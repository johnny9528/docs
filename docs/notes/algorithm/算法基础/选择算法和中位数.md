# 选择算法和中位数

### 1. 描述

在一个数组中， 寻找第 m小的数（特殊情况就是寻找中位数）， 如果使用先排序算法， 再判断，显示是不可取的， 因为只需要找到某一个数字， 而不需要将整个数组都进行排序。本次笔记内容则记录和分析了一个线性时间复杂度的算法。 笔记中以中位数问题进行呈现。

### 1. 算法思路

* 对数组进行一趟快速排序(注意是一趟， 即一个主元)， 假设得到在索引位置k，k的左边都比它小， 右边都比它大。
* 如果k小于 n/2(期望的中位数的位置)， 那么中位数一定在在k的右边。反之
* 递归进行上述步骤， 直到找到中位数

### 2. 性能分析

先假设一种状态， 比如每次快速排序的位置都是该次排序的 1/10 处(可以是任何值， 只是假设每次都是固定的值)， 那么递归表达式有：

`T(n) = T(9n/10) + Theta(n)` 

根据递归树的相关理论（第三种情况）， 得到复杂度为 `T(n) = O(n)`。

因此， 不管是采用随机化主元的方式（参考随机快速排序）， 还是平均而言， 算法的渐进复杂度是线性的。

但是， 存在最坏的情况， 就是每次递归的数组长度都只减少了1，那么表达式变成：

`T(n) = T(n - 1) + Theta(n)`  ， 得到复杂度为 `O(n^2)`

因此， 该算法是渐进线性的算法， 但是存在最坏情况， 复杂度达到二次方。采用随机主元可以解决这种最坏情况的产生， 使得算法变为线性算法。

### 3. 延展(了解)

虽然采用随机化的方式， 可以解决最坏情况的问题， 但是随机化， 总会有很小很小的概率会出现， 仍然是最坏的情况（这种概率很小很小）。引申出一个该种情况下的线性复杂度的算法。 该算法比较难理解， 了解就好。

大致思路是， 分成 5 * n/5 的（为什么是5， 因为5是满足条件的最小值， 7也可以， 性能似乎没有提升）网状， 每次递归中每五个先寻找中位数， 然后整体再次寻找中位数。

