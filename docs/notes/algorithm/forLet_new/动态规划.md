# 动态规划

## 5 最长回文子串(M）

### 描述

[链接](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```
求字符串的最长回文子串
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

### 分析

#### 暴力方式

暴力方式思想是， 获取所有子串， 然后判断该子串是否是回文子串。思路简单， 复杂度 `O(n^3)`

暴力方式一个优化思路是剪枝， 假设当前的已经得到的最大回文子串长度， 那么小于该长度的子串就不用再判断是否是回文子串。

#### 动态规划

回文子串具有明显的状态转移特性， 即一个回文子串， 代表左右字符相等， 同时里面仍然是一个回文子串。即，如果`s[i,j]`是回文子串， 意味着， `c[i]=c[j] && s[i+1,j-1]是回文子串`

因此写出状态转移方程为：

```
1. 如果字符串长度为1，即 j-i+1 = 1, 那么s[i,j] = true
2. 如果c[i]=c[j] 
	2.1 如果字符串长度为2或者3,即 j-i+1 <=3， 那么s[i,j]=true
	2.2 s[i,j] = s[i+1,j-1]
```

因此， 最核心的一步是2.2中的方程， 并且可以知道， `s[i,j]`依赖于`s[i+1,j-1]`， 即二维数组中当前结果依赖于左下角的结果，因此动态规划的顺序是一列一列的求， 而不是一行一行。

#### 中心扩散

回文串一定有一个中心部分， 如果回文串的长度为奇数，那么中心部分就是最中间的字符， 如果为偶数， 就是中间的两个部分。统一起来， 奇数的时候可能看成两个相等的字符。

根据中心， 向两边扩散，仍然是回文串则继续扩散， 否则停止， 这样可以求得每一个中心部分对应的最大回文串。而总共有s.length个中心部分， 即每一个字符或者相邻字符都可以是中心部分。

中心扩散的时间复杂度和动态规划一样，都是`O(n^2)`, 但是实际上， 中心扩散更好， 因此其只用扫描`O(2n)`个元素，只是在扩散的时候， 复杂度为`O(n)`， 结合起来是`O(n^2)`，但是扩散的时候， 一旦不满足， 就会跳出扩散，实际上会更快。而动态规划需要扫描`O(n^2)个元素`。并且， 中心扩散的空间复杂度比动态规划小。

### 实现

#### 暴力+剪枝

```java
class Solution {
    public String longestPalindrome(String s) {
        int maxLen = 0;
        int start = 0;
        for(int i = 0; i < s.length(); i++) {
            for(int j = i; j < s.length(); j++) {
                if(j - i + 1 <= maxLen) continue;
                if(isPalindrom(s, i, j)) {
                    start = i;
                    maxLen = j - i + 1;
                }
            }
        }
        return s.substring(start, start + maxLen);
    }

    public boolean isPalindrom(String s, int start, int end) {
        if(end - start + 1 <= 1) return true;
        while(start < end) {
            if(s.charAt(start) != s.charAt(end)) return false;
            start += 1;
            end -= 1;
        }
        return true;
    }
}
```

#### 动态规划

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len <= 1) return s; //字符串长度为0或者1， 直接返回
      
      
        boolean[][] dp = new boolean[len][len]; //创建二维数组，dp[i][j]代表子串i-j是否是回文串
        
      	int maxLen = 1;
        int startIndex = 0;
        for(int i = 0; i < len; i++) dp[i][i] = true; //对角线一定是回文串(这步其实可有可无，加上意义更清晰)

      	//开始动态规划， 一列一列进行
        for(int j = 1; j < len; j++) {
            for(int i = 0; i <= j; i++) {
                if(s.charAt(i) == s.charAt(j)) {
                    if(j - i + 1 <= 3) {
                        dp[i][j] = true;
                    }else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
										
                  	//接下来的操作是为了获取当前最大的回文串的下标和长度
                    if(dp[i][j] && j - i + 1 > maxLen) {
                        maxLen = j - i + 1;
                        startIndex = i;
                    }
                }
            }
        }

        return s.substring(startIndex, startIndex + maxLen);

    }
}
```

#### 中心扩散

```java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() <= 1) return s;
        String ans = "";
        for(int i = 0; i < s.length() - 1; i++) {
            String evenStr = centerSpread(s, i, i);//得到当前中心点为单个字符的最大回文串
            String ovenStr = centerSpread(s, i, i + 1);//得到当前中心点为两个字符的最大回文串
            String maxStr = evenStr.length() >= ovenStr.length() ? evenStr : ovenStr;
            if(maxStr.length() > ans.length()) {
                ans = maxStr;
            }
        }
        return ans;
    }
		
  	//核心方法， 针对每一个中心点， 得到当前的最大回文串
    public String centerSpread(String s, int left, int right) {
      
      //如果中心只有一个字符， 那么left=right，也是可以的。只要满足条件， 则向两边继续扩散
        while(left >= 0 && right < s.length()) {
            if(s.charAt(left) == s.charAt(right)) {
                left -= 1;
                right += 1;
            }else {
                break;
            }
        }
        return s.substring(left + 1, right);   
    }
}
```





-------------------------



## 10 正则表达式匹配(H)

### 描述

[链接](https://leetcode-cn.com/problems/regular-expression-matching/)

```
实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）
输入:
s = "aa"
p = "a*"
输出: true
```

### 分析

#### 动态规划

假设`dp[i][j]`表示字符串A的前`i`个和模式串B的前`j`个是否匹配。

* 如果`A[i]=B[j] 或者 B[j]='.'` 那么  `f[i][j]=f[i-1][j-1]`
* 如果`B[j]='*'` 
  * '*'代表之前字符重复0次， 直接忽略B中最近两个字符，有：`f[i][j]=f[i][j-2]`
  * '*'代表1个或多个， 那么必须满足 `A[i-1]=B[j-1]或者B[j-1]='.'`这一条件，此时，A串继续后移，B串不动。下一次比较`A[i]和B[j-1]`。
* 需要注意的是：
  * A串为空， B串不为空，结果不一定， 因为有'*'的存在。
  * A串为空， B串为空， 结果为true， 即`f[0][0]=true`
  * A串不为空， B串为空，结果一定是false， 即`f[0][j]=false`

#### 回溯法

回溯一般会由递归去实现， 即根据当前匹配结果以及子问题的结果， 综合得到结果。回溯的复杂度是比动态规划要高很多的， 因为可能涉及到重复计算。（动态规划就是空间换时间）

`f(String s, String p):`

* p的第一个字符不可能是 *， 那么如果第二个字符是 * ， 此时
  * *代表0个， 那么有 `f(s, p) = f(s, p[2:n])`
  * *代表1个或多个：
    * 不满足`s[0]=p[0]或者p[0]='.'`， 返回false
    * 满足上诉条件， 则将p移动一个即可： `f(s,p)=f(s[1:n], p)`
* p的第二个字符不是*, 那么正常匹配
  * `s[i]==s[j]或者s[j]='.'` 那么 很简单， `f(s,p)=f(s[1:n],p[1:n])`
  * 否则false

### 实现

#### 动态规划

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();

        boolean[][] dp = new boolean[m + 1][n + 1];

        for(int i = 0; i <= m; i++) {
            for(int j = 0; j <= n; j++) {
                if(j == 0) {

                    //根据分析，B串为空串， A串为空串则为true，A串不为空则为false
                    dp[i][j] = (i == 0);
                }else {

                    //不为*, 正常匹配
                    if(p.charAt(j - 1) != '*') {

                        if(i >= 1 && (s.charAt(i - 1) == p.charAt(j - 1) || '.' == p.charAt(j - 1))) {
                            dp[i][j] = dp[i - 1][j - 1];
                        }
                    }else {

                        //这是*代表0个字符的时候， 直接去掉B的最近两个字符
                        dp[i][j] = (j >= 2) && dp[i][j - 2];

                        //*代表1个或者多个字符，在A[i] == B[i - 1]的前提下，B串不动， A串后移
                        if(i >= 1 && j >= 2 && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) {
                            dp[i][j] |= dp[i - 1][j];
                        }
                    }
                }
            }
        }
        return dp[m][n];
    }
}
```

#### 回溯

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        if(n == 0) return (m == 0);
        boolean ans = false;
        boolean flag = (m > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.'));

        if(n >= 2 && p.charAt(1) == '*') {
            //代表0个
            ans = isMatch(s, p.substring(2));
            //代表多个
            ans = ans || (flag && isMatch(s.substring(1), p));
        }else {
            ans = flag && isMatch(s.substring(1), p.substring(1));
        }

        return ans;
    }
}
```





## 32. 最长有效括号(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/longest-valid-parentheses/)

```
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

### 分析

使用动态规划， 假设`dp[i]`是以第i个字符结束的最长的有效字串的长度。那么有以下几种情况：

* 第一种， 第i个字符是 左括号，以左括号结尾的一定不是有效字符，直接等于0
* 第二种，`s[i]`是右括号
  * `s[i-1]`是左括号，那么`s[i]`和`s[i-1]`能够匹配上，因此 `dp[i] = 2 + dp[i - 2]`
  * `s[i-1]`是右括号，那么i之前的`dp[i-1]`个字符，能够自己匹配上，现在要寻找到前面的第一个没有被使用的左括号。前面`dp[i-1]`个字符都被使用了(因为d[i-1]代表以i-1字符结束的最长字串，这一部分不能动)。因此
    * 如果 `s[i-dp[i-1]-1]`是右括号，那么以i结尾根本不可能合法，因为`s[i]`和`s[i-dp[i-1]-1]`这个右括号不能匹配，如果指望`s[i-dp[i-1]-1]`这个字符之前还有合适的左括号的话，那么为什么`dp[i-1]`不继续扩大呢
    * 这个字符是左括号，能够和`s[i]`进行匹配，加上2，加上中间的不能动的`dp[i-1]`， 加上`s[i-dp[i-1]-1]`这个字符之前的可能的最大的有效字符。

### 实现

```java
class Solution {
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int ans = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                // 当前字符为左括号，以他结尾的一定构不成有效的字符串
                continue;
            }

            if (s.charAt(i - 1) == '(') {
                // 当前字符为右括号，前一个为左括号，这俩匹配，加上之前的
                if (i == 1) {
                    dp[i] = 2;
                } else if (i > 1) {
                   dp[i] = 2 + dp[i - 2];
                }
            } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                // 这俩匹配成一组，加上中间的以及这个字符串之前的(如果有的话)
                if (i - dp[i - 1] >= 2) {
                    dp[i] = 2 + dp[i - 1] + dp[i - dp[i - 1] - 2];
                } else {
                    dp[i] = 2 + dp[i - 1];
                }
            }

            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```





## 44. 通配符匹配(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/wildcard-matching/)

```
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

### 分析

这个和正则表达式匹配很像，但是正则表达式种 * 代表的前一个字符有任意个， .代表前一个字符有1个， 而通配符匹配， * 代表任意个字符，比如  "*" 在正则表达式种是非法的，因为 * 和前面字符绑定， 而通配符种， "*"可以代表任意个字符

因此， 使用动态规划，`dp[i][j]`表示  s 的前i个和p的前j个是否匹配。

两类特殊情况， 如果 p的长度为0， s长度不为0， 一定是 false

如果s的长度为0， p的长度不为0， 那么如果要是true, p一定要全部是 星号组成

* `p[j]='?'或者 p[j]=s[i]`, 有 `dp[i][j]=dp[i-1][j-1]`
* `p[j]='*'`
  * *代表0个， `dp[i][j]=dp[i][j-1]`
  * *代表任意个，`dp[i][j]=dp[i-1][j]`

### 实现

```java
class Solution {
    public boolean isMatch(String s, String p) {

        int m = s.length();
        int n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true;

        // p如果为0， s如果不为0， 一定是false
        // s如果是0， p长度不为0， 那么如果要是true, 一定都得是星号
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = true;
            } else {
                break;
            }
        }


        // 正是通用dp
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                if (p.charAt(j - 1) == '?' || s.charAt(i - 1) == p.charAt(j - 1)) {
                    // 
                    dp[i][j] = dp[i - 1][j -1];
                } else if (p.charAt(j - 1) == '*') {
                    // * 代表0个字符
                    dp[i][j] = dp[i][j - 1];
                    // 代表任意个字符
                    dp[i][j] = dp[i][j] | dp[i - 1][j];
                }
            }
        }

        return dp[m][n];
    }
}
```



## 53. 最大子序和

### 描述

[链接](https://leetcode-cn.com/problems/maximum-subarray/)

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

### 分析

采用动态规划，遍历的时候，每次得到的局部最大值为右边界为当前元素的最大值。最终找到一个全局最大值

### 实现

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            dp[i + 1] = Math.max(0, dp[i]) + nums[i];
        }
        int ans = Integer.MIN_VALUE;
        for (int i = 1; i < dp.length; i++) {
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}

// 优化  由于求dp[i+1]的时候只和dp[i]有关，因此空间复杂度可以优化到 o(1)
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = Integer.MIN_VALUE;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            max = Math.max(0, max) + nums[i];
            ans = Math.max(ans, max);
        }
        return ans;
    }
}
```



## 62. 不同路径

### 描述

[链接](https://leetcode-cn.com/problems/unique-paths/)

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

```

### 分析

反向分析，如果知道一个点右边的点和下边的点有多少条路径，该点的路径就是二者之和。即

`count[i][j] = count[i + 1][j] + count[i][j + 1]`

构造一个dp的二维数组，存储每个点的路径个数，然后从右下角一直分析到左上角。

构造二维dp的题目，一般都应该思考一下，使用一维dp能否实现，可以减小空间复杂度。但是会降低程序的可读性

### 实现

```java
class Solution {
    public int uniquePaths(int m, int n) {
        if (m == 0 || n == 0) return 0;
        int[][] paths = new int[m + 1][n + 1];
        paths[m - 1][n] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                paths[i][j] = paths[i][j + 1] + paths[i + 1][j];
            }
        }
        return paths[0][0];
    }
}
```



## 63. 不同路径2

### 描述

[链接](https://leetcode-cn.com/problems/unique-paths-ii/)

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

```

### 分析

与上题唯一区别是障碍物，如果有障碍物，dp中直接设置为0即可。

同理，也可以优化空间复杂度，甚至直接采用输入的数组，让空间复杂度为o(1)

### 实现

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0) return 0;
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if (obstacleGrid[m - 1][n - 1] == 1) return 0;
        int[][] dp = new int[m + 1][n + 1];

        dp[m - 1][n] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
            }
        }
        return dp[0][0];
    }
}
```



## 64. 最小路径和

### 描述

[链接](https://leetcode-cn.com/problems/minimum-path-sum/)

```
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

### 分析

原理上上诉两题几乎一致，区别在于dp的条件为取右边一个点和下面一个点的最小值。

### 实现

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        int m = grid.length, n = grid[0].length;
        for (int i = m - 2; i >= 0; i--) {
            grid[i][n - 1] += grid[i + 1][n - 1];
        }
        for (int i = n - 2; i >= 0; i--) {
            grid[m - 1][i] += grid[m - 1][i + 1];
        }
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                grid[i][j] += Math.min(grid[i][j + 1], grid[i + 1][j]);
            }
        }
        return grid[0][0];
    }
}
```

## 70. 爬楼梯

### 描述

[链接](https://leetcode-cn.com/problems/climbing-stairs/)

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。
```

### 分析

简单的动态规划。从后往前，当前需要的个数等于上一阶的个数加上上两阶的个数

### 实现

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) return n; 
        int first = 2; int second = 1;
        for (int i = n - 2; i >= 1; i--) {
            int temp = second;
            second = first;
            first = first + temp;
        }
        return first;
    }
}
```



## 72. 编辑距离(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/edit-distance/)

```
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
插入一个字符
删除一个字符
替换一个字

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

```

### 分析

动态规划，`dp[i][j]`表示`word1`的前`i`个和`word2`的前`j`个的最小操作次数。

边界情况： `word1`和空字符串， 全部删除`word1`即可，操作次数是`word1`的长度。 空字符串和`word2`, 插入`word2`的长度即可

通常情况下分为下面几种情况：

* 因为已经知道了 `dp[i][j-1]`， 那么， `word1`删除第i个即可，操作次数加1
* 因为知道了`dp[i-1][j]`， 在i增加一个即可，操作次数加1
* 因为知道了`dp[i-1][j-1]`， 如果 `word1`的第i位和`word2`的第`j`位相等，什么也不干， 否则替换一个即可，操作加1
* 取上述三种方式的最小值即可

### 实现

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();

        int[][] dp = new int[m + 1][n + 1];
        
        // 如果i = 0, j不等于0， 那么i需要插入j个
        for (int j = 1; j <= n; j++) {
            dp[0][j] = j;
        }
        // 同理， j=0， i不等于0, 那么 i需要删除i个
        for (int i = 1; i <= m; i++) {
            dp[i][0] = i;
        }

        // 正式dp
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                // 已经知道了 dp[i - 1][j]， 那么i 增加一个即可
                dp[i][j] = dp[i - 1][j] + 1;

                // 已经知道了dp[i][j - 1]， 那么i删除一个即可
                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);

                // 已经知道了dp[i-1][j-1]
                // 如果word1[i] == word2[j], 那么什么都不用干
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                } else {
                    // 否则需要替换一个字符
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```





## 91. 解码方法

### 描述

[链接](https://leetcode-cn.com/problems/decode-ways/)

```
一条包含字母 A-Z 的消息通过以下方式进行了编码
'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。
```

### 分析

典型动态规划，一个数字可能成一种可能，两个数字可能成一种可能，当前状态只可能与前一个状态和前第二个状态有关系。

难点在于数字0的判断

### 实现

```java
class Solution {
    public int numDecodings(String s) {
        if (s == null || s.length() == 0 || s.charAt(0) == '0') return 0;
        int length = s.length();
        int[] dp = new int[length];
        dp[0] = 1;


        for (int i = 1; i < length; i++) {
            if (s.charAt(i) != '0') {
                dp[i] = dp[i - 1];
            } 
            int num = (s.charAt(i - 1) - '0') * 10 + (s.charAt(i) - '0');
            if (num <= 26 && num >= 10) {
                if (i == 1) {
                    dp[i] += 1;
                } else {
                    dp[i] += dp[i - 2];
                }
                
            }
        }
        return dp[length - 1];
    }
}
```



## 96. 不同的二叉搜索树

### 描述

[链接](https://leetcode-cn.com/problems/unique-binary-search-trees/)

```
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

### 分析

比如n = 5， 那么构成二叉搜索树的情况是：

* 1是root，那么左子树为0个，右字数为4个
* 2 是root， 左子树为1个，右子树为3个
* ...



因此很自然的想到用递归。  count(5) = count(1) * count(4) + count(2) * count(3) + count(3) * count(2) + ...

此时发现，有很多都重复使用了，因此可以采用动态规划，即牺牲空间做缓存，降低时间复杂度



### 实现

```java
// 纯递归  时间复杂度很高
class Solution {
    public int numTrees(int n) {
        if (n == 0 || n == 1) return 1;
        int ans = 0;
        for (int i = 1; i <= n; i++) {
             ans += numTrees(i - 1) * numTrees(n - i);
        }
        return ans;
    }
}

// 动态规划
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
}
```

## 95. 不同的二叉搜索树2

### 链接

[链接](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

```
给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

### 分析

每次固定root节点，然后递归构造左子树和右子树

### 实现

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) {
            return new LinkedList<>();
        }
        return getTree(1, n);
    }

    public List<TreeNode> getTree(int start, int end) {
        List<TreeNode> ans = new LinkedList<>();
        if (start == end) {
            ans.add(new TreeNode(start));
            return ans;
        }
        if (start > end) {
            ans.add(null);
            return ans;
        }

        for (int i = start; i <= end; i++) {
            List<TreeNode> subLeftAns = getTree(start, i - 1);
            List<TreeNode> subRightAns = getTree(i + 1, end);

            for (TreeNode temp_left : subLeftAns) {
                for (TreeNode temp_right : subRightAns) {
                    TreeNode root = new TreeNode(i);
                    root.left = temp_left;
                    root.right = temp_right;
                    ans.add(root);
                }
            }
        }
        return ans;
    }
}
```



## 115. 不同的子序列个数

### 题目描述

[链接](https://leetcode-cn.com/problems/distinct-subsequences/)

```
给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)
rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

### 分析

设`dp[i][j]`代表s的前i个字符， t的前i个字符子序列的个数

那么有一些特殊情况：

* 如果 i 小于 j， 那么一定不可能是子序列
* 空字符串是任意字符串的子序列

通用情况下：

* 如果 `s[i]==t[j]`， 此时有两种选择
  * j这个字符，就用i了， 那么 `dp[i][j]=dp[i-1][j-1]`
  * j这个字符，不是i这个字符提供的，那么， j这个字符一定是i-1之前提供的，因此`dp[i][j]=dp[i-1][j]`
* 如果二者不相等，那么只有一种情况
  * i这个字符，并没有什么卵用，j这个字符，由i-1之前提供， `dp[i][j]=dp[i-1][j]`

### 实现

```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        int[][] dp = new int[m + 1][n + 1];

        // 如果t是空字符串， 那么子序列个数就是1， 这一步很关键，也不好理解
        for (int i = 0; i <= m; i++) {
            dp[i][0] = 1;
        }

        // dp
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[m][n];
    }
}
```



## 120. 三角形最小路径和(和799香槟塔类似)

### 描述

[链接](https://leetcode-cn.com/problems/triangle/)

```
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

### 分析

简单递归，`dp`表示`(i, j)`位置上的最小路径和, 递推为左上和右上的最小值加上本身的值

可以对空间进行优化

### 实现

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[][] f = new int[n][n];
        f[0][0] = triangle.get(0).get(0);
        for (int i = 1; i < n; ++i) {
            f[i][0] = f[i - 1][0] + triangle.get(i).get(0);
            for (int j = 1; j < i; ++j) {
                f[i][j] = Math.min(f[i - 1][j - 1], f[i - 1][j]) + triangle.get(i).get(j);
            }
            f[i][i] = f[i - 1][i - 1] + triangle.get(i).get(i);
        }
        int minTotal = f[n - 1][0];
        for (int i = 1; i < n; ++i) {
            minTotal = Math.min(minTotal, f[n - 1][i]);
        }
        return minTotal;
    }
}
```



## 121. 买卖股票的最佳时机

### 题目描述

[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

### 分析

保存当天之前买入的时候的最小金额，然后如果当天卖出，则当天的收益就能计算出来

### 实现

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPriceSinceBuy = Integer.MAX_VALUE;
        int ans = 0;
        for (int i = 0; i < prices.length; i++) {
            minPriceSinceBuy = Math.min(minPriceSinceBuy, prices[i]);
            ans = Math.max(ans, prices[i] - minPriceSinceBuy);
        }
        return ans;
    }
}
```





## 132. 分割回文串(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

```
给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
返回符合要求的最少分割次数。
输入: "aab"
输出: 1
解释: 进行一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```

### 分析

动态规划，假设`dp[i]`是前i个字串的最少分割次数。那么有：

`dp[i] = Math.min(如果  j 到 i的字串是回文串的前提下， dp[j])`，两层循环即可.

判断是否是回文串那部分，会出现很多重复，可以优化

### 实现

```java
class Solution {
    public int minCut(String s) {
        int len = s.length();
        
        int[] dp = new int[len + 1];
        Arrays.fill(dp, len + 1);
        dp[0] = 0;
        for (int i = 1; i <= len; i++) {
            for (int j = 0; j < i; j++) {
                if (isTrue(s, j, i - 1)) {// 如果 j 到 i的字串是回文串的前提下，取dp[j] + 1的最小的数
                    dp[i] = Math.min(dp[i], dp[j] + 1);
                }
            }
        }
        return dp[len] - 1;  // dp[len]是分割的之后的个数，需要减1才是分割的次数

       
    }


        // 判断是否是回文串
    private boolean isTrue(String s, int left, int right) {
        if (left > right) {
            return false;
        }

        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left += 1;
            right -= 1;
        }
        return true;
    }

}
```





## 139. 单词拆分(M

### 题目描述

[链接](https://leetcode-cn.com/problems/word-break/)

```
给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

### 分析

假设`dp[i]`是前`i`个字符串是否能被拆分。那么有`dp[i] = dp[j] && s(i,j)在单词列表中`， 其中 `j`小于`i`，两层遍历即可

### 实现

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        for (String word : wordDict) {
            set.add(word);
        }

        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                boolean isTrue = dp[j] && set.contains(s.substring(j, i)); // 是否能这么拆
                if (isTrue) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```





## 152. 乘积最大子数组

### 描述

```
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

### 分析

很显然的动态规划， 但是需要考虑的是， 如果当前数字是个负数，则之前的乘积为负数才能达到最大值。即之前应该为负数的最大值， 即最小值。所以需要保存之前的最小值。

`dp`问题都可以考虑优化空间复杂度，此问题也可以优化到`o1`

### 实现

```java
class Solution {
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return -1;

        int[] dp1 = new int[nums.length];  // 存储包含当前值的最大值
        int[] dp2 = new int[nums.length];  // 存储最小值
        dp1[0] = nums[0];
        dp2[0] = nums[0];
        int ans = nums[0];

        for (int i = 1; i < nums.length; i++) {
            dp1[i] = Math.max(nums[i] * dp1[i - 1], Math.max(nums[i] * dp2[i - 1], nums[i]));
            dp2[i] = Math.min(nums[i] * dp1[i - 1], Math.min(nums[i] * dp2[i - 1], nums[i]));

            if (ans < dp1[i]) {
                ans = dp1[i];
            }
        }
        return ans;
    }
}
```



## 198. 打家劫舍

### 描述

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

```

### 分析

动态规划的两种考虑点：

* dp[i]代表一定包含当前点的情况下的最优解
* dp[i]代表前i个的最优解

本题应该选择后者，如果dp[i]代表前i个房子能够取得的最大收益， 那么i+1，只有两种情况，第一，偷该房子，那么只能选择d[i - 1]个房子的最大收益，第二种情况，不偷 i+1， 那么最大收益为 dp[i]；

需要考虑一种情况是，如果 dp[i]的最优解也是第i个没有被偷，那么  dp[i] 一定等于dp[i-1]，所以dp[i - 1] + nums[i] 就等于dp[i] + nums[i]。

### 实现

```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 0) return 0;
        int[] dp = new int[nums.length + 1]; // 代表前i个房屋的最大收益
        dp[1] = nums[0];
        for (int i = 2; i <= nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
        }
        return dp[nums.length];
        
    }
}
```

## 199. 打家劫舍2

### 描述

```
类似于上一题， 但是房子是环形的
```



### 分析

房子是环形的，拆成两部分分别计算，第一部分是1号房子到倒数第二个房子。一部分是第二个房子到最后一个房子。

### 实现

```java

class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
		if(nums.length == 1) return nums[0];
		if(nums.length == 2) return Math.max(nums[0], nums[1]);
       return Math.max(rob1(nums,0,nums.length - 2), rob1(nums, 1, nums.length - 1));
    }
    public int rob1(int[] nums, int start, int end) {
        int temp1 = 0;
        int temp2 = 0;
        for(int i = start; i <= end; i++) {
            int temp_max = Math.max(temp1 + nums[i], temp2);
            temp1 = temp2;
            temp2 = temp_max;
        }
        return temp2;
    }
}
```



## 221 最大正方形

### 描述

```
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

### 分析

dp [i] [j] 代表i， j位置为右下角的最大边长度  **

如果该位置的值是 0，则 dp(i, j) = 0dp(i,j)=0，因为当前位置不可能在由 1 组成的正方形中；

如果该位置的值是 1，则 dp(i, j)dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 11，状态转移方程如下：

### 实现

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int maxLength = 0;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int[][] dp = new int[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j== 0) {
                        dp[i][j] = 1;
                    }else {
                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                }
                maxLength = Math.max(maxLength, dp[i][j]);
            }
        }
        return maxLength * maxLength;
    }
}
```



## 264 丑数2

### 描述

```
编写一个程序，找出第 n 个丑数。

丑数就是质因数只包含 2, 3, 5 的正整数。
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数
```

### 分析

让我们从数组中只包含一个丑数数字 1 开始，使用三个指针代表下一个乘以2，3，5的值。然后找到下一个丑数，然后更新某一个指针(可能同时更新多个指针，因为最小值可能同时等于 x1 * 2  和 x2 * 3 )

### 实现

```java
// 三个 if 不能是 if else if  ，因为可能存在同时更新多个指针的情况，必须都去判断
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int count2 = 0, count3 = 0, count5 = 0;
        
        for (int i = 1; i < n; i++) {
            int nextOne = Math.min(dp[count2] * 2, Math.min(dp[count3] * 3, dp[count5] * 5));
            dp[i] = nextOne;
            if (nextOne == dp[count2] * 2) count2 += 1;
            if (nextOne == dp[count3] * 3) count3 += 1;
            if (nextOne == dp[count5] * 5) count5 += 1;

        }
        return dp[n - 1];
    }
}
```



## 799. 香槟塔

### 描述

[题目链接](https://leetcode-cn.com/problems/champagne-tower/)

```
我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。
从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）

现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。


示例 1:
输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.0
解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。

示例 2:
输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.5
解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。

```

### 分析

某个香槟杯子的上一层的两个杯子，如果满了，都会有一半的香槟流向这个杯子。

假设`dp[i][j]` 代表的是流经这个杯子的总的香槟，那么会有递推：`dp[i][j] = (dp[i - 1][j - 1] - 1) / 2  + (dp[i - 1][j] - 1) / 2`

### 实现

```java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        double[][] dp = new double[101][101];  // dp[i][j]表示流经该杯子的总的香槟数量。如果大于1说明最终会满，反之
        dp[1][1] = poured;  // 所有的水都会经过 第一个杯子

        for (int level = 2; level <= 100; level++) {
            for (int num = 1; num <= level; num++) {
                if (dp[level - 1][num - 1] > 1) {  // 左上的杯子超过1，会有溢出的一半香槟流到这个杯子
                    dp[level][num] += (dp[level - 1][num - 1] - 1) / 2;
                }

                if (dp[level - 1][num] > 1) { // 右上的杯子超过1，也会有一半的香槟流到这个杯子
                    dp[level][num] += (dp[level - 1][num] - 1) / 2;
                }
            }
        }

        return dp[query_row + 1][query_glass + 1] > 1 ? 1.0 : dp[query_row + 1][query_glass + 1];
    }
}
```



## 801. 使得序列递增的最小交换次数

### 题目描述

[链接](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/)

```
我们有两个长度相等且不为空的整型数组 A 和 B 。
我们可以交换 A[i] 和 B[i] 的元素。注意这两个元素在各自的序列中应该处于相同的位置。
在交换过一些元素之后，数组 A 和 B 都应该是严格递增的（数组严格递增的条件仅为A[0] < A[1] < A[2] < ... < A[A.length - 1]）。
给定数组 A 和 B ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。

示例:
输入: A = [1,3,5,4], B = [1,2,3,7]
输出: 1
解释: 
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。

```

### 分析

构造两个数组，yes[i] 表示当前索引交换之后，序列有序的最小次数；no[i]表示当前索引不交换，序列有序的最小次数。

* 当 `A[i] > A[i - 1]  && B[i] > B[i - 1]`  并且 `A[i-1] < B[i] && B[i-1] < A[i]`的时候， 那么此时，交换或者不交换都是有序的。那么有 `yes[i] = Math.min(yes[i - 1], no[i - 1])  + 1`,  `no[i] = Math.min(yes[i - 1], no[i - 1])`
* 当各自有序，但是交叉不是有序，即  `A[i] > A[i - 1]  && B[i] > B[i - 1]`  但是 `A[i-1] < B[i] || B[i-1] < A[i]`， 那么此时， 如果上一次交换，那么这一次必须交换，如果上一次不交换，那么这一次也不能交换。所以有 `yes[i] = yes[i - 1] + 1`,  `no[i] = no[i - 1]`
* 当各自都不满足有序的时候，那么上一次交换，这一次不能交换，如果上一次没有交换，这一次必须交换。于是有 `yes[i] = no[i - 1] + 1`  , `no[i] = yes[i - 1]`

### 实现

```java
class Solution {
    public int minSwap(int[] A, int[] B) {
        int length = A.length;
        if (length == 0) return 0;
        int[] yes = new int[length];  // 当前索引交换后，使得当前有序的最小交换次数
        int[] no = new int[length];  // 当前索引不交换，使得当前有序的最小交换次数
        no[0] = 0;  // 第一个值，既可以交换，也可以不交换
        yes[0] = 1;

        for (int i = 1; i < length; i++) {
            if (A[i] > A[i - 1] && B[i] > B[i - 1] &&  A[i] > B[i - 1] && B[i] > A[i - 1]) {
                // 既满足  各自有序，也满足交叉有序。那么这一次交换与否，不依赖于上一次的情况
                no[i] = Math.min(no[i - 1], yes[i - 1]);
                yes[i] = Math.min(yes[i - 1],no[i - 1]) + 1;
            } 
            else if (A[i] > A[i - 1] && B[i] > B[i - 1] ) {
                // 满足各自有序， 不满足交叉有序
                // 之前没有换，现在不能换，之前换了，现在必须换
                no[i] = no[i - 1];
                yes[i] = yes[i - 1] + 1;
            }
            else {
                // 不满足各自有序
                // 之前没有换，这次必须换，之前换了，这次不能换
                no[i] = yes[i - 1];
                yes[i] = no[i - 1] + 1;
            }
        }

        return Math.min(yes[length - 1], no[length - 1]);
    }
}
```



## 813. 最大平均值和的分组

### 描述

[链接](https://leetcode-cn.com/problems/largest-sum-of-averages/)

```
我们将给定的数组 A 分成 K 个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。
注意我们必须使用 A 数组中的每一个数进行分组，并且分数不一定需要是整数。

示例:
输入: 
A = [9,1,2,3,9]
K = 3
输出: 20
解释: 
A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.
我们也可以把 A 分成[9, 1], [2], [3, 9].
这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.
```

### 分析

假设 `dp[i][k]` 为 数组的前 `i`个如果分为 k个的最大的平均值和。比如要求 前5个，分为3个组的最大平均值和。那么去求

* 前 1 个数 分为2个组，此种情况不可能
* 前2个数分为2个组，然后求 3到5的平均值 ，加起来
* 前3个数分为2个组，然后求4到5的平均值，加起来
* 前4个数分为2个组，然后求5的平均值，加起来

求得上面的值，取最大值，作为本次`dp`的最终值

每次求平均值的地方可以优化，利用已经求的的平均值进行求取。但是保证逻辑的清晰，还是用最基本的方式求

### 实现

```java
class Solution {
    public double largestSumOfAverages(int[] A, int K) {
        int length = A.length;
        double[][] dp = new double[length + 1][K + 1];

        // 第一层得事先求，因为后面得层都依赖于第一层
        for (int i = 1; i <= length; i++) {
            dp[i][1] = getAverage(A, 0, i - 1);
        }

        for (int count = 2; count <= K; count++) {
            for (int i = count; i <= length; i++) {  // i 从 count 开始，因为如果i 小于count，是不可能的，没有意义
                for (int j = count - 1; j < i; j++) {// 同理，j如果小于count-1，也是不可能的
                    dp[i][count] = Math.max(dp[i][count], dp[j][count - 1] + getAverage(A, j, i - 1));
                }
            }
        }

        return dp[length][K];
    }

    /**
        求某一段的平均值(可以优化，根据之前一个 dp 的值去求，复杂度为 o(1), 但是保证逻辑的清晰性，还是用这种方式求)
    **/
    public double getAverage(int[] nums, int i, int j) {
        double ans = 0;
        for (int index = i; index <= j; index++) {
            ans += nums[index];
        }
        return ans / (j - i + 1);
    }
}
```

