# 动态规划

## 5 最长回文子串(M）

### 描述

[链接](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```
求字符串的最长回文子串
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

### 分析

#### 暴力方式

暴力方式思想是， 获取所有子串， 然后判断该子串是否是回文子串。思路简单， 复杂度 `O(n^3)`

暴力方式一个优化思路是剪枝， 假设当前的已经得到的最大回文子串长度， 那么小于该长度的子串就不用再判断是否是回文子串。

#### 动态规划

回文子串具有明显的状态转移特性， 即一个回文子串， 代表左右字符相等， 同时里面仍然是一个回文子串。即，如果`s[i,j]`是回文子串， 意味着， `c[i]=c[j] && s[i+1,j-1]是回文子串`

因此写出状态转移方程为：

```
1. 如果字符串长度为1，即 j-i+1 = 1, 那么s[i,j] = true
2. 如果c[i]=c[j] 
	2.1 如果字符串长度为2或者3,即 j-i+1 <=3， 那么s[i,j]=true
	2.2 s[i,j] = s[i+1,j-1]
```

因此， 最核心的一步是2.2中的方程， 并且可以知道， `s[i,j]`依赖于`s[i+1,j-1]`， 即二维数组中当前结果依赖于左下角的结果，因此动态规划的顺序是一列一列的求， 而不是一行一行。

#### 中心扩散

回文串一定有一个中心部分， 如果回文串的长度为奇数，那么中心部分就是最中间的字符， 如果为偶数， 就是中间的两个部分。统一起来， 奇数的时候可能看成两个相等的字符。

根据中心， 向两边扩散，仍然是回文串则继续扩散， 否则停止， 这样可以求得每一个中心部分对应的最大回文串。而总共有s.length个中心部分， 即每一个字符或者相邻字符都可以是中心部分。

中心扩散的时间复杂度和动态规划一样，都是`O(n^2)`, 但是实际上， 中心扩散更好， 因此其只用扫描`O(2n)`个元素，只是在扩散的时候， 复杂度为`O(n)`， 结合起来是`O(n^2)`，但是扩散的时候， 一旦不满足， 就会跳出扩散，实际上会更快。而动态规划需要扫描`O(n^2)个元素`。并且， 中心扩散的空间复杂度比动态规划小。

### 实现

#### 暴力+剪枝

```java
class Solution {
    public String longestPalindrome(String s) {
        int maxLen = 0;
        int start = 0;
        for(int i = 0; i < s.length(); i++) {
            for(int j = i; j < s.length(); j++) {
                if(j - i + 1 <= maxLen) continue;
                if(isPalindrom(s, i, j)) {
                    start = i;
                    maxLen = j - i + 1;
                }
            }
        }
        return s.substring(start, start + maxLen);
    }

    public boolean isPalindrom(String s, int start, int end) {
        if(end - start + 1 <= 1) return true;
        while(start < end) {
            if(s.charAt(start) != s.charAt(end)) return false;
            start += 1;
            end -= 1;
        }
        return true;
    }
}
```

#### 动态规划

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len <= 1) return s; //字符串长度为0或者1， 直接返回
      
      
        boolean[][] dp = new boolean[len][len]; //创建二维数组，dp[i][j]代表子串i-j是否是回文串
        
      	int maxLen = 1;
        int startIndex = 0;
        for(int i = 0; i < len; i++) dp[i][i] = true; //对角线一定是回文串(这步其实可有可无，加上意义更清晰)

      	//开始动态规划， 一列一列进行
        for(int j = 1; j < len; j++) {
            for(int i = 0; i <= j; i++) {
                if(s.charAt(i) == s.charAt(j)) {
                    if(j - i + 1 <= 3) {
                        dp[i][j] = true;
                    }else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
										
                  	//接下来的操作是为了获取当前最大的回文串的下标和长度
                    if(dp[i][j] && j - i + 1 > maxLen) {
                        maxLen = j - i + 1;
                        startIndex = i;
                    }
                }
            }
        }

        return s.substring(startIndex, startIndex + maxLen);

    }
}
```

#### 中心扩散

```java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length() <= 1) return s;
        String ans = "";
        for(int i = 0; i < s.length() - 1; i++) {
            String evenStr = centerSpread(s, i, i);//得到当前中心点为单个字符的最大回文串
            String ovenStr = centerSpread(s, i, i + 1);//得到当前中心点为两个字符的最大回文串
            String maxStr = evenStr.length() >= ovenStr.length() ? evenStr : ovenStr;
            if(maxStr.length() > ans.length()) {
                ans = maxStr;
            }
        }
        return ans;
    }
		
  	//核心方法， 针对每一个中心点， 得到当前的最大回文串
    public String centerSpread(String s, int left, int right) {
      
      //如果中心只有一个字符， 那么left=right，也是可以的。只要满足条件， 则向两边继续扩散
        while(left >= 0 && right < s.length()) {
            if(s.charAt(left) == s.charAt(right)) {
                left -= 1;
                right += 1;
            }else {
                break;
            }
        }
        return s.substring(left + 1, right);   
    }
}
```





-------------------------



## 10 正则表达式匹配(H)

### 描述

[链接](https://leetcode-cn.com/problems/regular-expression-matching/)

```
实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）
输入:
s = "aa"
p = "a*"
输出: true
```

### 分析

#### 动态规划

假设`dp[i][j]`表示字符串A的前`i`个和模式串B的前`j`个是否匹配。

* 如果`A[i]=B[j] 或者 B[j]='.'` 那么  `f[i][j]=f[i-1][j-1]`
* 如果`B[j]='*'` 
  * '*'代表之前字符重复0次， 直接忽略B中最近两个字符，有：`f[i][j]=f[i][j-2]`
  * '*'代表1个或多个， 那么必须满足 `A[i-1]=B[j-1]或者B[j-1]='.'`这一条件，此时，A串继续后移，B串不动。下一次比较`A[i]和B[j-1]`。
* 需要注意的是：
  * A串为空， B串不为空，结果不一定， 因为有'*'的存在。
  * A串为空， B串为空， 结果为true， 即`f[0][0]=true`
  * A串不为空， B串为空，结果一定是false， 即`f[0][j]=false`

#### 回溯法

回溯一般会由递归去实现， 即根据当前匹配结果以及子问题的结果， 综合得到结果。回溯的复杂度是比动态规划要高很多的， 因为可能涉及到重复计算。（动态规划就是空间换时间）

`f(String s, String p):`

* p的第一个字符不可能是 *， 那么如果第二个字符是 * ， 此时
  * *代表0个， 那么有 `f(s, p) = f(s, p[2:n])`
  * *代表1个或多个：
    * 不满足`s[0]=p[0]或者p[0]='.'`， 返回false
    * 满足上诉条件， 则将p移动一个即可： `f(s,p)=f(s[1:n], p)`
* p的第二个字符不是*, 那么正常匹配
  * `s[i]==s[j]或者s[j]='.'` 那么 很简单， `f(s,p)=f(s[1:n],p[1:n])`
  * 否则false

### 实现

#### 动态规划

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();

        boolean[][] dp = new boolean[m + 1][n + 1];

        for(int i = 0; i <= m; i++) {
            for(int j = 0; j <= n; j++) {
                if(j == 0) {

                    //根据分析，B串为空串， A串为空串则为true，A串不为空则为false
                    dp[i][j] = (i == 0);
                }else {

                    //不为*, 正常匹配
                    if(p.charAt(j - 1) != '*') {

                        if(i >= 1 && (s.charAt(i - 1) == p.charAt(j - 1) || '.' == p.charAt(j - 1))) {
                            dp[i][j] = dp[i - 1][j - 1];
                        }
                    }else {

                        //这是*代表0个字符的时候， 直接去掉B的最近两个字符
                        dp[i][j] = (j >= 2) && dp[i][j - 2];

                        //*代表1个或者多个字符，在A[i] == B[i - 1]的前提下，B串不动， A串后移
                        if(i >= 1 && j >= 2 && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) {
                            dp[i][j] |= dp[i - 1][j];
                        }
                    }
                }
            }
        }
        return dp[m][n];
    }
}
```

#### 回溯

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        if(n == 0) return (m == 0);
        boolean ans = false;
        boolean flag = (m > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.'));

        if(n >= 2 && p.charAt(1) == '*') {
            //代表0个
            ans = isMatch(s, p.substring(2));
            //代表多个
            ans = ans || (flag && isMatch(s.substring(1), p));
        }else {
            ans = flag && isMatch(s.substring(1), p.substring(1));
        }

        return ans;
    }
}
```





## 32. 最长有效括号(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/longest-valid-parentheses/)

```
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

### 分析

使用动态规划， 假设`dp[i]`是以第i个字符结束的最长的有效字串的长度。那么有以下几种情况：

* 第一种， 第i个字符是 左括号，以左括号结尾的一定不是有效字符，直接等于0
* 第二种，`s[i]`是右括号
  * `s[i-1]`是左括号，那么`s[i]`和`s[i-1]`能够匹配上，因此 `dp[i] = 2 + dp[i - 2]`
  * `s[i-1]`是右括号，那么i之前的`dp[i-1]`个字符，能够自己匹配上，现在要寻找到前面的第一个没有被使用的左括号。前面`dp[i-1]`个字符都被使用了(因为d[i-1]代表以i-1字符结束的最长字串，这一部分不能动)。因此
    * 如果 `s[i-dp[i-1]-1]`是右括号，那么以i结尾根本不可能合法，因为`s[i]`和`s[i-dp[i-1]-1]`这个右括号不能匹配，如果指望`s[i-dp[i-1]-1]`这个字符之前还有合适的左括号的话，那么为什么`dp[i-1]`不继续扩大呢
    * 这个字符是左括号，能够和`s[i]`进行匹配，加上2，加上中间的不能动的`dp[i-1]`， 加上`s[i-dp[i-1]-1]`这个字符之前的可能的最大的有效字符。

### 实现

```java
class Solution {
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int ans = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                // 当前字符为左括号，以他结尾的一定构不成有效的字符串
                continue;
            }

            if (s.charAt(i - 1) == '(') {
                // 当前字符为右括号，前一个为左括号，这俩匹配，加上之前的
                if (i == 1) {
                    dp[i] = 2;
                } else if (i > 1) {
                   dp[i] = 2 + dp[i - 2];
                }
            } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                // 这俩匹配成一组，加上中间的以及这个字符串之前的(如果有的话)
                if (i - dp[i - 1] >= 2) {
                    dp[i] = 2 + dp[i - 1] + dp[i - dp[i - 1] - 2];
                } else {
                    dp[i] = 2 + dp[i - 1];
                }
            }

            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```





## 44. 通配符匹配(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/wildcard-matching/)

```
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

### 分析

这个和正则表达式匹配很像，但是正则表达式种 * 代表的前一个字符有任意个， .代表前一个字符有1个， 而通配符匹配， * 代表任意个字符，比如  "*" 在正则表达式种是非法的，因为 * 和前面字符绑定， 而通配符种， "*"可以代表任意个字符

因此， 使用动态规划，`dp[i][j]`表示  s 的前i个和p的前j个是否匹配。

两类特殊情况， 如果 p的长度为0， s长度不为0， 一定是 false

如果s的长度为0， p的长度不为0， 那么如果要是true, p一定要全部是 星号组成

* `p[j]='?'或者 p[j]=s[i]`, 有 `dp[i][j]=dp[i-1][j-1]`
* `p[j]='*'`
  * *代表0个， `dp[i][j]=dp[i][j-1]`
  * *代表任意个，`dp[i][j]=dp[i-1][j]`

### 实现

```java
class Solution {
    public boolean isMatch(String s, String p) {

        int m = s.length();
        int n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        dp[0][0] = true;

        // p如果为0， s如果不为0， 一定是false
        // s如果是0， p长度不为0， 那么如果要是true, 一定都得是星号
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = true;
            } else {
                break;
            }
        }


        // 正是通用dp
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                if (p.charAt(j - 1) == '?' || s.charAt(i - 1) == p.charAt(j - 1)) {
                    // 
                    dp[i][j] = dp[i - 1][j -1];
                } else if (p.charAt(j - 1) == '*') {
                    // * 代表0个字符
                    dp[i][j] = dp[i][j - 1];
                    // 代表任意个字符
                    dp[i][j] = dp[i][j] | dp[i - 1][j];
                }
            }
        }

        return dp[m][n];
    }
}
```



## 53. 最大子序和

### 描述

[链接](https://leetcode-cn.com/problems/maximum-subarray/)

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

### 分析

采用动态规划，遍历的时候，每次得到的局部最大值为右边界为当前元素的最大值。最终找到一个全局最大值

### 实现

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            dp[i + 1] = Math.max(0, dp[i]) + nums[i];
        }
        int ans = Integer.MIN_VALUE;
        for (int i = 1; i < dp.length; i++) {
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}

// 优化  由于求dp[i+1]的时候只和dp[i]有关，因此空间复杂度可以优化到 o(1)
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = Integer.MIN_VALUE;
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            max = Math.max(0, max) + nums[i];
            ans = Math.max(ans, max);
        }
        return ans;
    }
}
```



## 62. 不同路径

### 描述

[链接](https://leetcode-cn.com/problems/unique-paths/)

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

```

### 分析

反向分析，如果知道一个点右边的点和下边的点有多少条路径，该点的路径就是二者之和。即

`count[i][j] = count[i + 1][j] + count[i][j + 1]`

构造一个dp的二维数组，存储每个点的路径个数，然后从右下角一直分析到左上角。

构造二维dp的题目，一般都应该思考一下，使用一维dp能否实现，可以减小空间复杂度。但是会降低程序的可读性

### 实现

```java
class Solution {
    public int uniquePaths(int m, int n) {
        if (m == 0 || n == 0) return 0;
        int[][] paths = new int[m + 1][n + 1];
        paths[m - 1][n] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                paths[i][j] = paths[i][j + 1] + paths[i + 1][j];
            }
        }
        return paths[0][0];
    }
}
```



## 63. 不同路径2

### 描述

[链接](https://leetcode-cn.com/problems/unique-paths-ii/)

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

```

### 分析

与上题唯一区别是障碍物，如果有障碍物，dp中直接设置为0即可。

同理，也可以优化空间复杂度，甚至直接采用输入的数组，让空间复杂度为o(1)

### 实现

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0) return 0;
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if (obstacleGrid[m - 1][n - 1] == 1) return 0;
        int[][] dp = new int[m + 1][n + 1];

        dp[m - 1][n] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
            }
        }
        return dp[0][0];
    }
}
```



## 64. 最小路径和

### 描述

[链接](https://leetcode-cn.com/problems/minimum-path-sum/)

```
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

### 分析

原理上上诉两题几乎一致，区别在于dp的条件为取右边一个点和下面一个点的最小值。

### 实现

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        int m = grid.length, n = grid[0].length;
        for (int i = m - 2; i >= 0; i--) {
            grid[i][n - 1] += grid[i + 1][n - 1];
        }
        for (int i = n - 2; i >= 0; i--) {
            grid[m - 1][i] += grid[m - 1][i + 1];
        }
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                grid[i][j] += Math.min(grid[i][j + 1], grid[i + 1][j]);
            }
        }
        return grid[0][0];
    }
}
```

## 70. 爬楼梯

### 描述

[链接](https://leetcode-cn.com/problems/climbing-stairs/)

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。
```

### 分析

简单的动态规划。从后往前，当前需要的个数等于上一阶的个数加上上两阶的个数

### 实现

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) return n; 
        int first = 2; int second = 1;
        for (int i = n - 2; i >= 1; i--) {
            int temp = second;
            second = first;
            first = first + temp;
        }
        return first;
    }
}
```



## 72. 编辑距离(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/edit-distance/)

```
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
插入一个字符
删除一个字符
替换一个字

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

```

### 分析

动态规划，`dp[i][j]`表示`word1`的前`i`个和`word2`的前`j`个的最小操作次数。

边界情况： `word1`和空字符串， 全部删除`word1`即可，操作次数是`word1`的长度。 空字符串和`word2`, 插入`word2`的长度即可

通常情况下分为下面几种情况：

* 因为已经知道了 `dp[i][j-1]`， 那么， `word1`删除第i个即可，操作次数加1
* 因为知道了`dp[i-1][j]`， 在i增加一个即可，操作次数加1
* 因为知道了`dp[i-1][j-1]`， 如果 `word1`的第i位和`word2`的第`j`位相等，什么也不干， 否则替换一个即可，操作加1
* 取上述三种方式的最小值即可

### 实现

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();

        int[][] dp = new int[m + 1][n + 1];
        
        // 如果i = 0, j不等于0， 那么i需要插入j个
        for (int j = 1; j <= n; j++) {
            dp[0][j] = j;
        }
        // 同理， j=0， i不等于0, 那么 i需要删除i个
        for (int i = 1; i <= m; i++) {
            dp[i][0] = i;
        }

        // 正式dp
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                // 已经知道了 dp[i - 1][j]， 那么i 增加一个即可
                dp[i][j] = dp[i - 1][j] + 1;

                // 已经知道了dp[i][j - 1]， 那么i删除一个即可
                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);

                // 已经知道了dp[i-1][j-1]
                // 如果word1[i] == word2[j], 那么什么都不用干
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                } else {
                    // 否则需要替换一个字符
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```



## 583. 两个字符串的删除操作(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

```
给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

### 分析

思路1： 和上一道题是完全类似的。

**思路2**， 也是动态规划，但是含义不一样。 `dp[i][j]`是 `word1前 i`个字符串和 `word2前 j`个字符串的公共最长子序列。那么有

* 如果 `word1[i] == word[j]`, 有 `dp[i][j] = dp[i - 1][j - 1] + 1`
* 如果不相等， `dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])`

最后 的结果等于 `len(word1) + len(word2) - 2 * dp[len1][len2]`

因此，`dp`的含义不同，递推式也不同

### 实现

```java
// 方法1，和上一题类似
class Solution {
    public int minDistance(String word1, String word2) {
        
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];

        for (int i = 0; i <= word1.length(); i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= word2.length(); j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {

                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;
                }
            }
        }

        return dp[word1.length()][word2.length()];
    }
}


// 方法2
class Solution {
       public int minDistance(String s1, String s2) {
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        for (int i = 0; i <= s1.length(); i++) {
            for (int j = 0; j <= s2.length(); j++) {
                if (i == 0 || j == 0)
                    continue;
                if (s1.charAt(i - 1) == s2.charAt(j - 1))
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                else
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return s1.length() + s2.length() - 2 * dp[s1.length()][s2.length()];
    }
}
```







## 91. 解码方法

### 描述

[链接](https://leetcode-cn.com/problems/decode-ways/)

```
一条包含字母 A-Z 的消息通过以下方式进行了编码
'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。
```

### 分析

典型动态规划，一个数字可能成一种可能，两个数字可能成一种可能，当前状态只可能与前一个状态和前第二个状态有关系。

难点在于数字0的判断

### 实现

```java
class Solution {
    public int numDecodings(String s) {
        if (s == null || s.length() == 0 || s.charAt(0) == '0') return 0;
        int length = s.length();
        int[] dp = new int[length];
        dp[0] = 1;


        for (int i = 1; i < length; i++) {
            if (s.charAt(i) != '0') {
                dp[i] = dp[i - 1];
            } 
            int num = (s.charAt(i - 1) - '0') * 10 + (s.charAt(i) - '0');
            if (num <= 26 && num >= 10) {
                if (i == 1) {
                    dp[i] += 1;
                } else {
                    dp[i] += dp[i - 2];
                }
                
            }
        }
        return dp[length - 1];
    }
}
```



## 96. 不同的二叉搜索树

### 描述

[链接](https://leetcode-cn.com/problems/unique-binary-search-trees/)

```
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

### 分析

比如n = 5， 那么构成二叉搜索树的情况是：

* 1是root，那么左子树为0个，右字数为4个
* 2 是root， 左子树为1个，右子树为3个
* ...



因此很自然的想到用递归。  count(5) = count(1) * count(4) + count(2) * count(3) + count(3) * count(2) + ...

此时发现，有很多都重复使用了，因此可以采用动态规划，即牺牲空间做缓存，降低时间复杂度



### 实现

```java
// 纯递归  时间复杂度很高
class Solution {
    public int numTrees(int n) {
        if (n == 0 || n == 1) return 1;
        int ans = 0;
        for (int i = 1; i <= n; i++) {
             ans += numTrees(i - 1) * numTrees(n - i);
        }
        return ans;
    }
}

// 动态规划
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
}
```

## 95. 不同的二叉搜索树2

### 链接

[链接](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

```
给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

### 分析

每次固定root节点，然后递归构造左子树和右子树

### 实现

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) {
            return new LinkedList<>();
        }
        return getTree(1, n);
    }

    public List<TreeNode> getTree(int start, int end) {
        List<TreeNode> ans = new LinkedList<>();
        if (start == end) {
            ans.add(new TreeNode(start));
            return ans;
        }
        if (start > end) {
            ans.add(null);
            return ans;
        }

        for (int i = start; i <= end; i++) {
            List<TreeNode> subLeftAns = getTree(start, i - 1);
            List<TreeNode> subRightAns = getTree(i + 1, end);

            for (TreeNode temp_left : subLeftAns) {
                for (TreeNode temp_right : subRightAns) {
                    TreeNode root = new TreeNode(i);
                    root.left = temp_left;
                    root.right = temp_right;
                    ans.add(root);
                }
            }
        }
        return ans;
    }
}
```



## 115. 不同的子序列个数

### 题目描述

[链接](https://leetcode-cn.com/problems/distinct-subsequences/)

```
给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)
rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

### 分析

设`dp[i][j]`代表s的前i个字符， t的前i个字符子序列的个数

那么有一些特殊情况：

* 如果 i 小于 j， 那么一定不可能是子序列
* 空字符串是任意字符串的子序列

通用情况下：

* 如果 `s[i]==t[j]`， 此时有两种选择
  * j这个字符，就用i了， 那么 `dp[i][j]=dp[i-1][j-1]`
  * j这个字符，不是i这个字符提供的，那么， j这个字符一定是i-1之前提供的，因此`dp[i][j]=dp[i-1][j]`
* 如果二者不相等，那么只有一种情况
  * i这个字符，并没有什么卵用，j这个字符，由i-1之前提供， `dp[i][j]=dp[i-1][j]`

### 实现

```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        int[][] dp = new int[m + 1][n + 1];

        // 如果t是空字符串， 那么子序列个数就是1， 这一步很关键，也不好理解
        for (int i = 0; i <= m; i++) {
            dp[i][0] = 1;
        }

        // dp
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[m][n];
    }
}
```



## 120. 三角形最小路径和(和799香槟塔类似)

### 描述

[链接](https://leetcode-cn.com/problems/triangle/)

```
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

### 分析

简单递归，`dp`表示`(i, j)`位置上的最小路径和, 递推为左上和右上的最小值加上本身的值

可以对空间进行优化

### 实现

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[][] f = new int[n][n];
        f[0][0] = triangle.get(0).get(0);
        for (int i = 1; i < n; ++i) {
            f[i][0] = f[i - 1][0] + triangle.get(i).get(0);
            for (int j = 1; j < i; ++j) {
                f[i][j] = Math.min(f[i - 1][j - 1], f[i - 1][j]) + triangle.get(i).get(j);
            }
            f[i][i] = f[i - 1][i - 1] + triangle.get(i).get(i);
        }
        int minTotal = f[n - 1][0];
        for (int i = 1; i < n; ++i) {
            minTotal = Math.min(minTotal, f[n - 1][i]);
        }
        return minTotal;
    }
}
```



## 121. 买卖股票的最佳时机

### 题目描述

[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

### 分析

保存当天之前买入的时候的最小金额，然后如果当天卖出，则当天的收益就能计算出来

### 实现

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPriceSinceBuy = Integer.MAX_VALUE;
        int ans = 0;
        for (int i = 0; i < prices.length; i++) {
            minPriceSinceBuy = Math.min(minPriceSinceBuy, prices[i]);
            ans = Math.max(ans, prices[i] - minPriceSinceBuy);
        }
        return ans;
    }
}
```





## 132. 分割回文串(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)

```
给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
返回符合要求的最少分割次数。
输入: "aab"
输出: 1
解释: 进行一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```

### 分析

动态规划，假设`dp[i]`是前i个字串的最少分割次数。那么有：

`dp[i] = Math.min(如果  j 到 i的字串是回文串的前提下， dp[j])`，两层循环即可.

判断是否是回文串那部分，会出现很多重复，可以优化

### 实现

```java
class Solution {
    public int minCut(String s) {
        int len = s.length();
        
        int[] dp = new int[len + 1];
        Arrays.fill(dp, len + 1);
        dp[0] = 0;
        for (int i = 1; i <= len; i++) {
            for (int j = 0; j < i; j++) {
                if (isTrue(s, j, i - 1)) {// 如果 j 到 i的字串是回文串的前提下，取dp[j] + 1的最小的数
                    dp[i] = Math.min(dp[i], dp[j] + 1);
                }
            }
        }
        return dp[len] - 1;  // dp[len]是分割的之后的个数，需要减1才是分割的次数

       
    }


        // 判断是否是回文串
    private boolean isTrue(String s, int left, int right) {
        if (left > right) {
            return false;
        }

        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left += 1;
            right -= 1;
        }
        return true;
    }

}
```





## 139. 单词拆分(M

### 题目描述

[链接](https://leetcode-cn.com/problems/word-break/)

```
给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

### 分析

假设`dp[i]`是前`i`个字符串是否能被拆分。那么有`dp[i] = dp[j] && s(i,j)在单词列表中`， 其中 `j`小于`i`，两层遍历即可

### 实现

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        for (String word : wordDict) {
            set.add(word);
        }

        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                boolean isTrue = dp[j] && set.contains(s.substring(j, i)); // 是否能这么拆
                if (isTrue) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```





## 152. 乘积最大子数组

### 描述

```
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

### 分析

很显然的动态规划， 但是需要考虑的是， 如果当前数字是个负数，则之前的乘积为负数才能达到最大值。即之前应该为负数的最大值， 即最小值。所以需要保存之前的最小值。

`dp`问题都可以考虑优化空间复杂度，此问题也可以优化到`o1`

### 实现

```java
class Solution {
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return -1;

        int[] dp1 = new int[nums.length];  // 存储包含当前值的最大值
        int[] dp2 = new int[nums.length];  // 存储最小值
        dp1[0] = nums[0];
        dp2[0] = nums[0];
        int ans = nums[0];

        for (int i = 1; i < nums.length; i++) {
            dp1[i] = Math.max(nums[i] * dp1[i - 1], Math.max(nums[i] * dp2[i - 1], nums[i]));
            dp2[i] = Math.min(nums[i] * dp1[i - 1], Math.min(nums[i] * dp2[i - 1], nums[i]));

            if (ans < dp1[i]) {
                ans = dp1[i];
            }
        }
        return ans;
    }
}
```



## 198. 打家劫舍

### 描述

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

```

### 分析

动态规划的两种考虑点：

* dp[i]代表一定包含当前点的情况下的最优解
* dp[i]代表前i个的最优解

本题应该选择后者，如果dp[i]代表前i个房子能够取得的最大收益， 那么i+1，只有两种情况，第一，偷该房子，那么只能选择d[i - 1]个房子的最大收益，第二种情况，不偷 i+1， 那么最大收益为 dp[i]；

需要考虑一种情况是，如果 dp[i]的最优解也是第i个没有被偷，那么  dp[i] 一定等于dp[i-1]，所以dp[i - 1] + nums[i] 就等于dp[i] + nums[i]。

### 实现

```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 0) return 0;
        int[] dp = new int[nums.length + 1]; // 代表前i个房屋的最大收益
        dp[1] = nums[0];
        for (int i = 2; i <= nums.length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i - 1], dp[i - 1]);
        }
        return dp[nums.length];
        
    }
}
```

## 199. 打家劫舍2

### 描述

```
类似于上一题， 但是房子是环形的
```



### 分析

房子是环形的，拆成两部分分别计算，第一部分是1号房子到倒数第二个房子。一部分是第二个房子到最后一个房子。

### 实现

```java

class Solution {
    public int rob(int[] nums) {
        if(nums.length == 0) return 0;
		if(nums.length == 1) return nums[0];
		if(nums.length == 2) return Math.max(nums[0], nums[1]);
       return Math.max(rob1(nums,0,nums.length - 2), rob1(nums, 1, nums.length - 1));
    }
    public int rob1(int[] nums, int start, int end) {
        int temp1 = 0;
        int temp2 = 0;
        for(int i = start; i <= end; i++) {
            int temp_max = Math.max(temp1 + nums[i], temp2);
            temp1 = temp2;
            temp2 = temp_max;
        }
        return temp2;
    }
}
```



## 221 最大正方形

### 描述

```
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

### 分析

dp [i] [j] 代表i， j位置为右下角的最大边长度  **

如果该位置的值是 0，则 dp(i, j) = 0dp(i,j)=0，因为当前位置不可能在由 1 组成的正方形中；

如果该位置的值是 1，则 dp(i, j)dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 11，状态转移方程如下：

### 实现

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int maxLength = 0;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int[][] dp = new int[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j== 0) {
                        dp[i][j] = 1;
                    }else {
                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                }
                maxLength = Math.max(maxLength, dp[i][j]);
            }
        }
        return maxLength * maxLength;
    }
}
```



## 264 丑数2

### 描述

```
编写一个程序，找出第 n 个丑数。

丑数就是质因数只包含 2, 3, 5 的正整数。
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数
```

### 分析

让我们从数组中只包含一个丑数数字 1 开始，使用三个指针代表下一个乘以2，3，5的值。然后找到下一个丑数，然后更新某一个指针(可能同时更新多个指针，因为最小值可能同时等于 x1 * 2  和 x2 * 3 )

### 实现

```java
// 三个 if 不能是 if else if  ，因为可能存在同时更新多个指针的情况，必须都去判断
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int count2 = 0, count3 = 0, count5 = 0;
        
        for (int i = 1; i < n; i++) {
            int nextOne = Math.min(dp[count2] * 2, Math.min(dp[count3] * 3, dp[count5] * 5));
            dp[i] = nextOne;
            if (nextOne == dp[count2] * 2) count2 += 1;
            if (nextOne == dp[count3] * 3) count3 += 1;
            if (nextOne == dp[count5] * 5) count5 += 1;

        }
        return dp[n - 1];
    }
}
```



## 313. 超级丑数(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/super-ugly-number/)

```
编写一段程序来查找第 n 个超级丑数。

超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。
输入: n = 12, primes = [2,7,13,19]
输出: 32 
解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。

```

### 分析

思路其实一致，只不过丑数之前只有三个，现在是数组存储的多个。直接一个循环之前的过程即可。

### 实现

```java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        int[] indexs = new int[primes.length];

        int[] dp = new int[n];
        dp[0] = 1;

        for (int i = 1; i < n; i++) {

            int minValue = getMinValue(indexs, primes, dp);
            dp[i] = minValue;
            refreshIndexs(indexs, primes, dp, minValue);
        }
        return dp[n - 1];
    }

    // 找最小值，即找下一个值
    private int getMinValue(int[] indexs, int[] primes, int[] dp) {

        int min = Integer.MAX_VALUE;
        for (int i = 0; i < primes.length; i++) {
            int temp = primes[i] * dp[indexs[i]];
            min = Math.min(min, temp);
        }
        return min;
    }
	
    // 根据下一个值更新丑数的索引，看谁等于minValue
    private void refreshIndexs(int[] indexs, int[] primes, int[] dp, int minValue) {
        for (int i = 0; i < primes.length; i++) {
            int temp = primes[i] * dp[indexs[i]];
            if (temp == minValue) {
                indexs[i] += 1;
            }
        }
    }


}
```





## 799. 香槟塔

### 描述

[题目链接](https://leetcode-cn.com/problems/champagne-tower/)

```
我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。
从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）

现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。


示例 1:
输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.0
解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。

示例 2:
输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.5
解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。

```

### 分析

某个香槟杯子的上一层的两个杯子，如果满了，都会有一半的香槟流向这个杯子。

假设`dp[i][j]` 代表的是流经这个杯子的总的香槟，那么会有递推：`dp[i][j] = (dp[i - 1][j - 1] - 1) / 2  + (dp[i - 1][j] - 1) / 2`

### 实现

```java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        double[][] dp = new double[101][101];  // dp[i][j]表示流经该杯子的总的香槟数量。如果大于1说明最终会满，反之
        dp[1][1] = poured;  // 所有的水都会经过 第一个杯子

        for (int level = 2; level <= 100; level++) {
            for (int num = 1; num <= level; num++) {
                if (dp[level - 1][num - 1] > 1) {  // 左上的杯子超过1，会有溢出的一半香槟流到这个杯子
                    dp[level][num] += (dp[level - 1][num - 1] - 1) / 2;
                }

                if (dp[level - 1][num] > 1) { // 右上的杯子超过1，也会有一半的香槟流到这个杯子
                    dp[level][num] += (dp[level - 1][num] - 1) / 2;
                }
            }
        }

        return dp[query_row + 1][query_glass + 1] > 1 ? 1.0 : dp[query_row + 1][query_glass + 1];
    }
}
```



## 801. 使得序列递增的最小交换次数

### 题目描述

[链接](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/)

```
我们有两个长度相等且不为空的整型数组 A 和 B 。
我们可以交换 A[i] 和 B[i] 的元素。注意这两个元素在各自的序列中应该处于相同的位置。
在交换过一些元素之后，数组 A 和 B 都应该是严格递增的（数组严格递增的条件仅为A[0] < A[1] < A[2] < ... < A[A.length - 1]）。
给定数组 A 和 B ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。

示例:
输入: A = [1,3,5,4], B = [1,2,3,7]
输出: 1
解释: 
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。

```

### 分析

构造两个数组，yes[i] 表示当前索引交换之后，序列有序的最小次数；no[i]表示当前索引不交换，序列有序的最小次数。

* 当 `A[i] > A[i - 1]  && B[i] > B[i - 1]`  并且 `A[i-1] < B[i] && B[i-1] < A[i]`的时候， 那么此时，交换或者不交换都是有序的。那么有 `yes[i] = Math.min(yes[i - 1], no[i - 1])  + 1`,  `no[i] = Math.min(yes[i - 1], no[i - 1])`
* 当各自有序，但是交叉不是有序，即  `A[i] > A[i - 1]  && B[i] > B[i - 1]`  但是 `A[i-1] < B[i] || B[i-1] < A[i]`， 那么此时， 如果上一次交换，那么这一次必须交换，如果上一次不交换，那么这一次也不能交换。所以有 `yes[i] = yes[i - 1] + 1`,  `no[i] = no[i - 1]`
* 当各自都不满足有序的时候，那么上一次交换，这一次不能交换，如果上一次没有交换，这一次必须交换。于是有 `yes[i] = no[i - 1] + 1`  , `no[i] = yes[i - 1]`

### 实现

```java
class Solution {
    public int minSwap(int[] A, int[] B) {
        int length = A.length;
        if (length == 0) return 0;
        int[] yes = new int[length];  // 当前索引交换后，使得当前有序的最小交换次数
        int[] no = new int[length];  // 当前索引不交换，使得当前有序的最小交换次数
        no[0] = 0;  // 第一个值，既可以交换，也可以不交换
        yes[0] = 1;

        for (int i = 1; i < length; i++) {
            if (A[i] > A[i - 1] && B[i] > B[i - 1] &&  A[i] > B[i - 1] && B[i] > A[i - 1]) {
                // 既满足  各自有序，也满足交叉有序。那么这一次交换与否，不依赖于上一次的情况
                no[i] = Math.min(no[i - 1], yes[i - 1]);
                yes[i] = Math.min(yes[i - 1],no[i - 1]) + 1;
            } 
            else if (A[i] > A[i - 1] && B[i] > B[i - 1] ) {
                // 满足各自有序， 不满足交叉有序
                // 之前没有换，现在不能换，之前换了，现在必须换
                no[i] = no[i - 1];
                yes[i] = yes[i - 1] + 1;
            }
            else {
                // 不满足各自有序
                // 之前没有换，这次必须换，之前换了，这次不能换
                no[i] = yes[i - 1];
                yes[i] = no[i - 1] + 1;
            }
        }

        return Math.min(yes[length - 1], no[length - 1]);
    }
}
```



## 813. 最大平均值和的分组

### 描述

[链接](https://leetcode-cn.com/problems/largest-sum-of-averages/)

```
我们将给定的数组 A 分成 K 个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。
注意我们必须使用 A 数组中的每一个数进行分组，并且分数不一定需要是整数。

示例:
输入: 
A = [9,1,2,3,9]
K = 3
输出: 20
解释: 
A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.
我们也可以把 A 分成[9, 1], [2], [3, 9].
这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.
```

### 分析

假设 `dp[i][k]` 为 数组的前 `i`个如果分为 k个的最大的平均值和。比如要求 前5个，分为3个组的最大平均值和。那么去求

* 前 1 个数 分为2个组，此种情况不可能
* 前2个数分为2个组，然后求 3到5的平均值 ，加起来
* 前3个数分为2个组，然后求4到5的平均值，加起来
* 前4个数分为2个组，然后求5的平均值，加起来

求得上面的值，取最大值，作为本次`dp`的最终值

每次求平均值的地方可以优化，利用已经求的的平均值进行求取。但是保证逻辑的清晰，还是用最基本的方式求

### 实现

```java
class Solution {
    public double largestSumOfAverages(int[] A, int K) {
        int length = A.length;
        double[][] dp = new double[length + 1][K + 1];

        // 第一层得事先求，因为后面得层都依赖于第一层
        for (int i = 1; i <= length; i++) {
            dp[i][1] = getAverage(A, 0, i - 1);
        }

        for (int count = 2; count <= K; count++) {
            for (int i = count; i <= length; i++) {  // i 从 count 开始，因为如果i 小于count，是不可能的，没有意义
                for (int j = count - 1; j < i; j++) {// 同理，j如果小于count-1，也是不可能的
                    dp[i][count] = Math.max(dp[i][count], dp[j][count - 1] + getAverage(A, j, i - 1));
                }
            }
        }

        return dp[length][K];
    }

    /**
        求某一段的平均值(可以优化，根据之前一个 dp 的值去求，复杂度为 o(1), 但是保证逻辑的清晰性，还是用这种方式求)
    **/
    public double getAverage(int[] nums, int i, int j) {
        double ans = 0;
        for (int index = i; index <= j; index++) {
            ans += nums[index];
        }
        return ans / (j - i + 1);
    }
}
```





## 221. 最大正方形(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/maximal-square/)

```
在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

输入：matrix = [
["1","0","1","0","0"],
["1","0","1","1","1"],
["1","1","1","1","1"],
["1","0","0","1","0"]
]
输出：4
```

### 分析

寻找最大的边长。如果当前点是 `(i, j)`， 那么有 

`dp[i,j] = min(dp[i - 1, j], dp[i, j - 1], dp[i-1,j-1]) + 1     if  matrix[i,j]=1`

### 实现

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int maxLength = 0;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int[][] dp = new int[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j== 0) {
                        dp[i][j] = 1;
                    }else {
                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                }
                maxLength = Math.max(maxLength, dp[i][j]);
            }
        }
        return maxLength * maxLength;
    }
}
```





## 300. 最长递增子序列(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

### 分析

`dp[i]`表示以 `i`结尾的最长的递增子序列，那么有

`dp[i] = max(dp[j]) + 1 `, 其中 `j 小于 i 并且 nums[i] 大于 nums[j]`

### 实现

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) return 0;
        int[] dp = new int[nums.length + 1];
        Arrays.fill(dp, 1);
        int ans = 1;

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            ans = Math.max(ans, dp[i]);
        }

        return ans;
    }
}
```





## 322. 零钱兑换(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/coin-change/)

```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

### 分析

保存之前的状态即可。`dp[i]`表示 `i`需要的最小硬币个数。因此。

`dp[i] = min(dp[j]) + 1`  其中 `i - j `是`coins`数组中的数字。

### 实现

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        for (int i = 1; i <= amount; i++) {

            for (int each : coins) {
                if (i - each < 0 || dp[i - each] == Integer.MAX_VALUE) {
                    // i - each 不能被 coins中硬币凑出来
                    continue;
                }

                dp[i] = Math.min(dp[i], dp[i - each] + 1);
            }
        }

        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
   
}
```





## 376.摆动序列(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/wiggle-subsequence/)

```
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```

### 分析

思路1， 动态规划。由于序列存在上升或者下降，因此需要两个数组来保存。假设 `up[i]`表示的是**以`i`结尾**的并且最后是上升的最长序列。同理， `donw[i]`表示以`i`结尾的最后是下降的最长序列长度。两层循环。于是有：

* 如果 `nums[i] > nums[j], 这一个是上升，需要j是下降， 于是有  up[i] = down[j] + 1`
* 如果 `nums[i] < nums[j], 有 donw[i] = up[j] + 1`
* 取最大的即可。



思路2， 动态规划。但是表达的含义不同。`up[i]`表示的是最长的序列最后是上升的最大序列长度。与第一种动态规划区别在于这里没有限定是 以 `i`结尾。也能计算，只用一层循环。就是不好理解，官方题解有说明。

思路3， 贪心。交替选择上升和下降。也有点晦涩难懂

### 实现

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }

        int[] up = new int[nums.length];
        int[] down = new int[nums.length];

        Arrays.fill(up, 1);
        Arrays.fill(down, 1);
        int ans = 1;

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    up[i] = Math.max(up[i], down[j] + 1);
                    ans = Math.max(up[i], ans);
                } else if (nums[i] < nums[j]) {
                    down[i] = Math.max(down[i], up[j] + 1);
                    ans = Math.max(down[i], ans);
                }
            }
        }

        return ans;
    }
}

/**
	贪心
*/
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return n;
        }
        int prevdiff = nums[1] - nums[0];
        int ret = prevdiff != 0 ? 2 : 1;
        for (int i = 2; i < n; i++) {
            int diff = nums[i] - nums[i - 1];
            if ((diff > 0 && prevdiff <= 0) || (diff < 0 && prevdiff >= 0)) {
                ret++;
                prevdiff = diff;
            }
        }
        return ret;
    }
}

```





## 410. 分割数组的最大值(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/split-array-largest-sum/)

```
给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。

输入:
nums = [7,2,5,10,8]
m = 2

输出:
18

解释:
一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。

```

### 分析

假设 `dp[i][j]`表示的是 前 `i`个数，分割成 `j`个的最大值的最小值。那么有：

`dp[i][j] = min( max(dp[k][j - 1], sum(k, j)) )`

意思是，前 k 个数字分成 `j-1`个，然后`k`到 `i`之间的和的较大值。这里面再取一个最小值即可。

方便求 区间内的和，采用前缀和进行保存，方便求值。

数组的初始化，很关键。因为要求最小值，先将所有的初始化  `max_value`。然后由于 `dp[0][0]`等于0.因为没有元素，不切割的时候。和就是0。

### 实现

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        int len = nums.length;
        
        // 前缀和
        int[] preSum = new int[len + 1];
        for (int i = 1; i <= len; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        } 

        int[][] dp = new int[len + 1][m + 1];
        for (int[] each : dp) {
            Arrays.fill(each, Integer.MAX_VALUE);
        }
        dp[0][0] = 0;

        for (int i = 1; i <= len; i++) {
            for (int j = 1; j <= m; j++) {
                if (j > i) {
                    // 总共元素才 i 个 ,现在要分成 j 个 数组，j > i， 是不行的
                    break;
                }

                for (int k = 1; k <= i; k++) {
                    // 划分位 dp[k - 1]][j - 1] 和 nums[k, i]
                    // 同理， k 必须大于等于 j - 1
                    if (j - 1 > k - 1) {
                        continue;  // 这里是 continue, 而不是break， 因为 这里是 k 在增加
                    }
                    int temp = preSum[i] - preSum[k - 1]; // 后面这一段的和
                    int max = Math.max(temp, dp[k - 1][j - 1]); // 如果这样分割的话和的最大值
                    dp[i][j] = Math.min(dp[i][j], max); // 取最小的

                }
            }
        }
        // for (int[] each : dp) {
        //     System.out.println(Arrays.toString(each));
        // }
        return dp[len][m];
    }
}
```





## 516. 最长回文子序列(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

```
给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

"bbbab"
4
```

### 分析

子序列并不需要连续。设 `dp[i][j]`表示 `i`到`j` 之间的最大回文序列的长度。于是有：

* 如果 `s[i] == s[j]`， 那么`dp[i][j] = dp[i + 1][j - 1] + 2`
* 如果二者不相等，那么有 `dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])`
* 一些边界条件，`i == j`的时候一定是回文，`dp[i][i]= 1`;  
* 由于 `dp[i][j]` 和 `i + 1`以及 `j - 1`相关，依赖于这两个，因此循环顺序是 `i`从大到小， `j`从小到达。根据定义， `j`比如大于等于`i`才有意义。

### 实现

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        int len = s.length();
        int[][] dp = new int[len][len];

        // dp[i][j] = dp[i + 1][j - 1] + 2 
        // dp[i][j] = 

        for (int i = len - 1; i >= 0; i--) {
            dp[i][i] = 1;

            for (int j = i + 1; j < len; j++) {

                if (s.charAt(i) == s.charAt(j)) {
                    if (j == i + 1) {
                        dp[i][j] = 2;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1] + 2;
                    }
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }
        return dp[0][len - 1];

    }
    
}
```





## 518. 零钱兑换2(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/coin-change-2/)

```
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

```

### 分析

设 `dp[i]`表示能够凑成 价值为 `i`的方案数。于是有

`dp[i] = dp[i - coin]`, 其中 `coin`代表每一种硬币的价值。

### 实现

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1; // dp[0] = 1 的目的是， 比如coin=4, 那么价值为4，有一种方案，可以之间通过dp[0]得到
        for(int each : coins) {
            for(int i = 1; i <= amount; i++) {
                if(i >= each) {
                    dp[i] += dp[i - each];
                }
            }
        }
        // System.out.println(Arrays.toString(dp));
        return dp[amount];
    }
}
```





## 542. 01矩阵(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/01-matrix/)

```
给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。
给定矩阵中至少有一个元素是 0。

输入：
[[0,0,0],
 [0,1,0],
 [1,1,1]]

输出：
[[0,0,0],
 [0,1,0],
 [1,2,1]]
```

### 分析

最开始使用深度优先搜索，结果错了。后发现不能使用深度优先搜索的原因是，比如要求 `(i, j)`的最小值，向右求 `(i, j+ 1)`的值，但其实 `(i, j+ 1)`也依赖于`(i, j)`， 即互相依赖，不能用深度优先。

可以使用广度优先，类似于在树里面找最短的高度。

还可以使用动态规划。两次循环，`dp[i][j]`的时候，已经知道了她上面和左面的值，然后取较小值即可。但是并不知道下面和右面的，然后再一次循环，从右下角开始的循环即可。

即，先找再其上面和左面的最小值，然后再找右边和下面的，二者结合，就是整体的最小值.

第一次见这种`dp`

### 实现

```java
class Solution {
    public int[][] updateMatrix(int[][] matrix) {
        if (matrix == null && matrix.length == 0) {
            return new int[0][0];
        }

        int m = matrix.length - 1;
        int n = matrix[0].length - 1;        
        int[][] ans = new int[m + 1][n + 1];
        for (int[] each : ans) {
            Arrays.fill(each, Integer.MAX_VALUE);
        }

        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (matrix[i][j] == 0) {
                    ans[i][j] = 0;
                    continue;
                }

                if (i > 0 && ans[i - 1][j] != Integer.MAX_VALUE) {
                    ans[i][j] = Math.min(ans[i][j], ans[i - 1][j] + 1);
                }

                if (j > 0 && ans[i][j - 1] != Integer.MAX_VALUE) {
                    ans[i][j] = Math.min(ans[i][j], ans[i][j - 1] + 1);
                }
            }
        }

        for (int i = m; i >= 0; i--) {
            for (int j = n; j >= 0; j--) {
                if (matrix[i][j] == 0) {
                    ans[i][j] = 0;
                    continue;
                }

                if (i < m && ans[i + 1][j] != Integer.MAX_VALUE) {
                    ans[i][j] = Math.min(ans[i][j], ans[i + 1][j] + 1);
                }

                if (j < n && ans[i][j + 1] != Integer.MAX_VALUE) {
                    ans[i][j] = Math.min(ans[i][j], ans[i][j + 1] + 1);
                }
            }
        }

        return ans;


    }

}
```





## 576. 足球出界的路径数(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/out-of-boundary-paths/)

```
给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109 + 7 的值。

输入: m = 2, n = 2, N = 2, i = 0, j = 0
输出: 6
```

### 分析

由于路径数量是很大的，并且还可以迂回，比如往回走，因此，不能使用深度优先。

使用动态规划，假设已经直到网格内每一个点，最多移动`k - 1`次的出界次数,用`dp[i][j][k - 1]`表示，那么最多移动`k`次的话

`dp[i][j][k] = dp[i - 1][j][k - 1] + dp[i + 1][j][k - 1] + dp[i][j + 1][k - 1] + dp[i][j - 1][k - 1]`

### 实现

代码中没有取余，大量取余影响可读性

```JAVA
class Solution {
    public int findPaths(int m, int n, int N, int rowIndex, int colIndex) {

        int[][][] dp = new int[m + 2][n + 2][N + 1];  // 把网格扩充一圈，方便计算

        // 初始化四个边界，已经是界外了，那么移动0步出界的方式就是1
        for (int i = 0; i <= m + 1; i++) {
            dp[i][0][0] = 1;
            dp[i][n + 1][0] = 1;
        }
        for (int j = 0; j <= n + 1; j++) {
            dp[0][j][0] = 1;
            dp[m + 1][j][0] = 1;
        }


        for (int k = 1; k <= N; k++) { // 每一个每一个 k 得找，即先循环k

            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    dp[i][j][k] = dp[i - 1][j][k - 1] + dp[i + 1][j][k - 1] + dp[i][j - 1][k - 1] + dp[i][j + 1][k - 1];

                }
            }
        }

        int ans = 0;
        for (int k = 1; k <= N; k++) {
            ans += dp[rowIndex + 1][colIndex + 1][k];
        }
        return ans;

    }
}
```



## 688. 马在棋盘上的概率(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)

```
已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 
现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 
如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。
现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。
求移动结束后，“马” 仍留在棋盘上的概率。
输入: 3, 2, 0, 0
输出: 0.0625
解释: 
输入的数据依次为 N, K, r, c
第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。
所以 “马” 在结束后仍在棋盘上的概率为 0.0625。

```

### 分析

和上一道题很类似。 使用 三维`dp`来保存变量。

### 实现

```java
class Solution {
    public double knightProbability(int N, int K, int r, int c) {
        int[][] directions = {{2, -1}, {2, 1}, {-2, -1}, {-2, 1}, {-1, -2}, {1, -2}, {-1, 2}, {1, 2}};

        // 移动 K 次 仍然在 棋盘上的概率
        double[][][] dp = new double[N + 2][N + 2][K + 1];

        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                dp[i][j][0] = 1.0; // 移动 0 次 本身就在棋盘上的点 还在棋盘上的概率是 1
            }
        }

        for (int k = 1; k <= K; k++) {
            for (int i = 1; i <= N; i++) {
                for (int j = 1; j <= N; j++) {

                    // 8 种走法
                    for (int[] each : directions) {
                        if (i + each[0] <= 0 || i + each[0] > N) {
                            // 越界
                            continue;
                        } 
                        if (j + each[1] <= 0 || j + each[1] > N) {
                            // 越界
                            continue;
                        }

                        dp[i][j][k] += dp[i + each[0]][j + each[1]][k - 1] / 8;
                    }
                }
            }
        }

        // 每一个点移动 K 次 还在棋盘上的概率找到了
        return dp[r + 1][c + 1][K];
    }
}
```



## 647. 回文字串的个数(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/palindromic-substrings/)

```
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

### 分析

和求最大回文字串没什么区别，可以采用中心扩散，也可以采用二维动态规划。

### 实现

```java
class Solution {
    public int countSubstrings(String s) {
        /**
          s(i) == s(j) => dp[i][j] = dp[i + 1][j - 1]
          否则，dp[i][j] = false
        */
        if (s == null || s.length() == 0) {
            return 0;
        }
        int len = s.length();
        boolean[][] dp = new boolean[len][len];

        for (int i = len - 1; i >= 0; i--) {
            dp[i][i] = true;
            for (int j = i + 1; j < len; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j == i + 1) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                } else {
                    dp[i][j] = false;
                }
            }
        } 

        int ans = 0;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len; j++) {
                if (dp[i][j] == true) {
                    ans += 1;
                }
            }
        }
        return ans;
    }
}
```





## 673. 最长递增子序列的个数(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

```
给定一个未排序的整数数组，找到最长递增子序列的个数。
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

### 分析

要求最长递增子序列的长度，需要使用动态规划，这道题还要求，在最长情况下的个数，因此还需要一个数组保存数量。

`dp[i]`表示， 前 `i`个的最长子序列的长度，并且序列必须以 `nums[i]`结束。

`count[i]`表示对应的子序列最长的时候的个数。

因此有  

* 如果 `nums[i] > nums[j]`, 有 `dp[i] = max(dp[i], dp[j] + 1)`。 需要实时更新 `count[i]`， 如果 `dp[j] + 1 > dp[i]`， 那么`count[i] = count[j]`； 如果 `dp[i] == dp[j] + 1`， 那么 `count[i] = count[i] + count[j]`

### 实现

```java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int[] dp = new int[nums.length];
        int[] count = new int[nums.length];

        Arrays.fill(dp, 1); // 序列只包含自己，因此长度至少都是1
        Arrays.fill(count, 1);

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {

                if (nums[i] > nums[j]) {
                    int temp = dp[j] + 1; // 如果和 j 合并的序列长度
                    if (temp == dp[i]) {
                        // 如果等于暂时的最长长度，将方法加进去
                        count[i] += count[j];
                    } else if (temp > dp[i]) {
                        // 更新长度
                        dp[i] = temp;
                        count[i] = count[j];
                    }
                }
                
            }
        }
		
        // 全局找最长的长度
        int maxLength = Integer.MIN_VALUE;
        for (int i = 0; i < dp.length; i++) {
            maxLength = Math.max(maxLength, dp[i]);
        }
        // 找到最长长度之后，找对应的个数
        int ans = 0;
        for (int i = 0; i < count.length; i++) {
            if (dp[i] == maxLength) {
                ans += count[i];
            }
        }

        return ans;

    }
}
```





## 712. 两个字符串的最小ASCII删除和(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

```
给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。
输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。

```

### 分析

和编辑距离的思路一致。假设 `dp[i][j]`代表的是 `s1`的前`i`个字符 和 `s2`的前 `j`个字符的最小和。那么有：

* 如果 `s1(i) == s2[j]`， `dp[i][j] = dp[i - 1][j -1]`
* 如果不相等，选择删除哪一个 `dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])`

### 实现

```java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        if (s1 == null || s2 == null) {
            return -1;
        }
        int len1 = s1.length();
        int len2 = s2.length();

        int[][] dp = new int[len1 + 1][len2 + 2];

        // 初始化0
        for (int i = 1; i <= len1; i++) {
            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);
        }
        for (int j = 1; j <= len2; j++) {
            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);
        }

        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));
                }
            }
        }
        return dp[len1][len2];
    }

}
```





## 718. 最长重复子数组(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

```
给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

### 分析

和寻找两个字符串的最长公共子序列有点类似。

假设 `dp[i][j]`表示的是数组`A`以 `i`结尾， 数组`B`以`j`结尾的最长长度，那么有

* 如果 `A[i] == B[j]`， 有 `dp[i][j] = dp[i - 1][j - 1] + 1`
* 否则 ， `dp[i][j] = 0`
* 最后找一个全局的最大值

### 实现

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int m = A.length;
        int n = B.length;
        int[][] dp = new int[m + 1][n + 1];
        int ans = 0;

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    ans = Math.max(ans, dp[i][j]);
                }
            }
        }

       return ans;
    }
}
```

