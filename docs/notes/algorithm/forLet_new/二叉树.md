# 二叉树

## 94. 二叉树中序遍历

### 实现

```java
// 较为简单，直接实现
// 递归方式
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dsf(root, ans);
        return ans;
    }
    public void dsf(TreeNode head, List<Integer> ans) {
        if (head == null) return;
        dsf(head.left, ans);
        ans.add(head.val);
        dsf(head.right, ans);
    }

}
```

## 95. 不同的二叉搜索树2

### 描述

[链接](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

```
给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

### 分析

简单递归

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) {
      return new LinkedList<TreeNode>();
    }
    return generate_trees(1, n);
  }
    
    public LinkedList<TreeNode> generate_trees(int start, int end) {
	    LinkedList<TreeNode> ans = new LinkedList<TreeNode>();
	    if (start > end) {
	      ans.add(null);
	      return ans;
	    }

	    for (int i = start; i <= end; i++) {
	      LinkedList<TreeNode> left_trees = generate_trees(start, i - 1);
	      LinkedList<TreeNode> right_trees = generate_trees(i + 1, end);
	      for (TreeNode left : left_trees) {
	        for (TreeNode right : right_trees) {
	          TreeNode current_tree = new TreeNode(i);
	          current_tree.left = left;
	          current_tree.right = right;
	          ans.add(current_tree);
	        }
	      }
	    }
	    return ans;
	}

}
```



## 98. 验证二叉搜索树

### 描述

[链接](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```
定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

```

### 实现

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }

    public boolean helper(TreeNode node, Integer lower, Integer upper) {
        if (node == null) {
            return true;
        }

        int val = node.val;
        if (lower != null && val <= lower) {
            return false;
        }
        if (upper != null && val >= upper) {
            return false;
        }

        if (!helper(node.right, val, upper)) {
            return false;
        }
        if (!helper(node.left, lower, val)) {
            return false;
        }
        return true;
    }
}

```



## 反转链表*

### 递归实现(难点)

```java
ListNode reverse(ListNode head) {
    if (head.next == null) return head;
    ListNode last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}



/**
	* 反转前N个节点
**/
ListNode successor = null; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
ListNode reverseN(ListNode head, int n) {
    if (n == 1) { 
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    ListNode last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head.next = successor;
    return last;
}



/**
 * 反转区间链表  
 * 如果 M= 1就是上面的情况。如果把 head.next 的索引视为 1 ， 那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的；同理一直往后
**/
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
}


```



## 101. 对称二叉树

### 描述

[链接](https://leetcode-cn.com/problems/symmetric-tree/)

```
给定一个二叉树，检查它是否是镜像对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

### 分析

简单递归

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return isTrue(root, root);
    }
    private boolean isTrue(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return true;
        if (root1 == null || root2 == null) return false;
        if (root1.val != root2.val) return false;

        if (isTrue(root1.left, root2.right) == false) return false;
        if (isTrue(root1.right, root2.left) == false) return false;
        return true;
    }
}
```



## 102. 二叉树层序遍历

### 实现

```java
// 使用 队列
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();  // 双向队列用于队列
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        deque.addLast(root);

        while (deque.size() > 0) {
            int number = deque.size();
            List<Integer> subList = new ArrayList<>();
            for (int i = 0; i < number; i++) {
                TreeNode firstOne = deque.removeFirst();
                subList.add(firstOne.val);
                if (firstOne.left != null) {
                    deque.addLast(firstOne.left);
                }
                if (firstOne.right != null) {
                    deque.addLast(firstOne.right);
                }
            }
            ans.add(subList);
        }
        return ans;
    }

}
```

## 103. 二叉树锯齿形层序遍历

### 描述

[链接](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

```
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）
```

### 分析

如果只是单纯的层序遍历，使用队列即可，如果是交替层序遍历，采用双向队列即可。如果是奇数层，当做队列使用，如果是偶数层，当做栈使用。奇数层，先push左节点，再右节点。反之

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;

        Deque<TreeNode> deque = new LinkedList<>();
        int level = 0;  // level 代表层，奇数层  从左到右，使用队列， 偶数层从右到左，使用栈，使用双向队列，既包含栈，又包含队列
        deque.addLast(root);

        while (!deque.isEmpty()) {
            int number = deque.size();
            level += 1;
            List<Integer> subList = new ArrayList<>();

            if (level % 2 == 1) {
                //  从左到右
                for (int i = 0; i < number; i++) {
                    TreeNode firstOne =  deque.removeFirst();
                    subList.add(firstOne.val);
                    if (firstOne.left != null) {
                        deque.addLast(firstOne.left);
                    }
                    if (firstOne.right != null) {
                        deque.addLast(firstOne.right);
                    }
                }
            } else {
                for (int i = 0; i < number; i++) {
                    TreeNode firstOne = deque.removeLast();
                    subList.add(firstOne.val);
                    if (firstOne.right != null) {
                        deque.addFirst(firstOne.right);
                    }
                    if (firstOne.left != null) {
                        deque.addFirst(firstOne.left);
                    }
                }
            }
            ans.add(subList);
        }
        return ans;
    }
}
```

## 104. 二叉树的最大深度

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```



## 105. 根据前序遍历和中序遍历构造二叉树

### 描述

[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
   3
   / \
  9  20
    /  \
   15   7
```

### 分析

前序遍历中，第一个值是root节点。而在中序遍历中，root节点值之前的数组是左子树的内容，之后数组的内容是右边子树的内容。因此递归的时候，每次找到左子树的内容和右子树的内容，继续构造二叉树

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildOne(preorder, inorder, 0, preorder.length - 1, 0, inorder.length);
    }

    private TreeNode buildOne(int[] preorder, int[] inorder, int preLeft, int preRight, int inoLeft, int inoRight) {
        if (preLeft > preRight) return null;
        TreeNode root = new TreeNode(preorder[preLeft]);

      	// 找到当前二叉树中的左子树有多少个节点
        int count = 0;
        while (preorder[preLeft] != inorder[inoLeft + count]) {
            count += 1;
        }
        // System.out.println(count);

        // inoLeft + count 代表 中序遍历中root节点的分割点
        root.left = buildOne(preorder, inorder, preLeft + 1, preLeft  + count, inoLeft, inoLeft + count - 1);

        root.right = buildOne(preorder, inorder, preLeft + count + 1, preRight, inoLeft + count + 1, inoRight);

        return root;

    }
}
```



## 106. 中序遍历和后序遍历构造二叉树

### 描述

[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```
根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]

  3
   / \
  9  20
    /  \
   15   7
```

### 分析

后上题思路差不多。后续遍历的最后一个值一定是root， 根据这个值，找到左子树的个数，然后分割两个数组，进行递归，分别构建root的左子树和右子树

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildOne(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);
    }
    private TreeNode buildOne(int[] inorder, int[] postorder, int left1, int right1, int left2, int right2) {
        if (left2 > right2) return null;

        TreeNode root = new TreeNode(postorder[right2]);

        int count = 0;
        while (inorder[left1 + count] != postorder[right2]) {
            count += 1;
        }

        root.left = buildOne(inorder, postorder, left1, left1 + count - 1, left2, left2 + count - 1);
        root.right = buildOne(inorder, postorder, left1 + count + 1, right1, left2 + count, right2 - 1);

        return root;
    }
}
```

## 107. 二叉树的层序遍历2

### 描述

[链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],
  	3
   / \
  9  20
    /  \
   15   7
[
  [15,7],
  [9,20],
  [3]
]
```

### 分析

和层序遍历没有什么区别。可以在插入List的时候指定位置，也可以将最后结果直接进行反转

### 实现

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> levelOrder = new LinkedList<List<Integer>>();
        if (root == null) {
            return levelOrder;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                TreeNode left = node.left, right = node.right;
                if (left != null) {
                    queue.offer(left);
                }
                if (right != null) {
                    queue.offer(right);
                }
            }
            levelOrder.add(0, level);
        }
        return levelOrder;
    }
}

```



## 108. 将有序数组转化为二叉搜索树

### 描述

[链接](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

```

### 分析

找到中心点，作为root，然后分别构建左子树和右子树

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return buildOne(nums, 0, nums.length - 1);
    }
    public TreeNode buildOne(int[] nums, int left, int right) {
        if (left > right) return null;
        int middle = (left + right) / 2;
        TreeNode root = new TreeNode(nums[middle]);

        root.left = buildOne(nums, left, middle - 1);
        root.right = buildOne(nums, middle + 1, right);
        return root;
    }
}
```



## 109. 有序链表转化为二叉搜索树

### 描述

和上一道题几乎一样，区别在于输入的是链表

### 分析

数组可以获得索引，因此很容易找到中心点。所以稍微复杂一点的只是寻找中心节点。

### 实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return buildTree(head, null);
    }

  // right为尾节点的下一个节点
    private TreeNode buildTree(ListNode left, ListNode right) {
        if (left == right) return null;

        ListNode mid = getMiddle(left, right);
        TreeNode root = new TreeNode(mid.val);
        root.left = buildTree(left, mid);
        root.right = buildTree(mid.next, right);
        return root;

    }

    private ListNode getMiddle(ListNode left, ListNode right) {
        ListNode fast = left;
        ListNode slow = left;
        while (fast != right && fast.next != right) {
            fast = fast.next;
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```



## 110. 判断二叉树是否是平衡二叉树

### 描述

[链接](https://leetcode-cn.com/problems/balanced-binary-tree/)

```
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
```



### 分析

根据递归求深度。难点在于如果子树已经不是平衡二叉树的时候，就不再递归了。如果子树已经不是平衡二叉树了，那么返回高度的长度为-1来标识，一层一层往上把 -1 抛出去，类似于一层一层向上抛出异常的操作

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
      // 如果数的告诉不是 -1 ，说明没有问题。如果是-1，说明在某个节点已经不是子树，一直往上抛
        return getLength(root) != -1;
    }

    private int getLength(TreeNode root) {
        if (root == null) return 0;
      
       // 左子树 已经不是平衡二叉树  ，直接往上抛
        int left = getLength(root.left);
        if (left == -1) return -1;

      	// 右子树 已经不是平衡二叉树，直接往上抛
        int right = getLength(root.right);
        if (right == -1) return -1;
				
      	// 当前树不是平衡二叉树，也往上抛出去
        if (Math.abs(left - right) > 1) return -1;
				
      	// 返回树的高度
        return Math.max(left, right) + 1;
    }
}
```

## 110.二叉树的最小深度

### 描述

[链接](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

    3
   / \
  9  20
    /  \
   15   7
   
最小深度为2
```

### 分析

如果一棵树的左子树为空，则返回右子树的最小深度加1.反之。

如果左子树和右子树都不为null， 返回左右的最小深度的较小值 加1

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null) return minDepth(root.right) + 1;
        if (root.right == null) return minDepth(root.left) + 1;
        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    }
}
```



## 102. 路径总和

### 描述

[链接](https://leetcode-cn.com/problems/path-sum/)

```
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
sum =22 , 返回true, 因为存在路径之和为22
```



### 分析

简单递归

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        if (root.val == sum && root.left == null && root.right == null) return true;

        if (hasPathSum(root.left, sum - root.val)) return true;

        if (hasPathSum(root.right, sum - root.val)) return true;

        return false;
    }
}
```



## 113. 路径总和2

### 描述

[链接](https://leetcode-cn.com/problems/path-sum-ii/)

```
题目与上一题一样，但是返回所有的可能情况
返回：
[
   [5,4,11,2],
   [5,8,4,5]
]
```

### 分析

找寻所有情况，明显使用回溯。具体看代码。

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        Deque<Integer> path = new LinkedList<>();
        dfs(root, sum, ans, path);
        return ans;
    }
    private void dfs(TreeNode root, int sum, List<List<Integer>> ans, Deque<Integer> path) {
        if (root == null) return;
      
      //  满足条件(总和等于sum， 是根节点， 加入到结果集中并返回)
        if (sum == root.val && root.left == null && root.right == null) {
            path.addLast(root.val);
            ans.add(new ArrayList<>(path));
            path.removeLast();
            return;
        }
        path.addLast(root.val);
      	// 往左边走
        dfs(root.left, sum - root.val, ans, path);
      	// 往右边走
        dfs(root.right, sum - root.val, ans, path);
        path.removeLast();
    }


}
```



## 114. 二叉树原地展开为链表

### 描述

[链接](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```
   1
   / \
  2   5          ->>>>     
 / \   \
3   4   6

变成：
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

### 分析

整个流程其实类似一个前序遍历。一个root节点，左子树的最右边最右边的节点指向右边的第一个节点。因此，可以先找到左子树的最右边的根节点，然后指向右边。然后继续递归下去。

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {

        while (root != null) {
            TreeNode next = root.left;
            if (next == null) {
                root = root.right;
                continue;
            }
            TreeNode temp = next;
            // 找到左子树最右最右的节点
            while (temp.right != null) {
                temp = temp.right;
            }

            // 左子树的最右节点指向右子树
            temp.right = root.right;
            root.left = null;
            root.right = next;
            
            root = root.right;
        }
        
    }

}
```

## 116. 填充每个节点的下一个节点的右侧节点指针

### 描述

[链接](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```java
// 题目描述过于复杂，点开链接直接看吧
```

### 分析

一种很简单的方式就是层序遍历，但是需要额外的队列的空间。如果不适用额外的空间，可以借助next指针。

* 如果是一个节点的left和right，直接把left.next指向right。
* 如果是不同节点，需要注意的是，上一层已经有next了，因此，head.next=head2.而需要做的只是  head1.right .next 指向head.left。 即变成  head1.right.next指向  head1.next.left。

### 实现

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if (root == null) return root;

        Node leftMost = root;
        while (leftMost.left != null) {

            Node head = leftMost;

            while (head != null) {
                head.left.next = head.right;
                if (head.next != null) {
                    head.right.next = head.next.left;
                }
                head = head.next;
            }
            leftMost = leftMost.left;

        }
        return root;

    }
}
```



