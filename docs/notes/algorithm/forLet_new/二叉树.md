# 二叉树



## 94. 二叉树中序遍历

### 实现

```java
// 较为简单，直接实现
// 递归方式
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dsf(root, ans);
        return ans;
    }
    public void dsf(TreeNode head, List<Integer> ans) {
        if (head == null) return;
        dsf(head.left, ans);
        ans.add(head.val);
        dsf(head.right, ans);
    }

}


/**
	迭代
**/
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> ans = new LinkedList<>();

        while (!stack.isEmpty() || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            // 已经没有左节点了，取栈顶元素，先获取值，再指向右节点，重复上述过程
            root = stack.pop();
            ans.add(root.val);
            root = root.right;
        }
        return ans;
    }
}
```



### 144. 二叉树的前序遍历

### 分析

方式一 递归，很简单

方式二： 自己用栈进行模拟

方式三： 空间复杂度为`o1`， 莫里斯算法  *

方式四， 使用N叉树的先序遍历思路，见N叉树题解

### 实现

```java
/**
	递归
**/
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new LinkedList<>();
        dfs(root, ans);
        return ans;

    }
    public void dfs(TreeNode root, List<Integer> ans) {
        if (root == null) {
            return;
        }
        ans.add(root.val);
        dfs(root.left, ans);
        dfs(root.right, ans);
    }
}

/**
	用栈进行模拟， 和中序遍历区别在于，获取值的地方不一样
**/
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node != null) {
                res.add(node.val);
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        return res;
    }

}

/**
	用栈进行模拟方式2， 类似于层序遍历，但是是dfs， 并且每一层入栈是从后往前
**/
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (stack.size() > 0) {
            TreeNode topOne = stack.pop();
            ans.add(topOne.val);
            if (topOne.right != null) {
                stack.push(topOne.right);
            }
            if (topOne.left != null) {
                stack.push(topOne.left);
            }
        }
        return ans;

    }
```



## 145.后序遍历

### 实现

```java
/**
	递归
**/
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}

/**
	模拟栈（相比于另外两种，难点在于： 因为栈顶元素不能像之前那样，左边遍历完之后就提前出栈，二十要等到右边也遍历完才能出栈。因此难点在于如何判断右边节点是否被之前遍历过了）
**/
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> ans = new LinkedList<>();
        TreeNode lastRightVisted = null; // 上一次往右边遍历的那个节点
        while(stack.size() > 0 || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }

            root = stack.peek();
            if (root.right == null || root.right == lastRightVisted) {
                // 右节点为空或者之前已经被访问过了
                ans.add(root.val);
                lastRightVisted = root;
                root = null; // 设置为null是为了不让其进入内部的while循环，因为该节点的左子树已经全部被访问过了
                stack.pop();
            } else {
                // 访问右边节点
                root = root.right;
            }

        }
        return ans;
    }
}

/**
	手动模拟栈 方式2， 更简洁
*/
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        
        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> ans = new LinkedList<>();
        if (root == null) {
            return ans;
        }
        stack.push(root);

        while (stack.size() > 0) {
            TreeNode topOne = stack.pop();
            ans.add(topOne.val);
            
            if (topOne.left != null) {
                stack.push(topOne.left);
            }
            if (topOne.right != null) {
                stack.push(topOne.right);
            }
        }

        Collections.reverse(ans);  // 其实可以通过linkedlist，直接往第一个元素插值，就不用反转了
        return ans;
    }
}
```



## 589. N叉树的前序遍历

### 题目描述 (N叉树如果没有子节点，并不是null， 而是list长度为0)

[链接](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

```
给定一个 N 叉树，返回其节点值的前序遍历。

					    1
                    /   |    \
                  2     3     4
                 / \          |
                5   6         7
    返回 [1, 2, 5, 6, 3, 4, 7]
```

### 分析

递归很简单，主要分析以下手动压栈版本

比如根节点1已经入栈了，那么下一次，要入的是1的子节点， 因为下一个要访问的是2， 那么2必须在最上面，因此先把4入栈， 再把3入栈，再把2入栈。这一次结束。

同理，当前栈顶是2， 2的子节点从后往前入栈，先是6， 再是5

### 实现

```java
/**
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/


/**
	递归版本
*/
class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> ans = new ArrayList<>();
        dfs(root, ans);
        return ans;
    }

    private void dfs(Node root, List<Integer> ans) {
        if (root == null) {
            return;
        }
        ans.add(root.val);
        for (Node each : root.children) {
            dfs(each, ans);
        }
    }
}



/**
	迭代版本
*/

class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        
        Deque<Node> stack = new LinkedList<>();

        stack.push(root);
        while (stack.size() > 0) {
            Node top = stack.pop();
            ans.add(top.val);
            Collections.reverse(top.children);  // 这里是为了好理解，翻转标识从后往前，其实可以通过for循环的索引从后往前
            for (Node each : top.children) {
                stack.push(each);
            }
        }
        return ans;

    }
}
```



## 590 N叉树的后序遍历

### 题目描述

[链接](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

```
给定一个 N 叉树，返回其节点值的后序遍历。

					    1
                    /   |    \
                  2     3     4
                 / \          |
                5   6         7
    返回 [5， 6， 2， 3， 7， 4， 1]
```

### 分析

先把1压栈， 然后1的子节点中，顺序压栈，先压栈2， 然后是3， 然后是4， 同理，每次出栈的时候，将值放入结果集，得到结果是

`[1, 4, 7, 3, 2, 6, 5]`， 恰好是需要结果的翻转。

### 实现

```java
class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        Deque<Node> stack = new LinkedList<>();

        stack.push(root);
        while (stack.size() > 0) {
            Node top = stack.poll();
            ans.add(top.val);
            for (Node each : top.children) {
                stack.push(each);
            }
        }
        Collections.reverse(ans); // 不想翻转也可，直接用双向链表保存即可
        return ans;
    }
}
```





## 95. 不同的二叉搜索树2

### 描述

[链接](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

```
给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

### 分析

简单递归

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) {
      return new LinkedList<TreeNode>();
    }
    return generate_trees(1, n);
  }
    
    public LinkedList<TreeNode> generate_trees(int start, int end) {
	    LinkedList<TreeNode> ans = new LinkedList<TreeNode>();
	    if (start > end) {
	      ans.add(null);
	      return ans;
	    }

	    for (int i = start; i <= end; i++) {
	      LinkedList<TreeNode> left_trees = generate_trees(start, i - 1);
	      LinkedList<TreeNode> right_trees = generate_trees(i + 1, end);
	      for (TreeNode left : left_trees) {
	        for (TreeNode right : right_trees) {
	          TreeNode current_tree = new TreeNode(i);
	          current_tree.left = left;
	          current_tree.right = right;
	          ans.add(current_tree);
	        }
	      }
	    }
	    return ans;
	}

}
```



## 98. 验证二叉搜索树

### 描述

[链接](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```
定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

```

### 实现

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }

    public boolean helper(TreeNode node, Integer lower, Integer upper) {
        if (node == null) {
            return true;
        }

        int val = node.val;
        if (lower != null && val <= lower) {
            return false;
        }
        if (upper != null && val >= upper) {
            return false;
        }

        if (!helper(node.right, val, upper)) {
            return false;
        }
        if (!helper(node.left, lower, val)) {
            return false;
        }
        return true;
    }
}

```



## 反转链表*

### 递归实现(难点)

```java
ListNode reverse(ListNode head) {
    if (head.next == null) return head;
    ListNode last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}



/**
	* 反转前N个节点
**/
ListNode successor = null; // 后驱节点

// 反转以 head 为起点的 n 个节点，返回新的头结点
ListNode reverseN(ListNode head, int n) {
    if (n == 1) { 
        // 记录第 n + 1 个节点
        successor = head.next;
        return head;
    }
    // 以 head.next 为起点，需要反转前 n - 1 个节点
    ListNode last = reverseN(head.next, n - 1);

    head.next.next = head;
    // 让反转之后的 head 节点和后面的节点连起来
    head.next = successor;
    return last;
}



/**
 * 反转区间链表  
 * 如果 M= 1就是上面的情况。如果把 head.next 的索引视为 1 ， 那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的；同理一直往后
**/
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        return reverseN(head, n);
    }
    // 前进到反转的起点触发 base case
    head.next = reverseBetween(head.next, m - 1, n - 1);
    return head;
}


```

## 100. 判断相同的树

### 描述

[链接](https://leetcode-cn.com/problems/same-tree/)

```
给定两个二叉树，编写一个函数来检验它们是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true


```

### 分析

先判断当前节点，如果不满足直接返回，满足递归判断左子树和右子树

### 实现

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {// 都为空，说明相同，是递归的正确返回条件
            return true;
        }

        if(p == null || q == null) {
            // 一个为空，一个不为空，返回false
            return false;
        }
        if (q.val != p.val) {
            // 节点的值不同，不是相同的树，直接返回false
            return false;
        }

        if (isSameTree(p.left, q.left) == false) {
            // 左子树的结构不同，返回false
            return false;
        }
        if (isSameTree(p.right, q.right) == false) {
            // 右子树的结构不同，返回false
            return false;
        }
        return true;
    }
}
```



## 101. 对称二叉树

### 描述

[链接](https://leetcode-cn.com/problems/symmetric-tree/)

```
给定一个二叉树，检查它是否是镜像对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

### 分析

简单递归

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return isTrue(root, root);
    }
    private boolean isTrue(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return true;
        if (root1 == null || root2 == null) return false;
        if (root1.val != root2.val) return false;

        if (isTrue(root1.left, root2.right) == false) return false;
        if (isTrue(root1.right, root2.left) == false) return false;
        return true;
    }
}
```



## 102. 二叉树层序遍历

### 实现

```java
// 使用 队列
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();  // 双向队列用于队列
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        deque.addLast(root);

        while (deque.size() > 0) {
            int number = deque.size();
            List<Integer> subList = new ArrayList<>();
            for (int i = 0; i < number; i++) {
                TreeNode firstOne = deque.removeFirst();
                subList.add(firstOne.val);
                if (firstOne.left != null) {
                    deque.addLast(firstOne.left);
                }
                if (firstOne.right != null) {
                    deque.addLast(firstOne.right);
                }
            }
            ans.add(subList);
        }
        return ans;
    }

}
```

## 103. 二叉树锯齿形层序遍历

### 描述

[链接](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

```
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）
```

### 分析

如果只是单纯的层序遍历，使用队列即可，如果是交替层序遍历，采用双向队列即可。如果是奇数层，当做队列使用，如果是偶数层，当做栈使用。奇数层，先push左节点，再右节点。反之

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;

        Deque<TreeNode> deque = new LinkedList<>();
        int level = 0;  // level 代表层，奇数层  从左到右，使用队列， 偶数层从右到左，使用栈，使用双向队列，既包含栈，又包含队列
        deque.addLast(root);

        while (!deque.isEmpty()) {
            int number = deque.size();
            level += 1;
            List<Integer> subList = new ArrayList<>();

            if (level % 2 == 1) {
                //  从左到右
                for (int i = 0; i < number; i++) {
                    TreeNode firstOne =  deque.removeFirst();
                    subList.add(firstOne.val);
                    if (firstOne.left != null) {
                        deque.addLast(firstOne.left);
                    }
                    if (firstOne.right != null) {
                        deque.addLast(firstOne.right);
                    }
                }
            } else {
                for (int i = 0; i < number; i++) {
                    TreeNode firstOne = deque.removeLast();
                    subList.add(firstOne.val);
                    if (firstOne.right != null) {
                        deque.addFirst(firstOne.right);
                    }
                    if (firstOne.left != null) {
                        deque.addFirst(firstOne.left);
                    }
                }
            }
            ans.add(subList);
        }
        return ans;
    }
}
```

## 104. 二叉树的最大深度

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```



## 105. 根据前序遍历和中序遍历构造二叉树

### 描述

[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
   3
   / \
  9  20
    /  \
   15   7
```

### 分析

前序遍历中，第一个值是root节点。而在中序遍历中，root节点值之前的数组是左子树的内容，之后数组的内容是右边子树的内容。因此递归的时候，每次找到左子树的内容和右子树的内容，继续构造二叉树

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildOne(preorder, inorder, 0, preorder.length - 1, 0, inorder.length);
    }

    private TreeNode buildOne(int[] preorder, int[] inorder, int preLeft, int preRight, int inoLeft, int inoRight) {
        if (preLeft > preRight) return null;
        TreeNode root = new TreeNode(preorder[preLeft]);

      	// 找到当前二叉树中的左子树有多少个节点
        int count = 0;
        while (preorder[preLeft] != inorder[inoLeft + count]) {
            count += 1;
        }
        // System.out.println(count);

        // inoLeft + count 代表 中序遍历中root节点的分割点
        root.left = buildOne(preorder, inorder, preLeft + 1, preLeft  + count, inoLeft, inoLeft + count - 1);

        root.right = buildOne(preorder, inorder, preLeft + count + 1, preRight, inoLeft + count + 1, inoRight);

        return root;

    }
}
```



## 106. 中序遍历和后序遍历构造二叉树

### 描述

[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```
根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]

  3
   / \
  9  20
    /  \
   15   7
```

### 分析

后上题思路差不多。后续遍历的最后一个值一定是root， 根据这个值，找到左子树的个数，然后分割两个数组，进行递归，分别构建root的左子树和右子树

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildOne(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);
    }
    private TreeNode buildOne(int[] inorder, int[] postorder, int left1, int right1, int left2, int right2) {
        if (left2 > right2) return null;

        TreeNode root = new TreeNode(postorder[right2]);

        int count = 0;
        while (inorder[left1 + count] != postorder[right2]) {
            count += 1;
        }

        root.left = buildOne(inorder, postorder, left1, left1 + count - 1, left2, left2 + count - 1);
        root.right = buildOne(inorder, postorder, left1 + count + 1, right1, left2 + count, right2 - 1);

        return root;
    }
}
```

## 107. 二叉树的层序遍历2

### 描述

[链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],
  	3
   / \
  9  20
    /  \
   15   7
[
  [15,7],
  [9,20],
  [3]
]
```

### 分析

和层序遍历没有什么区别。可以在插入List的时候指定位置，也可以将最后结果直接进行反转

### 实现

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> levelOrder = new LinkedList<List<Integer>>();
        if (root == null) {
            return levelOrder;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                TreeNode left = node.left, right = node.right;
                if (left != null) {
                    queue.offer(left);
                }
                if (right != null) {
                    queue.offer(right);
                }
            }
            levelOrder.add(0, level);
        }
        return levelOrder;
    }
}

```



## 108. 将有序数组转化为二叉搜索树

### 描述

[链接](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5

```

### 分析

找到中心点，作为root，然后分别构建左子树和右子树

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return buildOne(nums, 0, nums.length - 1);
    }
    public TreeNode buildOne(int[] nums, int left, int right) {
        if (left > right) return null;
        int middle = (left + right) / 2;
        TreeNode root = new TreeNode(nums[middle]);

        root.left = buildOne(nums, left, middle - 1);
        root.right = buildOne(nums, middle + 1, right);
        return root;
    }
}
```



## 109. 有序链表转化为二叉搜索树

### 描述

和上一道题几乎一样，区别在于输入的是链表

### 分析

数组可以获得索引，因此很容易找到中心点。所以稍微复杂一点的只是寻找中心节点。

### 实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return buildTree(head, null);
    }

  // right为尾节点的下一个节点
    private TreeNode buildTree(ListNode left, ListNode right) {
        if (left == right) return null;

        ListNode mid = getMiddle(left, right);
        TreeNode root = new TreeNode(mid.val);
        root.left = buildTree(left, mid);
        root.right = buildTree(mid.next, right);
        return root;

    }

    private ListNode getMiddle(ListNode left, ListNode right) {
        ListNode fast = left;
        ListNode slow = left;
        while (fast != right && fast.next != right) {
            fast = fast.next;
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```



## 110. 判断二叉树是否是平衡二叉树

### 描述

[链接](https://leetcode-cn.com/problems/balanced-binary-tree/)

```
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
```



### 分析

根据递归求深度。难点在于如果子树已经不是平衡二叉树的时候，就不再递归了。如果子树已经不是平衡二叉树了，那么返回高度的长度为-1来标识，一层一层往上把 -1 抛出去，类似于一层一层向上抛出异常的操作

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
      // 如果数的告诉不是 -1 ，说明没有问题。如果是-1，说明在某个节点已经不是子树，一直往上抛
        return getLength(root) != -1;
    }

    private int getLength(TreeNode root) {
        if (root == null) return 0;
      
       // 左子树 已经不是平衡二叉树  ，直接往上抛
        int left = getLength(root.left);
        if (left == -1) return -1;

      	// 右子树 已经不是平衡二叉树，直接往上抛
        int right = getLength(root.right);
        if (right == -1) return -1;
				
      	// 当前树不是平衡二叉树，也往上抛出去
        if (Math.abs(left - right) > 1) return -1;
				
      	// 返回树的高度
        return Math.max(left, right) + 1;
    }
}
```

## 111.二叉树的最小深度

### 描述

[链接](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

    3
   / \
  9  20
    /  \
   15   7
   
最小深度为2
```

### 分析

如果一棵树的左子树为空，则返回右子树的最小深度加1.反之。

如果左子树和右子树都不为null， 返回左右的最小深度的较小值 加1

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null) return minDepth(root.right) + 1;
        if (root.right == null) return minDepth(root.left) + 1;
        return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    }
}
```



## 112. 路径总和

### 描述

[链接](https://leetcode-cn.com/problems/path-sum/)

```
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
sum =22 , 返回true, 因为存在路径之和为22
```



### 分析

简单递归

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        if (root.val == sum && root.left == null && root.right == null) return true;

        if (hasPathSum(root.left, sum - root.val)) return true;

        if (hasPathSum(root.right, sum - root.val)) return true;

        return false;
    }
}
```



## 113. 路径总和2

### 描述

[链接](https://leetcode-cn.com/problems/path-sum-ii/)

```
题目与上一题一样，但是返回所有的可能情况
返回：
[
   [5,4,11,2],
   [5,8,4,5]
]
```

### 分析

找寻所有情况，明显使用回溯。具体看代码。

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        Deque<Integer> path = new LinkedList<>();
        dfs(root, sum, ans, path);
        return ans;
    }
    private void dfs(TreeNode root, int sum, List<List<Integer>> ans, Deque<Integer> path) {
        if (root == null) return;
      
      //  满足条件(总和等于sum， 是根节点， 加入到结果集中并返回)
        if (sum == root.val && root.left == null && root.right == null) {
            path.addLast(root.val);
            ans.add(new ArrayList<>(path));
            path.removeLast();
            return;
        }
        path.addLast(root.val);
      	// 往左边走
        dfs(root.left, sum - root.val, ans, path);
      	// 往右边走
        dfs(root.right, sum - root.val, ans, path);
        path.removeLast();
    }


}
```



## 114. 二叉树原地展开为链表

### 描述

[链接](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```
   1
   / \
  2   5          ->>>>     
 / \   \
3   4   6

变成：
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

### 分析

整个流程其实类似一个前序遍历。一个root节点，左子树的最右边最右边的节点指向右边的第一个节点。因此，可以先找到左子树的最右边的根节点，然后指向右边。然后继续递归下去。

### 实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {

        while (root != null) {
            TreeNode next = root.left;
            if (next == null) {
                root = root.right;
                continue;
            }
            TreeNode temp = next;
            // 找到左子树最右最右的节点
            while (temp.right != null) {
                temp = temp.right;
            }

            // 左子树的最右节点指向右子树
            temp.right = root.right;
            root.left = null;
            root.right = next;
            
            root = root.right;
        }
        
    }

}
```

## 116. 填充每个节点的下一个节点的右侧节点指针

### 描述

[链接](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```java
// 题目描述过于复杂，点开链接直接看吧
```

### 分析

一种很简单的方式就是层序遍历，但是需要额外的队列的空间。如果不适用额外的空间，可以借助next指针。

* 如果是一个节点的left和right，直接把left.next指向right。
* 如果是不同节点，需要注意的是，上一层已经有next了，因此，head.next=head2.而需要做的只是  head1.right .next 指向head.left。 即变成  head1.right.next指向  head1.next.left。

### 实现

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if (root == null) return root;

        Node leftMost = root;
        while (leftMost.left != null) {

            Node head = leftMost;

            while (head != null) {
                head.left.next = head.right;
                if (head.next != null) {
                    head.right.next = head.next.left;
                }
                head = head.next;
            }
            leftMost = leftMost.left;

        }
        return root;

    }
}
```



## 124. 二叉树中的最大路径和(H)

### 描述

[链接](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```
给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

输入：[1,2,3]

       1
      / \
     2   3

输出：6
```

### 分析

最大路径可以是从2->1->3这种方式，并不是单向的。因此， 假设根节点的左节点的最大单向路径`leftMax`和以及右边节点的最大路径和`rightMax`都求出来了(递归), 那么， 如果二者都小于0，那么该节点的最大单向路径为 自己本身的值。否则等于自己的值加上更大的哪个值。

全局的结果和最大单向路径和不一样，因此需要保存一个全局变量，实时更新全局结果

* 单向指的是，只能是从上到下，比如1到2或者1到3
* 题目要求的是，可以从2到1再到3

### 实现

```java
class Solution {
    int maxPathSum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        getMax(root);
        return maxPathSum;
    }

    public int getMax(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftMax = getMax(root.left);  // 左节点的单向最大路径和
        int rightMax = getMax(root.right);

        int subMaxPathSum = root.val; // 本节点的全局最大路径和 
        if (leftMax > 0) {
            subMaxPathSum += leftMax;
        }
        if (rightMax > 0) {
            subMaxPathSum += rightMax;
        }

        maxPathSum = Math.max(maxPathSum, subMaxPathSum); // 更新全局最大路径和

        // 返回值只能选择左边或者右边，因为是单向的
        if (leftMax < 0 && rightMax < 0) {
            return root.val;
        } else {
            return root.val + Math.max(leftMax, rightMax);
        }
    }
}
```



## 129. 求根节点到叶子节点的数字之和

### 描述

[链接](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```
给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
例如，从根到叶子节点路径 1->2->3 代表数字 123。
计算从根到叶子节点生成的所有数字之和。

输入: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
输出: 1026
解释:
从根到叶子节点路径 4->9->5 代表数字 495.
从根到叶子节点路径 4->9->1 代表数字 491.
从根到叶子节点路径 4->0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.
```

### 分析

方法一：递归(深度优先遍历)： 每个节点，记录下当前，已经前驱的值，比如，9这个节点，记录下当前的值为49，然后把49递归传递给左节点和右节点。遇到根节点则进行返回。

方法2： 层序遍历(广度优先遍历)：层序遍历一样的套路，只不过多一个队列记录当前节点的前驱值



### 实现

```java
/**
	递归(深度优先)
**/
class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root, 0);
    }

    public int dfs(TreeNode root, int prevSum) {
        if (root == null) {
            return 0;
        }
        int sum = prevSum * 10 + root.val;
        if (root.left == null && root.right == null) {
            return sum;
        } else {
            return dfs(root.left, sum) + dfs(root.right, sum);
        }
    }
}

/**
	层序遍历
**/
class Solution {
    public int sumNumbers(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int sum = 0;
        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();
        Queue<Integer> numQueue = new LinkedList<Integer>();
        nodeQueue.offer(root);
        numQueue.offer(root.val);
        while (!nodeQueue.isEmpty()) {
            TreeNode node = nodeQueue.poll();
            int num = numQueue.poll();
            TreeNode left = node.left, right = node.right;
            if (left == null && right == null) {
                sum += num;
            } else {
                if (left != null) {
                    nodeQueue.offer(left);
                    numQueue.offer(num * 10 + left.val);
                }
                if (right != null) {
                    nodeQueue.offer(right);
                    numQueue.offer(num * 10 + right.val);
                }
            }
        }
        return sum;
    }
}
```



## 199. 二叉树的右视图

### 题目描述

[链接](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

```

### 分析

最直观的想法，层序遍历(广度优先)，每一层的最右边一个元素即满足条件的值

方法二：深度优先(递归)， 某个节点，某次先递归访问右边节点，再访问左边节点。主要点在于什么时候将元素加入到结果集中。每次递归的时候，传入当前的集合，并且记录当前的深度，如果深度等于集合的大小+1，说明，当前层还没有加入，第一次满足的时候就加入。(因为先访问右边，再访问左边，因此第一个满足条件的一定是该层最右边的元素)

### 实现

```java
/**
	递归(深度优先遍历)
**/
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        int high = 1;
        List<Integer> ans = new LinkedList<>();
        dfs(root, ans, high);
        return ans;
    }

    public void dfs(TreeNode root, List<Integer> ans, int high) {
        if (root == null) {
            // 如果为空，跳出递归
            return;
        }

        if (ans.size() + 1 == high) {
            // 如果结果集的长度+1等于当前的高度，说明该层还没有加入。
            ans.add(root.val);
        }

        // 先递归右边，再递归左边, 高度应该加1
        dfs(root.right, ans, high + 1);
        dfs(root.left, ans, high + 1);
    }
}

/**
	层序遍历(广度优先)
**/
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
                if (i == size - 1) {  //将当前层的最后一个节点放入结果列表
                    res.add(node.val);
                }
            }
        }
        return res;
    }
}

```



## 22. 完全二叉树的个数

### 描述

[链接](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```
给出一个完全二叉树，求出该树的节点个数。
完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6
```

### 分析

完全二叉树， 

那么我们来对 root 节点的左右子树进行高度统计，分别记为 left 和 right，有以下两种结果：

* `left == right`。这说明，左子树一定是满二叉树，因为节点已经填充到右子树了，左子树必定已经填满了。所以左子树的节点总数可以直接得到，是 `2^left - 1`，加上当前这个 root 节点，则正好是` 2^left`。再对右子树进行递归统计。
* `left != righ`。说明此时最后一层不满，但倒数第二层已经满了，可以直接得到右子树的节点个数。同理，右子树节点 +root 节点，总数为` 2^right`。再对左子树进行递归查找。

### 实现

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root == null){
           return 0;
        } 
        int left = countLevel(root.left);
        int right = countLevel(root.right);
        if(left == right){
            return countNodes(root.right) + (1<<left);
        }else{
            return countNodes(root.left) + (1<<right);
        }
    }
    
    /**
    	利用完全二叉树的特性求高度
    **/
    public int countLevel(TreeNode root){
        int level = 0;
        while(root != null){
            level++;
            root = root.left;
        }
        return level;
    }
}

```



## 226. 翻转二叉树

### 描述

[链接](https://leetcode-cn.com/problems/invert-binary-tree/)

```
翻转一棵二叉树。

         4
       /   \
      2     7                   
     / \   / \
    1   3 6   9
    
    
     4
   /   \
  7     2
 / \   / \
9   6 3   1

```

### 分析

简单递归，先反转左子树，再反转右子树，再调换顺序

### 实现

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }

        TreeNode invertedLeft = invertTree(root.left);
        TreeNode invertedRight = invertTree(root.right);

        root.left = invertedRight;
        root.right = invertedLeft;
        return root;
    }
}
```



## 230. 二叉搜索树中第K小的数

### 描述

[链接](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```
给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。
说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3

```

### 分析

二叉搜索树的中序遍历是有序的。因此需要模拟中序遍历的过程。类似于，没打印一次结果，给count计数加1，如果count等于K的时候，返回结果。如果count大于k，则跳出遍历过程

### 实现

```java
/**
	递归模拟中序遍历
**/

class Solution {
    int ans = 0;
    int count = 0;
    public int kthSmallest(TreeNode root, int k) {
        dfs(root, k);
        return ans;
    }

    public void dfs(TreeNode root, int k) {
        if (root == null) {
            return;
        }
        if (root.left != null) {
            // 左边一直有，一直递归下去
            dfs(root.left, k);
        }
        // 出栈一个，计数加1
        count += 1;
        
        if (count > k) {
            return;  // 减枝， count已经大于k，之前已经找到想要的结果了，没必要继续递归了
        } else if (count == k) {
            // count等于k，则该次找到了结果，更新结果
            ans = root.val;
            return;
        }
        
        if (root.right != null) {
            // 左边还没有找到，则往右边继续寻找
            dfs(root.right, k);
        }
    }
}

/**
	手动压栈版本，同样模拟中序遍历
**/
class Solution {

    public int kthSmallest(TreeNode root, int k) {
        
        Deque<TreeNode> stack = new LinkedList<>();
        int count = 0;
        while (stack.size() > 0 || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }

            // 出一次栈，count加1
            root = stack.pop();
            count += 1;

            if (count == k) {
                // 第k次出栈
                return root.val;
            }
            
            root = root.right;
        }
        return 0;
    }
}
```



## 235. 二叉搜索树的最近公共祖先

### 描述

[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

### 分析

* 如果两个节点在根节点的两侧，那么最近公共祖先为根节点
* 某个节点刚好等于根节点，最近公共祖先为根节点
* 如果两个节点在根节点的同侧，递归那一侧即可

### 实现

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p.val > q.val) {
            TreeNode temp = p;
            p = q;
            q = temp;
        }
        if(p == root || q == root) return root; // 某个节点等于root，直接返回
        if(p.val < root.val && q.val > root.val) return root; // 在root的两侧
        if(p.val < root.val && q.val < root.val) { // 都在root的左侧
            return lowestCommonAncestor(root.left, p, q);
        }else {
            // 都在root的右侧
            return lowestCommonAncestor(root.right, p, q);
        }
    }
}
```



## 257. 二叉树的所有路径

### 描述

[链接](https://leetcode-cn.com/problems/binary-tree-paths/)

```
给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。

输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]
解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

### 分析

递归，保存之前已经走过路径的字符，加上本次的字符。遇到根节点则加入结果集

### 实现

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> ans = new LinkedList<>();
        dfs(root, ans, "");
        return ans;

    }

    public void dfs(TreeNode root, List<String> ans, String str) {
        if (root == null) {
            // 为null， 没有遇到根节点，直接返回
            return;
        }
        String subAns = str + root.val + "->";
        if (root.left == null && root.right == null) {
            // 遇到根节点，加入结果集，返回
            ans.add(str + root.val);
            return;
        }

        dfs(root.left, ans, subAns);
        dfs(root.right, ans, subAns);
    }
}
```



### 337. 打家劫舍3

### 描述

[链接](https://leetcode-cn.com/problems/house-robber-iii/)

```\
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

### 分析

任何一个节点能偷到的最大钱的状态可以定义为

* 当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱
* 当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数

### 实现

```java
class Solution {
    public int rob(TreeNode root) {
        int[] ans = getMax(root);

        return Math.max(ans[0], ans[1]);
    }

    public int[] getMax(TreeNode root) {
        int[] max = new int[2];  // 第一个值表示当前节点不偷的最大收益， 第二个值表示当前节点偷的最大收益
        if (root == null) {
            return max;
        }

        int[] leftMax = getMax(root.left);
        int[] rightMax = getMax(root.right);

        // 当前节点不偷， 左右节点，偷不偷都可以
        max[0] = Math.max(leftMax[0], leftMax[1]) + Math.max(rightMax[0], rightMax[1]);
        // 当前节点偷， 左右节点都不能偷
        max[1] = root.val + leftMax[0] + rightMax[0];
        
        return max;
    }
}
```

## 404 左叶子之和

### 描述

[链接](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```
计算给定二叉树的所有左叶子之和。
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

### 分析

递归，如果当前节点的左节点是根节点，加入到结果集，否则递归

### 实现

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int ans = 0;
        if (root == null) {
            return 0;
        }

        if (root.left != null && root.left.left == null && root.left.right == null) {
            // 满足条件，加入结果
            ans += root.left.val;
            // 继续找右子树
            ans += sumOfLeftLeaves(root.right);
        } else {
            // 不满足，递归左子树和右子树
            ans += sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
        }
        return ans;
    }
}
```



## 437. 路径总和3

### 题目描述

[链接](https://leetcode-cn.com/problems/path-sum-iii/)

```
给定一个二叉树，它的每个结点都存放着一个整数值。
找出路径和等于给定数值的路径总数。
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:
1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

### 分析

方式一： 最原始的方式，每一次求从root节点开始满足条件的个数。然后递归求其他所有的结果。很多重复的计算，复杂度比较高

方式二： 前缀和。类似于两个线段，如果A和B的前缀和都知道，那么A和B之间的距离为A的前缀和减去B的前缀和。类似的，每个节点，缓存之前的前缀和，然后直接计算

### 实现

```java
/**
	方式1： 暴力方式
**/

class Solution {
    
    public int pathSum(TreeNode root, int sum) {
        if (root == null) {
            return 0;
        }
        return dfs(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    }

    // 此方法意思是，一定从root开始，得到的所有情况
    public int dfs(TreeNode root, int target) {
        if (root == null) {
            return 0;
        }
        int ans = 0;
        if (root.val == target) {
            ans += 1;
        }
        // 并不返回继续执行
        ans += dfs(root.left, target - root.val);
        ans += dfs(root.right, target - root.val);
        return ans;
    }

}


/**
 	前缀和方式：(递归里面使用全局变量模式)
**/
class Solution {
    int count = 0;
    Map<Integer, Integer> map = new HashMap<>();
    public int pathSum(TreeNode root, int sum) {
        map.put(0, 1);
        dfs(root, 0, sum);
        return count;
    }

    public void dfs(TreeNode root, int preSum, int target) {
        if (root == null) {
            return;
        }
        int newPreSum = preSum + root.val;  // 更新本节点的前缀和

        // A和B点的前缀和的差  等于 A到B的路径
        count += map.getOrDefault(newPreSum - target, 0);
        
        // 前缀和 加1
        map.put(newPreSum, map.getOrDefault(newPreSum, 0) + 1);

        // 继续左边和右边
        dfs(root.left, newPreSum, target);
        dfs(root.right, newPreSum, target);

        // 从递归左边和右边结束，回到这一层，即将离开这一层，需要删除该节点的前缀和
        map.put(newPreSum, map.get(newPreSum) - 1);
    }
}


/**
 	前缀和方式：(递归里面不使用全局变量， 异曲同工，局部变量更好)
**/
class Solution {
    
    public int pathSum(TreeNode root, int sum) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        return dfs(root, 0, map, sum);
    }

    public int dfs(TreeNode root, int preSum, Map<Integer, Integer> map,  int target) {
        if (root == null) {
            return 0;
        }
        int count = 0;

        int newPreSum = preSum + root.val;  // 更新本节点的前缀和

        // A和B点的前缀和的差  等于 A到B的路径
        count += map.getOrDefault(newPreSum - target, 0);
        
        map.put(newPreSum, map.getOrDefault(newPreSum, 0) + 1);

        // 继续左边和右边
        int leftCount = dfs(root.left, newPreSum, map, target);
        int rightCount = dfs(root.right, newPreSum, map, target);

        count += leftCount;
        count += rightCount;

        // 从递归左边和右边结束，回到这一层，即将离开这一层，需要删除该节点的前缀和
        map.put(newPreSum, map.get(newPreSum) - 1);

        return count;
    }
}
```



## 449. 序列化和反序列化二叉搜索树

### 题目描述

[链接](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)

```
序列化和反序列化 二叉搜索树
```

### 分析

使用前序遍历。前序遍历的第一个值是根节点。因此二叉搜索树根节点左侧全部小于他右侧全部大于他，因此，找到前序遍历的分界点，左右递归生成树即可

### 实现

```java
public class Codec {

    // 序列化，使用前序遍历
    public String serialize(TreeNode root) {
        if (root == null) {
            return "null";
        }
        StringBuilder sb = new StringBuilder();
        dfs(root, sb);
        sb.deleteCharAt(0);
        return sb.toString();
    }

    private void dfs(TreeNode root, StringBuilder sb) {
        if (root == null) {
            return;
        }
        sb.append(",");
        sb.append(root.val);
        dfs(root.left, sb);
        dfs(root.right, sb);
    }



    // 反序列化
    public TreeNode deserialize(String data) {
        if ("null".equals(data)) {
            return null;
        }
        String[] dataArray = data.split(",");
        int[] nums = new int[dataArray.length];
        for (int i = 0; i < nums.length; i++) {
            nums[i] = Integer.parseInt(dataArray[i]);
        }

        return buildTree(nums, 0, nums.length - 1);
    }
	
    // 利用前序遍历生成二叉搜索树
    private TreeNode buildTree(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        int splitIndex = left + 1;
        while (splitIndex <= right && nums[splitIndex] < nums[left]) {
            splitIndex += 1;
        }
        TreeNode node = new TreeNode(nums[left]);
        node.left = buildTree(nums, left + 1, splitIndex - 1);
        node.right = buildTree(nums, splitIndex, right);
        return node;
    }
}
```





## 450 删除二叉搜索树的某个节点

### 题目描述

[链接](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

```
给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。
说明： 要求算法时间复杂度为 O(h)，h 为树的高度

root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

```

### 分析

先定位到节点，然后删除节点。

删除节点的时候，如果该节点的右侧节点为空，返回该节点的左节点/如果右侧不为空。需要找到右子树的最左侧节点，然后指向该节点的左侧节点。并返回右侧节点

### 实现

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) {
            return null;
        }
        if (root.val == key) {
            // 找到节点了，删除该节点，返回删除之后的节点
            return help(root, key);
        } else if (key < root.val) {
            // 节点在左侧，递归返回删除之后的树
            root.left = deleteNode(root.left, key);
        } else {
            root.right = deleteNode(root.right, key);
        }
        return root;
    }
	
    // 删除该节点，并保持二叉搜索树的结构
    TreeNode help(TreeNode root, int key) {

        TreeNode minRightNode = root.right;
        if (root.right == null) {
            return root.left;
        }
        while (minRightNode.left != null) {
            minRightNode = minRightNode.left;
        }
        minRightNode.left = root.left;
        return root.right;
    }
}
```



## 501. 二叉搜索树中的众数

### 描述

[链接](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```
给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
```

### 分析

二叉搜索树的中序遍历有序。因此进行中序遍历的过程。每次保存，当前值的个数，目前的最大个数。如果当前值个数超过了最大个数，则更新结果集

### 实现

```java
class Solution {
    int lastNumber = 0;  // 上一个遍历的值是什么
    int maxCount = 0;  // 最大的个数
    int currentCount = 0;  // 当前值的个数
    List<Integer> ans = new LinkedList<>(); // 结果集
    public List<Integer> findMode(TreeNode root) {
        if(root == null) {
            return ans;
        }
        dfs(root);
        return ans;
    }
    
    // 进行中序遍历过程
    public void dfs(TreeNode root) {
        if (root == null) {
            return;
        }

        dfs(root.left);
        
        if (root.val == lastNumber) {
            // 如果当前值和上一个遍历的值相等，当前个数加1
            currentCount += 1;
        } else {
            // 和上一个不相等，当前个数重置为1
            currentCount = 1;
            lastNumber = root.val;
        }

        if (currentCount == maxCount) {
            // 等于最大个数，加入结果
            ans.add(lastNumber);
        } else if (currentCount > maxCount) {
            //大于目前的最大个数，清空结果集再加入
            maxCount = currentCount;
            ans.clear();
            ans.add(lastNumber);
        }
		// 遍历右边
        dfs(root.right);
    }
}
```



## 508. 出现次数最多的子树元素和

### 题目描述

[链接](https://leetcode-cn.com/problems/most-frequent-subtree-sum/)

```
给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。

你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。

  5
 /  \
2   -3
返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。
```

### 分析

求得所有的元素和，放入map中，然后找最大的即可

递归函数返回值是当前子树的元素和，那么有`sum=root.val + dfs(root.left)+dfs(root.right)`

### 实现

```java
class Solution {
    public int[] findFrequentTreeSum(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<>();
        dfs(root, map);
        int maxCount = 0;
        for (Map.Entry<Integer, Integer> each : map.entrySet()) {
            if (each.getValue() > maxCount) {
                maxCount = each.getValue();
            }
        }

        List<Integer> ans = new ArrayList<>();
        for (Map.Entry<Integer, Integer> each : map.entrySet()) {
            if (each.getValue() == maxCount) {
                ans.add(each.getKey());
            }
        }
        
        int[] array = new int[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            array[i] = ans.get(i);
        }
        return array;
    }
	
    /**
    	递归函数，将所有的元素和放入map中
    */
    private int dfs(TreeNode root, Map<Integer, Integer> ans) {
        if (root == null) {
            return 0;
        }

        int sum = root.val + dfs(root.left, ans) + dfs(root.right, ans);
        ans.put(sum, ans.getOrDefault(sum, 0) + 1);
        return sum;
    }
}
```



## 513. 找树的最后一行的第一个值

### 题目描述

[链接](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```
给定一个二叉树，在树的最后一行找到最左边的值。
输入:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

输出:
7
```

### 分析

思路1： 一种很直观的思路就是`BFS`层序遍历，每一层的第一个，如果是最后一层的话，就是结果值。层序遍历即可

思路2：考虑深度优先和递归， 找到左子树的最后一行的第一个值，和右子树的最后一行的第一个值。那么选左边的还是右边的呢，看谁的深度更大，因此，还需要记录左子树的返回值对应的深度，以及右子树返回值的深度。使用一个两个元素的数组即可

### 实现

```java

// 方法1， 层序遍历
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        if (root == null) {
            return -1;
        }
        int ans = root.val;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.addLast(root);
        while (deque.size() > 0) {
            ans = deque.getLast().val; // 更新ans
            int count = deque.size();
            for (int i = 1; i <= count; i++) {
                TreeNode top = deque.removeFirst();
                if (top.right != null) {
                    deque.addLast(top.right);
                }
                if (top.left != null) {
                    deque.addLast(top.left);
                }
            }
        }
        return ans;
        
    }
}


// 方法2， dfs
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        int[] ans = dfs(root, 1); // 初始化深度为1
        return ans[1];
    }

    private int[] dfs(TreeNode root, int level) {
        int[] ans = new int[2]; // 第一个为对应的深度， 第二个为值
        if (root == null) {
            return ans;
        }
        if (root.left == null && root.right == null) {
            // 是根节点，返回深度和当前的值
            ans[0] = level;
            ans[1] = root.val;
            return ans;
        }
		
        //递归找左子树和右子树的值， 注意 深度加1， level + 1
        int[] leftAns = dfs(root.left, level + 1);
        int[] rightAns = dfs(root.right, level + 1);

        if (root.left == null) {
            // 左子树为空，右子树不为空，返回右边的结果即可
            return rightAns;
        }
        if (root.right == null) {
            // 同理返回左边的即可
            return leftAns;
        }

        // 都不为空
        if (leftAns[0] >= rightAns[0]) {
            // 如果左边值得深度大于等于右边，返回左边，否则返回右边
            return leftAns;
        } else {
            return rightAns;
        }
    }
}
```



## 515. 在每个树行中找最大值

### 题目描述

[链接](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```
您需要在二叉树的每一行中找到最大的值。
输入: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

输出: [1, 3, 9]
```

### 分析

简单层序遍历即可

### 实现

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.addLast(root);

        while (!deque.isEmpty()) {
            int max = Integer.MIN_VALUE;
            int count = deque.size();
            for (int i = 1; i <= count; i++) {
                TreeNode top = deque.removeFirst();
                max = Math.max(max, top.val);
                
                if (top.left != null) {
                    deque.addLast(top.left);
                }

                if (top.right != null) {
                    deque.addLast(top.right);
                }
            }
            ans.add(max);
        }
        return ans;

    }
}
```



## 530. 二叉搜索树的最小绝对值差

### 题目描述

[链接](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

```
给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

### 分析

中序遍历即可，需要保存上一个值，然后做差，更新结果。

使用递归，需要使用全局变量来保存结果和上一个值。也可以不使用全局变量使用一个数组来返回这两个值，但是有点绕。

使用迭代，模拟中序遍历，更直观

### 实现

```java
// 迭代版本
class Solution {
    public int getMinimumDifference(TreeNode root) {
        Integer pre = null; // 使用包装类来保存上一个值，方便最开始第一个值的时候，直接判空 跳过
        int ans = Integer.MAX_VALUE;
        
        Deque<TreeNode> stack = new LinkedList<>();
        // 中序遍历
        while (stack.size() > 0 || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }

            TreeNode top = stack.pop();
            if (pre != null) {
                ans = Math.min(ans, top.val - pre); // 更新最小值
            }
            pre = top.val; // 更新上一个值
            root = top.right;
        }
        return ans;
    }
}


// 递归版本 (全局变量)
class Solution {
    int ans = Integer.MAX_VALUE;
    Integer pre = null;
    public int getMinimumDifference(TreeNode root) {
        dfs(root);

        return ans;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        dfs(root.left);  // 先递归左边
        
        // 然后更新pre和ans
        if (pre != null) {
            ans = Math.min(ans, root.val - pre);
        }
        pre = root.val;
        
        // 递归右边
        dfs(root.right);
    }
}
```



## 538. 把二叉搜索树转化为累加树

### 题目描述

[链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

```
给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

输入：root = [1,0,2]
输出：[3,3,2]
```

### 分析

中序遍历即可，但是此处是先遍历右边。每次保存一个`sum`即可。跟上一题很类似

### 实现

```java
/**
	迭代版本
*/

class Solution {
    public TreeNode convertBST(TreeNode root) {
        
        Deque<TreeNode> stack = new LinkedList<>();
        if (root == null) {
            return root;
        }

        TreeNode node = root;
        int sum = 0;
        while (stack.size() > 0 || node != null) {
            while (node != null) {
                stack.push(node);
                node = node.right;
            }

            TreeNode top = stack.pop();
            top.val += sum;
            sum = top.val;
            node = top.left;
        }
        return root;
    }
}

/**
	递归版本，使用全局变量
*/
class Solution {
    int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        dfs(root);
        return root;
    }

    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }

        dfs(root.right);
        root.val += sum;
        sum = root.val;
        dfs(root.left);
    }
}
```



## 543. 二叉树的直径

### 题目描述

[链接](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
          1
         / \
        2   3
       / \     
      4   5 
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

### 分析

这道题和124题很类似， 某个节点，求最大路径的时候，需要同时加上左右子树的结果，但是返回的时候，只能返回单向的，只要左子树或者右子树

### 实现

```java
class Solution {
    int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }
        getMax(root);
        return max - 1;
    }

    private int getMax(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftAns = getMax(root.left); // 左边最大的单向路径
        int rightAns = getMax(root.right);// 右边最大的单向路径
        max = Math.max(max,leftAns + rightAns + 1); // 更新max， 可以跨越左右
        return Math.max(leftAns, rightAns) + 1; // 返回的是单向路径的最大值
    }
}
```



## 559. N叉树的最大深度

### 题目描述

[链接](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

```
给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

输入：root = [1,null,3,2,4,null,5,6]
输出：3
```

### 分析

如果是递归，和二叉树思路一致，求子树的最大深度，加1即可

迭代版本，N叉树必须把每一层的都放进栈中，因此，必须标识当前节点在哪一层，使用`pair`来标识

### 实现

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public int maxDepth(Node root) {
        if (root == null) {
            return 0;
        }
        int max = 0;
        for (Node each : root.children) {
            max = Math.max(max, maxDepth(each));
        }
        return max + 1;
    }
}


// 迭代版本， Pair有点类似于 Map.Entry, 可以理解为二元组
class Solution {
    public int maxDepth(Node root) {
        if (root == null) {
            return 0;
        }
        int ans = 0;

        Deque<Pair<Node, Integer>> stack = new LinkedList<>();
        stack.push(new Pair(root, 1));

        while (stack.size() > 0) {
            Pair<Node, Integer> topOne = stack.pop();
            ans = Math.max(ans, topOne.getValue());
            Node node = topOne.getKey();

            for (Node each : node.children) {
                stack.push(new Pair(each, topOne.getValue() + 1));
            }
        }
        return ans;
    }
}
```



## 563. 二叉树的坡度

### 题目描述

[链接](https://leetcode-cn.com/problems/binary-tree-tilt/)

```
给定一个二叉树，计算 整个树 的坡度 。

一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。

整个树 的坡度就是其所有节点的坡度之和。

          1
         / \
        2   3
输入：root = [1,2,3]
输出：1
解释：
节点 2 的坡度：|0-0| = 0（没有子节点）
节点 3 的坡度：|0-0| = 0（没有子节点）
节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）
坡度总和：0 + 0 + 1 = 1

```

### 分析

简单递归即可，求得左子树的总和和右子树的总和， 求当前坡度，并加入到整体中，需要一个全局变量`ans`

### 实现

```java
class Solution {
    int ans = 0;
    public int findTilt(TreeNode root) {
        getSum(root);
        return ans;
    }

    private int getSum(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftSum = getSum(root.left);
        int rightSum = getSum(root.right);

        ans += Math.abs(leftSum - rightSum);

        return leftSum + rightSum + root.val;
    }
}
```



## 572. 某个树是否是另一个树的子树

### 题目描述

[链接](https://leetcode-cn.com/problems/subtree-of-another-tree/)

```
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

```

### 分析

这道题是判断子树，另一种问题是判断是否是另一个树的一部分。因此必须完全相等。

只要确定起始点之后，再去判断是否完全相等即可



这道题的官方题解中，有其他两种别的思路，特别复杂特别复杂， 有兴趣就看看吧(没必要啊)

### 实现

```java
class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (s == null) {
            return t == null;
        }
        return isSame(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
    }

    /**
    	判断两个树是否完全一致
    */
    private boolean isSame(TreeNode first, TreeNode second) {
        if (first == null && second == null) {
            return true;
        }

        if (first == null || second == null || first.val != second.val) {
            return false;
        }

        return isSame(first.left, second.left) && isSame(first.right, second.right);
    }
}
```



## 606. 根据二叉树创建字符串

### 题目描述

[链接](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)

```
点开链接看吧，没咋读懂题目想说啥
```

### 分析

简单递归

### 实现

```java
// 有点绕
class Solution {
    public String tree2str(TreeNode t) {
        if (t == null) {
            return "";
        }
        if (t.left == null && t.right == null) {
            return "" + t.val;
        }
        if (t.right == null) {
            return "" + t.val + "(" + tree2str(t.left) + ")";
        }

        return "" + t.val + "(" + tree2str(t.left) + ")(" + tree2str(t.right) + ")";
    }
}
```



## 617. 合并二叉树

### 题目描述

[链接](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7

```

### 分析

简单递归即可

### 实现

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) {
            return null;
        }

        if (t1 == null) {
            return t2;
        }
        
        if (t2 == null) {
            return t1;
        }

        // 都不为空
        t1.val += t2.val;
        t1.left = mergeTrees(t1.left, t2.left);
        t1.right = mergeTrees(t1.right, t2.right);
        return t1;
    }

}
```



## 623. 在二叉树中增加一行

### 题目描述

[链接](https://leetcode-cn.com/problems/add-one-row-to-tree/)

```
描述过于复杂，点开链接看吧
```

### 分析

层序遍历即可，找到应该增加的上一层，然后一次加入

### 实现

```java
class Solution {
    public TreeNode addOneRow(TreeNode root, int v, int d) {
        if (d == 1) {
            TreeNode newNode = new TreeNode(v);
            newNode.left = root;
            return newNode;
        }

        Deque<TreeNode> deque = new LinkedList<>();
        deque.offerLast(root);
        int level = 2;
        while (deque.size() > 0) {
            if (level == d) {
                // 找到了前一层，跳出
                break;
            }
            int count = deque.size();
            for (int i = 1; i <= count; i++) {
                TreeNode topOne = deque.pollFirst();
                if (topOne.left != null) {
                    deque.offerLast(topOne.left);
                }
                if (topOne.right != null) {
                    deque.offerLast(topOne.right);
                }
            }
            level += 1;
        }

        // 此时deque不为空，并且保存的是上一层
        while (deque.size() > 0) {
            TreeNode topOne = deque.pollFirst();
            
            // 左边
            TreeNode newNode = new TreeNode(v);
            newNode.left = topOne.left;
            topOne.left = newNode;
            
            // 右边
            newNode = new TreeNode(v);
            newNode.right = topOne.right;
            topOne.right = newNode;

        }
        return root;
    }
}
```



