# 数组

## 11 盛最多水的容器(M)

### 描述

[链接](https://leetcode-cn.com/problems/container-with-most-water)

```
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水

输入：[1,8,6,2,5,4,8,3,7]
输出：49
说明， 下标为1和下标为8的两个数， 对应的面积最大， 为7 * 7 = 49（长度为索引的距离， 高度为两个数的较小值）
```

### 分析

最简单的思路是， 两次循环， 对每两个值都计算其面积， 找到最大的面积。

分析该问题可以得出这样的结论，如果当前下标为`i` 和`j`， 其面积为`area`， 如果`i`的高度大于`j`的高度， 那么此时取决于面积的高就是`j`对应的高度， 因此， 此时吧`i`向右移动， 面积不可能更大。同理， `i`对应的高度更大的时候， 向左移动`j`， 面积不可能更大。此时就可以采用双指针。

如果当前`i`的高度大于`j`对应的高度， 那么此时就把`j`向左移动， 才可能试图找到更大的面积。反之， 移动`i`。

### 实现

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int max = 0;
        while(left < right) {
            int area = Math.min(height[left], height[right]) * (right - left);
            max = Math.max(max, area);

            if(height[left] <= height[right]) {
                left += 1;
            }else {
                right -= 1;
            }
        }
        return max;
    }
}
```





## 15 三数之和为0的集合(M)

### 描述

[题目链接](https://leetcode-cn.com/problems/3sum/)

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。答案中不可以包含重复的三元组。
示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

### 分析

最直接的思路， 三次循环， 判断每次三个数的和是否为`0`。如果要去重， 可以先进行排序， 或者利用`set`集合去重。此种思路， 第一是时间复杂度高， 其次是去重的时候特别麻烦。

采用固定一个数+双指针。当固定一个数的时候， 就可以采用双指针指向另外两个数。采用双指针的前提是数组已经排好序， 因此需要进行排序。排序的另一个好处是， 排序之后， 可以很方便解决去重的问题。

大致思路是：

* 对第一个数进行循环。如果这个数，在之前已经出现过， 直接跳过。因为排好序， 只需比较前一个数即可。如果这个第一个数已经大于0， 后面的肯定大于0， 直接跳过循环。
* 左指针指向第二个数， 右指针指向第三个数。如果三个数之和为0，加入结果集，同时，左指针右移，右指针左移。如果三个数之和大于0，说明和太大， 右指针左移。如果三个数之和小于0， 左指针右移。
* 左右指针仍然需要考虑重复的问题， 和第一个数思路一样， 如果左指针和之前一个数相同，跳过，右指针和之后一个数相同， 跳过。

### 实现

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length < 3) return res; //数组长度小于3， 直接返回
        Arrays.sort(nums); //排序

        for(int i = 0; i <= nums.length - 3; i++) { //循环，固定第一个数为nums[i]
            if(nums[i] > 0) break; //第一个数大于0， 和不可能为0， 直接跳出循环

            if(i > 0 && nums[i] == nums[i - 1]) continue; 
            //数字发生重复， 跳过

            int left = i + 1;
            int right = nums.length - 1;
            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == 0) { //满足条件
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    res.add(list);
                    left += 1; //左指针右移
                    right -= 1; //右指针左移


                    while(left > i + 1 && left < right && nums[left] == nums[left - 1]) {
                        left += 1;
                    }
                    // 第二个数重复， 跳过
                    while(right < nums.length - 1 && right >  left && nums[right] == nums[right + 1]) {
                        right -= 1;
                    }
                    //第三个数重复， 跳过（这两个步骤也可以放到外部进行， 不管sum是否为0都跳过）
                }else if(sum > 0) {
                    right -= 1; //和大于0, 右指针左移
                }else{
                    left += 1; //和小于0, 左指针右移
                }   
            }
        }
        return res;

    }
}
```

### 扩展(四数之和)

思路基本一致， 多一层循环而已。两层循环+ 双指针。

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();

        if(nums.length < 4) return res;
        Arrays.sort(nums);
        
        for(int i = 0; i <= nums.length - 4; i++) {
            int min1 = nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3];
            if(min1 > target) break;
            if(i > 0 && nums[i] == nums[i - 1]) continue;

            //转化为三个数之和
            int subTarget = target - nums[i];
            for(int j = i + 1; j <= nums.length - 3; j++) {
                int min2 = nums[j] + nums[j + 1] + nums[j + 2];
                if(min2 > subTarget) break;
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;

                int left = j + 1;
                int right = nums.length - 1;
                int twoSum = subTarget - nums[j];
                if(nums[left] + nums[left + 1] > twoSum) break;
                while(left < right) {
                    if(left > j + 1 && left < right && nums[left] == nums[left - 1]) {
                        left += 1;
                        continue;
                    }
                    if(right < nums.length - 1 && right > left && nums[right] == nums[right + 1]) {
                        right -= 1;
                        continue;
                    }

                    if(nums[left] + nums[right] == twoSum) {
                        List<Integer> list = new ArrayList<>();
                        list.add(nums[i]);
                        list.add(nums[j]);
                        list.add(nums[left]);
                        list.add(nums[right]);
                        res.add(list);
                        left += 1;
                        right -= 1;
                    } else if(nums[right] + nums[left] > twoSum) {
                        right -= 1;
                    }else {
                        left += 1;
                    }

                }
            }
        }
        return res;

    }
}
```





## 16 最近的三数之和(M）

### 描述

[题目链接](https://leetcode-cn.com/problems/3sum-closest/)

```
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

```

### 分析

思路大体上和15题类似， 排序+双指针。区别点在于本题是求最近， 而不是固定的值。因此在双指针的循环中

* `sum -target > 0` 此时很明显， sum 是大于target的， 要想更靠近， 意味着需要sum 更小，因此right指针左移；同理， sum 小于target的时候， left右移动。
* `sum -target=0`, 此时已经是最近了， 直接返回。

### 实现

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if(nums.length < 3) return -1;
        Arrays.sort(nums);
        int ans = nums[0] + nums[1] + nums[2];   //获得初始的ans
        for(int i = 0; i <= nums.length - 3; i++) {
            if(i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1;
            int right = nums.length - 1;

            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum - target == 0) {
                    return target;
                }
                 if(sum - target > 0) {
                    ans = (sum - target > Math.abs(ans - target) ? ans : sum); //比较是否此时的sum是更优解
                    right -= 1;
                }else {
                    ans = (target - sum > Math.abs(ans - target) ? ans : sum);
                    left += 1;
                }
            }
        }
        return ans;
    }
}
```





 ## 26 删除排序数组的重复项(E)

### 描述

[题目链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例：
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

遍历一遍数组，统计迄今为止发生重复的个数。因为数组本身是排序的，因此如果当前值和前一个值相等，发生重复，重复个数加1， 那么该值应该被舍弃。如果没有重复，应该像前移动到 `i - dupCount`的位置， `dupCount`是迄今为止重复的个数

### 实现

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int dupCount = 0; // 重复的个数
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                // 当前值和前一个值相等，重复个数加1
                dupCount += 1;
                continue;
            }
            // 没有重复的时候，向前移动到  i - duoCount的位置
            nums[i - dupCount] = nums[i];
        }

        return nums.length - dupCount;
    }
}

```



## 27. 原地移除元素

### 题目描述

[链接](https://leetcode-cn.com/problems/remove-element/)

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

这道题和上一道题，思路一致

### 实现

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == val) {
                // 遇到一个,数量加1
                count += 1;
                continue;
            }
            nums[i - count] = nums[i];
        }
        return nums.length - count;
    }
}
```



## 31. 下一个排列(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/next-permutation/)

```
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

输入：nums = [ 1 2 3 4 7 5 3 1]
输出：[1,2,3,5,1,3,4,7]
```

### 分析

要找下一个更大的数字。

首先需要最靠右的较小的值，即例子中的4， 4的后面是逆序的，内部已经不可能再继续增加了，只能将4提升，提升到多少呢，需要提升最小，因此需要找到4的右侧，大于4的最小值。注意4的后面已经是逆序排列了，因此找到5之后，将4和5交换。此时5的后面是逆序的，4已经提升到5了，需要5的后面现在最小，也就是后面变成顺序，反转一下即可

### 实现

```java
class Solution {
    public void nextPermutation(int[] nums) {
        //  1 2 3 4 7 5 3 1

        // 找到一个尽可能靠右的 较小值，即找到从右往左的第一个  值小于下一个值
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i -= 1;
        }
        
        if (i >= 0) {
            // 找到 i的右侧，大于 nums[i]的最小的值，因为需要将nums[i]变大，
            int j = nums.length - 1;
            while (nums[j] <= nums[i]) {
                j -= 1;
            }

            // 找到了对应的两个值
            swap(nums, i, j);
        }

        // 需要将i之后的  已经是 逆序的，换成顺序
        reverse(nums, i + 1, nums.length - 1);
    }


    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start, end);
            start += 1;
            end -= 1;
        }
    }
}
```





## 41. 缺失的第一个正数(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/first-missing-positive/)

```
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

输入: [3,4,-1,1]
输出: 2
```

### 分析

和在0-n中寻找一个重复的元素类似，使用原地映射。

比如`[1,2,3,4,5]`，这种天然的已经是一个萝卜一个坑，每个位置的值和其索引都完全对应，那么下一个就是 `nums.length+1`

如果不是这种标准的，那么需要用一种方式来标识这个索引位置上有其对应的值。

由于负数和大于`nums.length`的值，其实是没有意义的，可能先一次遍历，将这些值设置为`Integer.MAX_VALUE`，或者只要超过`nums.length`的值都可以。

那么经过预处理之后，数组变成`3,4,100,1`

* 然后，比如，数字3， 那么3对应的索引位置是`3-1=2`，那么将索引为2的地方标识一下，已经有萝卜了，因为经过预处理现在都是正数，那么将`nums[2]`这个值变成负数`-100`，来标识他有对应的萝卜了。此时数组变成 `[3,4,-100,1]`
* 然后第二个数， 找到其坑位，是 `4-1=3`，把`nums[3]`变成负数 `[3,4,-100,-1]`
* 然后第三个数， `-100`，本来是100，太大，没有意义，跳过
* 然后第四个数，`-1`，本来是`1`,,找到其坑位 `1-1=0`，将`nums[0]`转化为负数， 变为 `-3,4,-100,-1`

一次遍历之后，结果显而易见，第一个为正数的地方，标识这个坑位没有对应的萝卜，那么结果就是这个位置上本应该的值

### 实现

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] <= 0) {
                nums[i] = nums.length + 1;
            }
        }

        // 原地哈希映射
        for (int i = 0; i < nums.length; i++) {
            int value = Math.abs(nums[i]);
            if (value > nums.length) {
                // 是负数或者超过length的数
                continue;
            }
            // 将 value-1位置的数变成负数
            if (nums[value - 1] > 0) {
                nums[value - 1] = - nums[value - 1];
            }

        }

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                // 这个位置没有被 标识为负数，即这个位置空缺
                return i + 1;
            }
        }

        return nums.length + 1;
    }
}
```





## 42. 接雨水

### 描述

[链接](https://leetcode-cn.com/problems/trapping-rain-water/)

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```



### 分析

方法1： 暴力法，遍历数组，针对每一个元素，向左查找比该元素大的最高柱子， 向右查找比该元素大的最高柱子，然后算出当前索引下的雨水量。求和。

方法2：动态规划。假设每个位置的向左的最大值和向右的最大值已经知道，那么就可以计算了。从左往右遍历，构造一个当前最大的数的数组，一直更新该数组。同理，从右往左遍历，实时更新当前最大的数。最后计算

方法3：双指针：维护一个左指针，一个右指针，并且当前的左边的最大值，和右边的最大值。如果left_max 小于right_max， 那么左指针进行移动，如果该元素，小于left_max，那么求出该柱子上的雨水，如果大于left_max，那么更新left_max。同理，如果当前left_max大于right_max，那么左指针不动，右指针进行移动，最终计算完成。

### 实现

```java
// 方法1, 暴力法
class Solution {
    public int trap(int[] nums) {
        int ans = 0;
        for (int i = 1; i < nums.length - 1; i++) {
            int leftMax = nums[i], rightMax = nums[i];
            for(int j = i - 1; j >= 0; j--) {
                if (nums[j] > leftMax) {
                    leftMax = nums[j];
                }
            }
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] > rightMax) {
                    rightMax = nums[j];
                }
            }
            ans += Math.min(leftMax, rightMax) - nums[i];
        }
        return ans;
    }
}

// 方法2： 动态规划
class Solution {
    public int trap(int[] nums) {
        int length = nums.length;
        if (length == 0) return 0;
        int[] leftMaxArray = new int[length];
        int[] rightMaxArray = new int[length];

        leftMaxArray[0] = nums[0];
        rightMaxArray[length - 1] = nums[length - 1];
        for (int i = 1; i < length; i++) {
            leftMaxArray[i] = Math.max(leftMaxArray[i - 1], nums[i]);
        }
        for (int i = length - 2; i >= 0; i--) {
            rightMaxArray[i] = Math.max(rightMaxArray[i + 1], nums[i]);
        }
        int ans = 0;
        for (int i = 0; i < length; i++) {
            ans += Math.min(leftMaxArray[i], rightMaxArray[i]) - nums[i];
        }
        return ans;
    }
}

// 方法3 双指针
class Solution {
    public int trap(int[] nums) {
        int left = 0;
        int right = nums.length - 1;;
        int leftMax = 0, rightMax = 0;
        int ans = 0;
        while (left < right) {
            if (leftMax <= rightMax) {
                if (nums[left] > leftMax) {
                    leftMax = nums[left];
                    left += 1;
                } else {
                    ans += leftMax - nums[left];
                    left += 1;
                }
            } else {
                if (nums[right] > rightMax) {
                    rightMax = nums[right];
                    right -= 1;
                } else {
                    ans += rightMax - nums[right];
                    right -= 1;
                }
            }
        }
        return ans;
    }
}

```





## 45. 跳跃游戏2(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/jump-game-ii/)

```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

### 分析

求最值问题，一种很直观的思路是动态规划，每个`dp[i]`记录的是到当前位置的最小次数。但是超时了

使用贪心算法。记录当前能够到达的最远的地方，然后从当前位置遍历到最远的地方，一直能够到达更新最远的地方，这次遍历完了之后，次数加1.有点像树的层序遍历，每一次跳跃就对应树的一层

### 实现

```java
class Solution {
    public int jump(int[] nums) {
        if (nums.length == 0 || nums.length == 1) {
            return 0;
        }
        int farest = nums[0];  // 第一个位置开始，能够到达的最远距离就是nums[0]
        int step = 1; 
        int start = 1;// 遍历的位置从1开始
        
        while (farest < nums.length - 1) { // 如果能够到达的最远距离超过了最后一个位置，跳出循环，得到结果
            int end = farest; // 本轮能够到达的最远的地方
            for (int i = start; i <= end; i++) {
                farest = Math.max(farest, i + nums[i]); // 更新最远距离
            }
            // 本轮结束，step加1
            step += 1;
            start = end;// 更新下一轮的起点
        }

        return step;
    }
}
```



## 55. 跳跃游戏(M)

[链接](https://leetcode-cn.com/problems/jump-game/)

```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

### 分析

方法1：动态规划。从右往左，依次找寻当前位置是否能跳转到最后一个位置。最后返回第一个位置是否能

方法2：贪心。方法1，找寻了每个位置是否能到达，其实可以只关心第一个点。遍历数组，维护一个当前位置能够跳转到的最远距离，此时更新最远距离为 此前的最大距离和当前能够跳转的最大距离的更大值。

贪心算法更好

### 实现

```java
// 动态规划
class Solution {
    public boolean canJump(int[] nums) {
        boolean[] yes = new boolean[nums.length];
        yes[nums.length - 1] = true;
        for (int j = nums.length - 1; j >= 0; j--) {
            for (int i = j + 1; i <= j + nums[j] && i < nums.length; i++) {
                if (yes[i]) {
                    yes[j] = true;
                    break;
                }
            }
        }
        return yes[0];
    }
}

// 贪心算法
class Solution {
    public boolean canJump(int[] nums) {
        int rightMost = 0;  // 当前能够到达的最远距离
        for (int i = 0; i < nums.length; i++) {
            if (rightMost < i) return false;  // 连第i个位置都不能跳到，直接返回false
            rightMost = Math.max(rightMost, nums[i] + i);
            if (rightMost >= nums.length - 1) return true;
        }
        return false;
    }
}
```





## 48. 旋转方阵90度(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/rotate-image/)

```
给定一个 n × n 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。
说明：
你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],
原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

### 分析

先转置，再左右对称变换

### 实现

```java
class Solution {
    public void rotate(int[][] nums) {
        if (nums == null) {
            return;
        }
        int m = nums.length;
        int n = nums[0].length;
        // 先转置
        for (int i = 0; i < m; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = nums[i][j];
                nums[i][j] = nums[j][i];
                nums[j][i] = temp;
            }
        }
		
        // 对称变换
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = nums[i][j];
                nums[i][j] = nums[i][n - j - 1];
                nums[i][n - j - 1] = temp;
            }
        }
    }
}
```





## 54. 旋转矩阵(M)

### 描述

[链接](https://leetcode-cn.com/problems/spiral-matrix/)

```
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]

```

### 分析

按照层级输出，每一轮都循环四次。相当于转了个圈子

### 实现

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> ans = new LinkedList<>();
        if (matrix == null || matrix.length == 0) return ans;
        int top = 0,  bottom = matrix.length - 1;
        int left = 0, right = matrix[0].length - 1;

        int total = (right + 1) * (bottom + 1);
        while (total > 0) {
          // 注意每次循环加的限制条件  total > 0， 如果是方阵，刚好四个循环之后，total为0， 如果是普通矩阵，会有问题，所以每个循环都要加该限制条件
            for (int i = left; i <= right && total > 0; i++) {
                ans.add(matrix[top][i]);
                total -= 1;
            }
            top += 1;

            for (int i = top; i <= bottom && total > 0; i++) {
                ans.add(matrix[i][right]);
                total -= 1;
            }
            right -= 1;

            for (int i = right; i >= left && total > 0; i--) {
                ans.add(matrix[bottom][i]);
                total -= 1;
            }
            bottom -= 1;

            for (int i = bottom; i >= top && total > 0; i--) {
                ans.add(matrix[i][left]);
                total -= 1;
            }
            left += 1;
        }
        return ans;
    }
}
```





## 59. 旋转矩阵2(M)

### 描述

[链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

```
给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]

```

### 分析

和上一道题原理一样， 只是换种形式

### 实现

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int count = 1; 
        int left = 0, right = n - 1, top = 0, bottom = n - 1;
        int[][] matrix = new int[n][n];
        while (count <= n * n) {
          // 这道题一定是方阵， 因此可以不用加额外的限制条件
            for (int i = left; i <= right; i++) {
                matrix[top][i] = count;
                count += 1;
            }
            top += 1;

            for (int i = top; i <= bottom; i++) {
                matrix[i][right] = count;
                count += 1;
            }
            right -= 1;

            for (int i = right; i >= left; i--) {
                matrix[bottom][i] = count;
                count += 1;
            }
            bottom -= 1;

            for (int i = bottom; i >= top; i--) {
                matrix[i][left] = count;
                count += 1;
            }
            left += 1;
        }
        return matrix;
    }
}
```





## 80. 删除排序数组中的重复项2

### 描述

[链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

```
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

给定 nums = [1,1,1,2,2,3],
函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

一种很自然的思路是，如果遇到重复的数字，则将后面的数整体向前移动一个，复杂度为 o(n^2)

采用双指针，i是遍历的数字，j是当前移动的位置，如果当前数字重复，则j不变，如果当前位置不重复，则移动数字到j，并把j+1。具体看代码。

### 实现

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int count = 1, j = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                count += 1;
            } else {
                count = 1;
            }
            if (count <= 2) {
                nums[j] = nums[i];
                j += 1;
            } else {
                
            }
        }
        return j;
    }
}
```



## 88. 合并两个有序数组

### 描述

[链接](https://leetcode-cn.com/problems/merge-sorted-array/)

```
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
 
说明:
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]

```

### 分析

一种很自然的方式就是重新构造一个数组，然后采用双指针进行插入。

但是更节省空间的方式，是**从后往前**进行遍历，这样就可以直接利用`nums1`这个数组

### 实现

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m - 1, index2 = n - 1;
        int index3 = m + n -1;
        while (index1 >= 0 && index2 >= 0) {
            if (nums1[index1] > nums2[index2]) {
                nums1[index3] = nums1[index1];
                index1 -= 1;
                index3 -= 1;
            } else {
                nums1[index3] = nums2[index2];
                index2 -= 1;
                index3 -= 1;
            }
        }

        while (index1 >= 0) {
            nums1[index3] = nums1[index1];
            index1 -= 1;
            index3 -= 1;
        }

        while (index2 >= 0) {
            nums1[index3] = nums2[index2];
            index2 -= 1;
            index3 -= 1;
        }

    }
}
```



## 167. 两数之和2-输入有序数组

### 描述

```
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

```

### 分析

一种思路是，固定一个数，另一个数用二分法寻找

另一种思路是左右指针，如果二者之和满足条件，返回，如果大于，右指针左移，否则左指针右移

### 实现

```java
/**
  双指针
**/
class Solution {
   public static int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        
        while (left < right) {
            if (numbers[left] + numbers[right] == target) return new int[]{left + 1, right + 1};
            
            if (numbers[left] + numbers[right] > target) {
                right -= 1;
            } else {
                left += 1;
            }
        }
        return null;
	}
}

/**
	二分法
**/

class Solution {
   public static int[] twoSum(int[] numbers, int target) {
        for (int i = 0; i < numbers.length; i++) {
            int left = i + 1; 
            int right = numbers.length - 1;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (numbers[mid] + numbers[i] == target) return new int[]{i + 1, mid + 1};
                if (numbers[mid] > target - numbers[i]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }
        return null;
	}
}
```

