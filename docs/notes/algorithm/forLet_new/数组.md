# 数组

## 11 盛最多水的容器(M)

### 描述

[链接](https://leetcode-cn.com/problems/container-with-most-water)

```
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水

输入：[1,8,6,2,5,4,8,3,7]
输出：49
说明， 下标为1和下标为8的两个数， 对应的面积最大， 为7 * 7 = 49（长度为索引的距离， 高度为两个数的较小值）
```

### 分析

最简单的思路是， 两次循环， 对每两个值都计算其面积， 找到最大的面积。

分析该问题可以得出这样的结论，如果当前下标为`i` 和`j`， 其面积为`area`， 如果`i`的高度大于`j`的高度， 那么此时取决于面积的高就是`j`对应的高度， 因此， 此时吧`i`向右移动， 面积不可能更大。同理， `i`对应的高度更大的时候， 向左移动`j`， 面积不可能更大。此时就可以采用双指针。

如果当前`i`的高度大于`j`对应的高度， 那么此时就把`j`向左移动， 才可能试图找到更大的面积。反之， 移动`i`。

### 实现

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int max = 0;
        while(left < right) {
            int area = Math.min(height[left], height[right]) * (right - left);
            max = Math.max(max, area);

            if(height[left] <= height[right]) {
                left += 1;
            }else {
                right -= 1;
            }
        }
        return max;
    }
}
```





## 15 三数之和为0的集合(M)

### 描述

[题目链接](https://leetcode-cn.com/problems/3sum/)

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。答案中不可以包含重复的三元组。
示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

### 分析

最直接的思路， 三次循环， 判断每次三个数的和是否为`0`。如果要去重， 可以先进行排序， 或者利用`set`集合去重。此种思路， 第一是时间复杂度高， 其次是去重的时候特别麻烦。

采用固定一个数+双指针。当固定一个数的时候， 就可以采用双指针指向另外两个数。采用双指针的前提是数组已经排好序， 因此需要进行排序。排序的另一个好处是， 排序之后， 可以很方便解决去重的问题。

大致思路是：

* 对第一个数进行循环。如果这个数，在之前已经出现过， 直接跳过。因为排好序， 只需比较前一个数即可。如果这个第一个数已经大于0， 后面的肯定大于0， 直接跳过循环。
* 左指针指向第二个数， 右指针指向第三个数。如果三个数之和为0，加入结果集，同时，左指针右移，右指针左移。如果三个数之和大于0，说明和太大， 右指针左移。如果三个数之和小于0， 左指针右移。
* 左右指针仍然需要考虑重复的问题， 和第一个数思路一样， 如果左指针和之前一个数相同，跳过，右指针和之后一个数相同， 跳过。

### 实现

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length < 3) return res; //数组长度小于3， 直接返回
        Arrays.sort(nums); //排序

        for(int i = 0; i <= nums.length - 3; i++) { //循环，固定第一个数为nums[i]
            if(nums[i] > 0) break; //第一个数大于0， 和不可能为0， 直接跳出循环

            if(i > 0 && nums[i] == nums[i - 1]) continue; 
            //数字发生重复， 跳过

            int left = i + 1;
            int right = nums.length - 1;
            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == 0) { //满足条件
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    res.add(list);
                    left += 1; //左指针右移
                    right -= 1; //右指针左移


                    while(left > i + 1 && left < right && nums[left] == nums[left - 1]) {
                        left += 1;
                    }
                    // 第二个数重复， 跳过
                    while(right < nums.length - 1 && right >  left && nums[right] == nums[right + 1]) {
                        right -= 1;
                    }
                    //第三个数重复， 跳过（这两个步骤也可以放到外部进行， 不管sum是否为0都跳过）
                }else if(sum > 0) {
                    right -= 1; //和大于0, 右指针左移
                }else{
                    left += 1; //和小于0, 左指针右移
                }   
            }
        }
        return res;

    }
}
```

### 扩展(四数之和)

思路基本一致， 多一层循环而已。两层循环+ 双指针。

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();

        if(nums.length < 4) return res;
        Arrays.sort(nums);
        
        for(int i = 0; i <= nums.length - 4; i++) {
            int min1 = nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3];
            if(min1 > target) break;
            if(i > 0 && nums[i] == nums[i - 1]) continue;

            //转化为三个数之和
            int subTarget = target - nums[i];
            for(int j = i + 1; j <= nums.length - 3; j++) {
                int min2 = nums[j] + nums[j + 1] + nums[j + 2];
                if(min2 > subTarget) break;
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;

                int left = j + 1;
                int right = nums.length - 1;
                int twoSum = subTarget - nums[j];
                if(nums[left] + nums[left + 1] > twoSum) break;
                while(left < right) {
                    if(left > j + 1 && left < right && nums[left] == nums[left - 1]) {
                        left += 1;
                        continue;
                    }
                    if(right < nums.length - 1 && right > left && nums[right] == nums[right + 1]) {
                        right -= 1;
                        continue;
                    }

                    if(nums[left] + nums[right] == twoSum) {
                        List<Integer> list = new ArrayList<>();
                        list.add(nums[i]);
                        list.add(nums[j]);
                        list.add(nums[left]);
                        list.add(nums[right]);
                        res.add(list);
                        left += 1;
                        right -= 1;
                    } else if(nums[right] + nums[left] > twoSum) {
                        right -= 1;
                    }else {
                        left += 1;
                    }

                }
            }
        }
        return res;

    }
}
```





## 16 最近的三数之和(M）

### 描述

[题目链接](https://leetcode-cn.com/problems/3sum-closest/)

```
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

```

### 分析

思路大体上和15题类似， 排序+双指针。区别点在于本题是求最近， 而不是固定的值。因此在双指针的循环中

* `sum -target > 0` 此时很明显， sum 是大于target的， 要想更靠近， 意味着需要sum 更小，因此right指针左移；同理， sum 小于target的时候， left右移动。
* `sum -target=0`, 此时已经是最近了， 直接返回。

### 实现

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if(nums.length < 3) return -1;
        Arrays.sort(nums);
        int ans = nums[0] + nums[1] + nums[2];   //获得初始的ans
        for(int i = 0; i <= nums.length - 3; i++) {
            if(i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1;
            int right = nums.length - 1;

            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum - target == 0) {
                    return target;
                }
                 if(sum - target > 0) {
                    ans = (sum - target > Math.abs(ans - target) ? ans : sum); //比较是否此时的sum是更优解
                    right -= 1;
                }else {
                    ans = (target - sum > Math.abs(ans - target) ? ans : sum);
                    left += 1;
                }
            }
        }
        return ans;
    }
}
```





 ## 26 删除排序数组的重复项(E)

### 描述

[题目链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例：
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

遍历一遍数组，统计迄今为止发生重复的个数。因为数组本身是排序的，因此如果当前值和前一个值相等，发生重复，重复个数加1， 那么该值应该被舍弃。如果没有重复，应该像前移动到 `i - dupCount`的位置， `dupCount`是迄今为止重复的个数

### 实现

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int dupCount = 0; // 重复的个数
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                // 当前值和前一个值相等，重复个数加1
                dupCount += 1;
                continue;
            }
            // 没有重复的时候，向前移动到  i - duoCount的位置
            nums[i - dupCount] = nums[i];
        }

        return nums.length - dupCount;
    }
}

```



## 27. 原地移除元素

### 题目描述

[链接](https://leetcode-cn.com/problems/remove-element/)

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

这道题和上一道题，思路一致

### 实现

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == val) {
                // 遇到一个,数量加1
                count += 1;
                continue;
            }
            nums[i - count] = nums[i];
        }
        return nums.length - count;
    }
}
```



## 31. 下一个排列(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/next-permutation/)

```
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

输入：nums = [ 1 2 3 4 7 5 3 1]
输出：[1,2,3,5,1,3,4,7]
```

### 分析

要找下一个更大的数字。

首先需要最靠右的较小的值，即例子中的4， 4的后面是逆序的，内部已经不可能再继续增加了，只能将4提升，提升到多少呢，需要提升最小，因此需要找到4的右侧，大于4的最小值。注意4的后面已经是逆序排列了，因此找到5之后，将4和5交换。此时5的后面是逆序的，4已经提升到5了，需要5的后面现在最小，也就是后面变成顺序，反转一下即可

### 实现

```java
class Solution {
    public void nextPermutation(int[] nums) {
        //  1 2 3 4 7 5 3 1

        // 找到一个尽可能靠右的 较小值，即找到从右往左的第一个  值小于下一个值
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i -= 1;
        }
        
        if (i >= 0) {
            // 找到 i的右侧，大于 nums[i]的最小的值，因为需要将nums[i]变大，
            int j = nums.length - 1;
            while (nums[j] <= nums[i]) {
                j -= 1;
            }

            // 找到了对应的两个值
            swap(nums, i, j);
        }

        // 需要将i之后的  已经是 逆序的，换成顺序
        reverse(nums, i + 1, nums.length - 1);
    }


    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start, end);
            start += 1;
            end -= 1;
        }
    }
}
```





## 41. 缺失的第一个正数(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/first-missing-positive/)

```
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

输入: [3,4,-1,1]
输出: 2
```

### 分析

和在0-n中寻找一个重复的元素类似，使用原地映射。

比如`[1,2,3,4,5]`，这种天然的已经是一个萝卜一个坑，每个位置的值和其索引都完全对应，那么下一个就是 `nums.length+1`

如果不是这种标准的，那么需要用一种方式来标识这个索引位置上有其对应的值。

由于负数和大于`nums.length`的值，其实是没有意义的，可能先一次遍历，将这些值设置为`Integer.MAX_VALUE`，或者只要超过`nums.length`的值都可以。

那么经过预处理之后，数组变成`3,4,100,1`

* 然后，比如，数字3， 那么3对应的索引位置是`3-1=2`，那么将索引为2的地方标识一下，已经有萝卜了，因为经过预处理现在都是正数，那么将`nums[2]`这个值变成负数`-100`，来标识他有对应的萝卜了。此时数组变成 `[3,4,-100,1]`
* 然后第二个数， 找到其坑位，是 `4-1=3`，把`nums[3]`变成负数 `[3,4,-100,-1]`
* 然后第三个数， `-100`，本来是100，太大，没有意义，跳过
* 然后第四个数，`-1`，本来是`1`,,找到其坑位 `1-1=0`，将`nums[0]`转化为负数， 变为 `-3,4,-100,-1`

一次遍历之后，结果显而易见，第一个为正数的地方，标识这个坑位没有对应的萝卜，那么结果就是这个位置上本应该的值

### 实现

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] <= 0) {
                nums[i] = nums.length + 1;
            }
        }

        // 原地哈希映射
        for (int i = 0; i < nums.length; i++) {
            int value = Math.abs(nums[i]);
            if (value > nums.length) {
                // 是负数或者超过length的数
                continue;
            }
            // 将 value-1位置的数变成负数
            if (nums[value - 1] > 0) {
                nums[value - 1] = - nums[value - 1];
            }

        }

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                // 这个位置没有被 标识为负数，即这个位置空缺
                return i + 1;
            }
        }

        return nums.length + 1;
    }
}
```





## 42. 接雨水

### 描述

[链接](https://leetcode-cn.com/problems/trapping-rain-water/)

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```



### 分析

方法1： 暴力法，遍历数组，针对每一个元素，向左查找比该元素大的最高柱子， 向右查找比该元素大的最高柱子，然后算出当前索引下的雨水量。求和。

方法2：动态规划。假设每个位置的向左的最大值和向右的最大值已经知道，那么就可以计算了。从左往右遍历，构造一个当前最大的数的数组，一直更新该数组。同理，从右往左遍历，实时更新当前最大的数。最后计算

方法3：双指针：维护一个左指针，一个右指针，并且当前的左边的最大值，和右边的最大值。如果left_max 小于right_max， 那么左指针进行移动，如果该元素，小于left_max，那么求出该柱子上的雨水，如果大于left_max，那么更新left_max。同理，如果当前left_max大于right_max，那么左指针不动，右指针进行移动，最终计算完成。

### 实现

```java
// 方法1, 暴力法
class Solution {
    public int trap(int[] nums) {
        int ans = 0;
        for (int i = 1; i < nums.length - 1; i++) {
            int leftMax = nums[i], rightMax = nums[i];
            for(int j = i - 1; j >= 0; j--) {
                if (nums[j] > leftMax) {
                    leftMax = nums[j];
                }
            }
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] > rightMax) {
                    rightMax = nums[j];
                }
            }
            ans += Math.min(leftMax, rightMax) - nums[i];
        }
        return ans;
    }
}

// 方法2： 动态规划
class Solution {
    public int trap(int[] nums) {
        int length = nums.length;
        if (length == 0) return 0;
        int[] leftMaxArray = new int[length];
        int[] rightMaxArray = new int[length];

        leftMaxArray[0] = nums[0];
        rightMaxArray[length - 1] = nums[length - 1];
        for (int i = 1; i < length; i++) {
            leftMaxArray[i] = Math.max(leftMaxArray[i - 1], nums[i]);
        }
        for (int i = length - 2; i >= 0; i--) {
            rightMaxArray[i] = Math.max(rightMaxArray[i + 1], nums[i]);
        }
        int ans = 0;
        for (int i = 0; i < length; i++) {
            ans += Math.min(leftMaxArray[i], rightMaxArray[i]) - nums[i];
        }
        return ans;
    }
}

// 方法3 双指针
class Solution {
    public int trap(int[] nums) {
        int left = 0;
        int right = nums.length - 1;;
        int leftMax = 0, rightMax = 0;
        int ans = 0;
        while (left < right) {
            if (leftMax <= rightMax) {
                if (nums[left] > leftMax) {
                    leftMax = nums[left];
                    left += 1;
                } else {
                    ans += leftMax - nums[left];
                    left += 1;
                }
            } else {
                if (nums[right] > rightMax) {
                    rightMax = nums[right];
                    right -= 1;
                } else {
                    ans += rightMax - nums[right];
                    right -= 1;
                }
            }
        }
        return ans;
    }
}

```





## 45. 跳跃游戏2(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/jump-game-ii/)

```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

### 分析

求最值问题，一种很直观的思路是动态规划，每个`dp[i]`记录的是到当前位置的最小次数。但是超时了

使用贪心算法。记录当前能够到达的最远的地方，然后从当前位置遍历到最远的地方，一直能够到达更新最远的地方，这次遍历完了之后，次数加1.有点像树的层序遍历，每一次跳跃就对应树的一层

### 实现

```java
class Solution {
    public int jump(int[] nums) {
        if (nums.length == 0 || nums.length == 1) {
            return 0;
        }
        int farest = nums[0];  // 第一个位置开始，能够到达的最远距离就是nums[0]
        int step = 1; 
        int start = 1;// 遍历的位置从1开始
        
        while (farest < nums.length - 1) { // 如果能够到达的最远距离超过了最后一个位置，跳出循环，得到结果
            int end = farest; // 本轮能够到达的最远的地方
            for (int i = start; i <= end; i++) {
                farest = Math.max(farest, i + nums[i]); // 更新最远距离
            }
            // 本轮结束，step加1
            step += 1;
            start = end;// 更新下一轮的起点
        }

        return step;
    }
}
```



## 55. 跳跃游戏(M)

[链接](https://leetcode-cn.com/problems/jump-game/)

```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

### 分析

方法1：动态规划。从右往左，依次找寻当前位置是否能跳转到最后一个位置。最后返回第一个位置是否能

方法2：贪心。方法1，找寻了每个位置是否能到达，其实可以只关心第一个点。遍历数组，维护一个当前位置能够跳转到的最远距离，此时更新最远距离为 此前的最大距离和当前能够跳转的最大距离的更大值。

贪心算法更好

### 实现

```java
// 动态规划
class Solution {
    public boolean canJump(int[] nums) {
        boolean[] yes = new boolean[nums.length];
        yes[nums.length - 1] = true;
        for (int j = nums.length - 1; j >= 0; j--) {
            for (int i = j + 1; i <= j + nums[j] && i < nums.length; i++) {
                if (yes[i]) {
                    yes[j] = true;
                    break;
                }
            }
        }
        return yes[0];
    }
}

// 贪心算法
class Solution {
    public boolean canJump(int[] nums) {
        int rightMost = 0;  // 当前能够到达的最远距离
        for (int i = 0; i < nums.length; i++) {
            if (rightMost < i) return false;  // 连第i个位置都不能跳到，直接返回false
            rightMost = Math.max(rightMost, nums[i] + i);
            if (rightMost >= nums.length - 1) return true;
        }
        return false;
    }
}
```





## 48. 旋转方阵90度(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/rotate-image/)

```
给定一个 n × n 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。
说明：
你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],
原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

### 分析

先转置，再左右对称变换

### 实现

```java
class Solution {
    public void rotate(int[][] nums) {
        if (nums == null) {
            return;
        }
        int m = nums.length;
        int n = nums[0].length;
        // 先转置
        for (int i = 0; i < m; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = nums[i][j];
                nums[i][j] = nums[j][i];
                nums[j][i] = temp;
            }
        }
		
        // 对称变换
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = nums[i][j];
                nums[i][j] = nums[i][n - j - 1];
                nums[i][n - j - 1] = temp;
            }
        }
    }
}
```





## 54. 旋转矩阵(M)

### 描述

[链接](https://leetcode-cn.com/problems/spiral-matrix/)

```
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]

```

### 分析

按照层级输出，每一轮都循环四次。相当于转了个圈子

### 实现

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> ans = new LinkedList<>();
        if (matrix == null || matrix.length == 0) return ans;
        int top = 0,  bottom = matrix.length - 1;
        int left = 0, right = matrix[0].length - 1;

        int total = (right + 1) * (bottom + 1);
        while (total > 0) {
          // 注意每次循环加的限制条件  total > 0， 如果是方阵，刚好四个循环之后，total为0， 如果是普通矩阵，会有问题，所以每个循环都要加该限制条件
            for (int i = left; i <= right && total > 0; i++) {
                ans.add(matrix[top][i]);
                total -= 1;
            }
            top += 1;

            for (int i = top; i <= bottom && total > 0; i++) {
                ans.add(matrix[i][right]);
                total -= 1;
            }
            right -= 1;

            for (int i = right; i >= left && total > 0; i--) {
                ans.add(matrix[bottom][i]);
                total -= 1;
            }
            bottom -= 1;

            for (int i = bottom; i >= top && total > 0; i--) {
                ans.add(matrix[i][left]);
                total -= 1;
            }
            left += 1;
        }
        return ans;
    }
}
```





## 59. 旋转矩阵2(M)

### 描述

[链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

```
给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]

```

### 分析

和上一道题原理一样， 只是换种形式

### 实现

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int count = 1; 
        int left = 0, right = n - 1, top = 0, bottom = n - 1;
        int[][] matrix = new int[n][n];
        while (count <= n * n) {
          // 这道题一定是方阵， 因此可以不用加额外的限制条件
            for (int i = left; i <= right; i++) {
                matrix[top][i] = count;
                count += 1;
            }
            top += 1;

            for (int i = top; i <= bottom; i++) {
                matrix[i][right] = count;
                count += 1;
            }
            right -= 1;

            for (int i = right; i >= left; i--) {
                matrix[bottom][i] = count;
                count += 1;
            }
            bottom -= 1;

            for (int i = bottom; i >= top; i--) {
                matrix[i][left] = count;
                count += 1;
            }
            left += 1;
        }
        return matrix;
    }
}
```





## 66.数组加1(E)

### 题目描述

[链接](https://leetcode-cn.com/problems/plus-one/)

```
给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。

输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

### 分析

如果最后一位不为9，直接加1返回即可。如果需要进位，则从后往前遍历，一直加下去。

如果遍历结束，还需要进位，则整个数组需要扩充一个，并且只有全是9，比如99999这种数才会需要扩充

### 实现

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int extra = 1;
        for (int i = digits.length - 1; i >= 0; i--) {
            int sum = (digits[i] + extra);
            digits[i] = sum % 10;
            extra = sum / 10;
            if (extra == 0) {
                // 不用继续了，已经得到结果了
                return digits;
            }
        }

        // 是否需要扩充数组
        if (extra == 0) {
            return digits;
        } else {
            int[] ans = new int[digits.length + 1];
            ans[0] = 1;
            return ans;
        }
    }
}
```





## 73. 矩阵置零(M)

### 描述

[链接](https://leetcode-cn.com/problems/set-matrix-zeroes/)

```
给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。(原地算法即空间复杂度为o(1))
输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

```

### 分析

空间复杂度要求为常数。使用第一行和第一列来标识该行该列是否需要置为0.。 遍历整个矩阵，如果`matrix[i][j = 0`, 那么将该行的第一个元素和该列的第一个元素设为0。最后，再次遍历矩阵，如果发现该行的第一个为0.则该行都设为0， 同理，发现该列的头元素为0，该列都设为0.

但是需要注意的是，由于第一行和第一列，可能会一直变化，所以需要先判断第一行和第一列本身是否需要置为0.

### 实现

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean firstRow = false, firstCol = false;

      // 判断第一列是否需要整体置为0
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstCol = true;
                break;
            }
        }
      // 判断第一行整体是否需要置为0
        for (int i = 0; i < n; i++) {
            if (matrix[0][i] == 0) {
                firstRow = true;
                break;
            }
        }

      // 寻找哪些行哪些列需要整体置为0， 用头元素标识
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }

      // 替换除了第一行和第一列的其他行、列
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

      // 第一行需要置换
        if (firstRow == true) {
            for (int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }
      // 第一列需要置换
        if (firstCol == true) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```





## 74. 搜索二维矩阵(M)

### 描述

[链接](https://leetcode-cn.com/problems/search-a-2d-matrix/)

```java
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。     // 剑指offer中类似题目，没有这个限制条件

输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true

```

### 分析

如果没有第二个限制条件，则可以设置一个baseline， 从左下角开始，如果大于target，则往右走，如果小于target，则往上走。

如果有第二个限制条件，整个矩阵展开来，扁平化之后，就是一个完全排序的数组。可以使用二分法。

或者先二分找到在哪个行，锁定行之后，然后再次二分即可



### 实现

```java
/**
	二分
*/
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }

        int m = matrix.length - 1;
        int n = matrix[0].length - 1;

        // 先找到对应的行
        int left = 0, right = m;
        while (left < right) {
            int mid = right - (right - left) / 2;
            if (matrix[mid][0] > target) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }

        // 现在对应的行是left
        int row = left;
        left = 0;
        right = n;
        // 锁定行之后，在列上二分，继续寻找
        while (left <= right) {
            int mid = right - (right - left) / 2;
            if (matrix[row][mid] == target) {
                return true;
            } else if (matrix[row][mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        return false;
        
    }
}


// 通用的解法
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) return false;
        int m = matrix.length, n = matrix[0].length;
        int row = m - 1, col = 0;
        while (row >= 0 && col < n) {
            int base = matrix[row][col];
            if (base == target) return true;
            if (target > base) {
                col += 1;
            }else {
                row -= 1;
            }
        }
        return false;
    }
}
```





## 75. 颜色分类(荷兰国旗问题)(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/sort-colors/)

```
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

你可以不使用代码库中的排序函数来解决这道题吗？
你能想出一个仅使用常数空间的一趟扫描算法吗？

输入：nums = [2,0,2,1,1,1]
输出：[0,0,1,1,2,2]
```

### 分析

类似于一趟快排的思路，需要一趟之后，分成三个区间，第一个区间是小于1，也就是0，第二个区间是等于1，第三个大于1，也就是2。

设0的区间是`[0,redIndex]`， 2的区间是`[blueIndex, len-1]`

* `i=0`，是2，和`blueIndex`置换，`blueIndex-1`，此时变成`[1,0,2,1,1,2]`
* `i仍然为0，`是1， 和`redIndex`置换，`redIndex+1,index+1`,,此时还是`[1,0,2,1,1,2]`
* ......

### 实现

```java
class Solution {
    public void sortColors(int[] nums) {
        int redIndex = 0;
        int blueIndex = nums.length - 1;
        int index = 0;

        while (index <= blueIndex) {
            if (nums[index] == 0) {
                // 需要往前放
                swap(nums, redIndex, index);
                redIndex += 1;
                index += 1; // 这里需要 index 也加1，因为换回来的一定是1，所以需要加1
            } else if (nums[index] == 2) {
                swap(nums, blueIndex, index);
                blueIndex -= 1;
                // 这里不需要index+1， 因为可能换回去的是0
            } else {
                // 是1，不用管
                index += 1;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```





## 80. 删除排序数组中的重复项2(M)

### 描述

[链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

```
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

给定 nums = [1,1,1,2,2,3],
函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

一种很自然的思路是，如果遇到重复的数字，则将后面的数整体向前移动一个，复杂度为 o(n^2)

采用双指针，i是遍历的数字，j是当前移动的位置，如果当前数字重复，则j不变，如果当前位置不重复，则移动数字到j，并把j+1。具体看代码。

### 实现

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int count = 1, j = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                count += 1;
            } else {
                count = 1;
            }
            if (count <= 2) {
                nums[j] = nums[i];
                j += 1;
            } else {
                
            }
        }
        return j;
    }
}
```



## 88. 合并两个有序数组(M)

### 描述

[链接](https://leetcode-cn.com/problems/merge-sorted-array/)

```
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
 
说明:
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]

```

### 分析

一种很自然的方式就是重新构造一个数组，然后采用双指针进行插入。

但是更节省空间的方式，是**从后往前**进行遍历，这样就可以直接利用`nums1`这个数组

### 实现

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m - 1, index2 = n - 1;
        int index3 = m + n -1;
        while (index1 >= 0 && index2 >= 0) {
            if (nums1[index1] > nums2[index2]) {
                nums1[index3] = nums1[index1];
                index1 -= 1;
                index3 -= 1;
            } else {
                nums1[index3] = nums2[index2];
                index2 -= 1;
                index3 -= 1;
            }
        }

        while (index1 >= 0) {
            nums1[index3] = nums1[index1];
            index1 -= 1;
            index3 -= 1;
        }

        while (index2 >= 0) {
            nums1[index3] = nums2[index2];
            index2 -= 1;
            index3 -= 1;
        }

    }
}
```





## 122. 买卖股票的最佳时机2(E)

### 题目描述

[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

输入: [7,1,5,3,6,8]
输出: 9
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 6 天（股票价格 = 8）的时候卖出, 这笔交易所能获得利润 = 8-3 = 5 。
```

### 分析

因为次数不受限制，因此什么时候买，什么时候卖不受限制。因此有：

* 7的时候不能买，因为`1小于7`,如果在7买，1卖出去，不如不买。如果7买，1的时候不卖，还不如在1买
* 1的时候买，5的时候卖出去，收益4
* 3的时候买，8的时候卖出去，收益5.可以发现这个等价于，3的时候买，6的时候卖出去，然后6的时候买，8的时候卖(虽然这个不能这么操作)

上述过程是一个贪心的算法，只要后面一个数字大于前一个数字，就可以等价的这么卖卖

### 实现

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) {
                ans += prices[i] - prices[i - 1];
            }
        }
        return ans;
    }
}
```





## 128. 最长连续序列(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

```
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
你可以设计并实现时间复杂度为 O(n) 的解决方案吗？

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

### 分析

时间复杂度要求为 `o(n)`，那么一定要使用空间，使用set来保存元素。

在set中遍历一次，比如遍历到1， 寻找是否存在2，是否存在3.....。

那么在遍历1的时候，会寻找2，那么为了保证不重复遍历2， 比如2在前面，如何不寻找2，发现 (2-1)在set中，因此不寻找2开始的最长的长度。

### 实现

```java
class Solution {
    public int longestConsecutive(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        int ans = 0;
        
        for (int num : set) {

            if (set.contains(num - 1)) {
                // 存在比num小1的，跳过，因为该元素不会是最长序列的第一个值
                continue;
            }

            int count = 1;
            while (set.contains(num + 1)) {
                count += 1;
                num = num + 1;
            }

            ans = Math.max(ans, count);
        }
        return ans;
    }
}
```





## 167. 两数之和2-输入有序数组

### 描述

```
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

```

### 分析

一种思路是，固定一个数，另一个数用二分法寻找

另一种思路是左右指针，如果二者之和满足条件，返回，如果大于，右指针左移，否则左指针右移

### 实现

```java
/**
  双指针
**/
class Solution {
   public static int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        
        while (left < right) {
            if (numbers[left] + numbers[right] == target) return new int[]{left + 1, right + 1};
            
            if (numbers[left] + numbers[right] > target) {
                right -= 1;
            } else {
                left += 1;
            }
        }
        return null;
	}
}

/**
	二分法
**/

class Solution {
   public static int[] twoSum(int[] numbers, int target) {
        for (int i = 0; i < numbers.length; i++) {
            int left = i + 1; 
            int right = numbers.length - 1;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (numbers[mid] + numbers[i] == target) return new int[]{i + 1, mid + 1};
                if (numbers[mid] > target - numbers[i]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }
        return null;
	}
}
```





## 134. 加油站(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/gas-station/)

```
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

```

### 分析

一种直观的思路是，先确定起点在哪，然后一直走下去，看是是否存在一个正确的。

如果只能一次遍历，那么思路是。试图从最开始走，然后如果在某个地方走不通了，那说明，在这个之前的任何地方作为起点，都是走不通的，那么直接跳过这些作为起点。

### 实现

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;

        int startIndex = 0; // 尝试从起点出发

        while (startIndex < len) {

            if (gas[startIndex] < cost[startIndex]) {
                // 这不能作为起点，都不够到下一程的
                startIndex += 1;
                continue;
            }

            int avail = gas[startIndex] - cost[startIndex];  // 剩下的油
            int i = startIndex + 1;
            int count = 1;

            while (count < len) {
                // 还没走完全程

                avail = avail + gas[i % len] - cost[i % len];  // 跑完i剩下的油
                if (avail < 0) {
                    // 上一轮剩下的不够了，重新设置起点,因为startIndex开始是有剩余的，如果startIndex开始都不能到达重点
                    // 那么 startIndex 到 i中间这些，如果作为起点，那一定也不能到达终点
                    startIndex = i;
                    break;
                } else {
                    // 还能接着跑
                    i += 1;
                    count += 1;
                }
            }

            if (count == len) {
                // 已经跑完了
                return startIndex;
            }
        }

        return -1;


    }
}
```





## 135. 分发糖果(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/candy/)

```
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

输入：[1,2,2]
输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

### 分析

* 当前值比上一个评分高，那么需要比上一个多一个糖果。
* 当前值如果和上一个一样，那么这个人直接给她1个
* 如果当前值比上一个小，首先这个人只给1个，需要将这个人之前的下降序列的值都增加一个糖果

### 实现

```java
class Solution {
    public int candy(int[] ratings) {

        int ans = 1;
        int pre = 1;

        int decLen = 0;
        int incLen = 1; // 上一个递增序列的最后一个同学的糖果个数

        for (int i = 1; i < ratings.length; i++) {

            if (ratings[i] > ratings[i - 1]) {
                // 比上一个评分高，必须比他得到更多的
                ans += pre + 1;  // 比上一个同学多一个
                pre += 1;  // 更新pre
                decLen = 0; // 因为是上升中，下降序列长度为0
                incLen = pre; // 上升中，最后一个同学就是当前同学， incLen = pre
            } else if (ratings[i] == ratings[i - 1]) {
                // 和上一个评分一样，直接给他最少的，1个
                ans += 1; // 给他一个
                pre = 1;
                decLen = 0;
                incLen = 1; //递增的最后一个同学就是当前同学
            } else {
                // 比上一个下降了，先给他1个，然后把之前下降序列的每一个都加1个
                decLen += 1; // 下降序列长度+1
                if (incLen == decLen) {
                    // 如果二者相等，则增序列的最后一个和下降序列的第一个(是同一个值),也需要多一个糖，否则可能出现下降序列的第1个同学和第2个同学糖果一样的情况
                    decLen += 1;
                }
                ans += decLen; // 给这个下降序列的每一个同学加1个
                pre = 1; // 当前同学只有1个
            }
        }
        return ans;
    }
}
```

