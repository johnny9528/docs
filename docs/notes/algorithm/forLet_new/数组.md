# 数组

## 11 盛最多水的容器(M)

### 描述

[链接](https://leetcode-cn.com/problems/container-with-most-water)

```
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水

输入：[1,8,6,2,5,4,8,3,7]
输出：49
说明， 下标为1和下标为8的两个数， 对应的面积最大， 为7 * 7 = 49（长度为索引的距离， 高度为两个数的较小值）
```

### 分析

最简单的思路是， 两次循环， 对每两个值都计算其面积， 找到最大的面积。

分析该问题可以得出这样的结论，如果当前下标为`i` 和`j`， 其面积为`area`， 如果`i`的高度大于`j`的高度， 那么此时取决于面积的高就是`j`对应的高度， 因此， 此时吧`i`向右移动， 面积不可能更大。同理， `i`对应的高度更大的时候， 向左移动`j`， 面积不可能更大。此时就可以采用双指针。

如果当前`i`的高度大于`j`对应的高度， 那么此时就把`j`向左移动， 才可能试图找到更大的面积。反之， 移动`i`。

### 实现

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int max = 0;
        while(left < right) {
            int area = Math.min(height[left], height[right]) * (right - left);
            max = Math.max(max, area);

            if(height[left] <= height[right]) {
                left += 1;
            }else {
                right -= 1;
            }
        }
        return max;
    }
}
```





## 15 三数之和为0的集合(M)

### 描述

[题目链接](https://leetcode-cn.com/problems/3sum/)

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。答案中不可以包含重复的三元组。
示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

### 分析

最直接的思路， 三次循环， 判断每次三个数的和是否为`0`。如果要去重， 可以先进行排序， 或者利用`set`集合去重。此种思路， 第一是时间复杂度高， 其次是去重的时候特别麻烦。

采用固定一个数+双指针。当固定一个数的时候， 就可以采用双指针指向另外两个数。采用双指针的前提是数组已经排好序， 因此需要进行排序。排序的另一个好处是， 排序之后， 可以很方便解决去重的问题。

大致思路是：

* 对第一个数进行循环。如果这个数，在之前已经出现过， 直接跳过。因为排好序， 只需比较前一个数即可。如果这个第一个数已经大于0， 后面的肯定大于0， 直接跳过循环。
* 左指针指向第二个数， 右指针指向第三个数。如果三个数之和为0，加入结果集，同时，左指针右移，右指针左移。如果三个数之和大于0，说明和太大， 右指针左移。如果三个数之和小于0， 左指针右移。
* 左右指针仍然需要考虑重复的问题， 和第一个数思路一样， 如果左指针和之前一个数相同，跳过，右指针和之后一个数相同， 跳过。

### 实现

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length < 3) return res; //数组长度小于3， 直接返回
        Arrays.sort(nums); //排序

        for(int i = 0; i <= nums.length - 3; i++) { //循环，固定第一个数为nums[i]
            if(nums[i] > 0) break; //第一个数大于0， 和不可能为0， 直接跳出循环

            if(i > 0 && nums[i] == nums[i - 1]) continue; 
            //数字发生重复， 跳过

            int left = i + 1;
            int right = nums.length - 1;
            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == 0) { //满足条件
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[left]);
                    list.add(nums[right]);
                    res.add(list);
                    left += 1; //左指针右移
                    right -= 1; //右指针左移


                    while(left > i + 1 && left < right && nums[left] == nums[left - 1]) {
                        left += 1;
                    }
                    // 第二个数重复， 跳过
                    while(right < nums.length - 1 && right >  left && nums[right] == nums[right + 1]) {
                        right -= 1;
                    }
                    //第三个数重复， 跳过（这两个步骤也可以放到外部进行， 不管sum是否为0都跳过）
                }else if(sum > 0) {
                    right -= 1; //和大于0, 右指针左移
                }else{
                    left += 1; //和小于0, 左指针右移
                }   
            }
        }
        return res;

    }
}
```

### 扩展(四数之和)

思路基本一致， 多一层循环而已。两层循环+ 双指针。

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();

        if(nums.length < 4) return res;
        Arrays.sort(nums);
        
        for(int i = 0; i <= nums.length - 4; i++) {
            int min1 = nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3];
            if(min1 > target) break;
            if(i > 0 && nums[i] == nums[i - 1]) continue;

            //转化为三个数之和
            int subTarget = target - nums[i];
            for(int j = i + 1; j <= nums.length - 3; j++) {
                int min2 = nums[j] + nums[j + 1] + nums[j + 2];
                if(min2 > subTarget) break;
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;

                int left = j + 1;
                int right = nums.length - 1;
                int twoSum = subTarget - nums[j];
                if(nums[left] + nums[left + 1] > twoSum) break;
                while(left < right) {
                    if(left > j + 1 && left < right && nums[left] == nums[left - 1]) {
                        left += 1;
                        continue;
                    }
                    if(right < nums.length - 1 && right > left && nums[right] == nums[right + 1]) {
                        right -= 1;
                        continue;
                    }

                    if(nums[left] + nums[right] == twoSum) {
                        List<Integer> list = new ArrayList<>();
                        list.add(nums[i]);
                        list.add(nums[j]);
                        list.add(nums[left]);
                        list.add(nums[right]);
                        res.add(list);
                        left += 1;
                        right -= 1;
                    } else if(nums[right] + nums[left] > twoSum) {
                        right -= 1;
                    }else {
                        left += 1;
                    }

                }
            }
        }
        return res;

    }
}
```





## 16 最近的三数之和(M）

### 描述

[题目链接](https://leetcode-cn.com/problems/3sum-closest/)

```
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

```

### 分析

思路大体上和15题类似， 排序+双指针。区别点在于本题是求最近， 而不是固定的值。因此在双指针的循环中

* `sum -target > 0` 此时很明显， sum 是大于target的， 要想更靠近， 意味着需要sum 更小，因此right指针左移；同理， sum 小于target的时候， left右移动。
* `sum -target=0`, 此时已经是最近了， 直接返回。

### 实现

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if(nums.length < 3) return -1;
        Arrays.sort(nums);
        int ans = nums[0] + nums[1] + nums[2];   //获得初始的ans
        for(int i = 0; i <= nums.length - 3; i++) {
            if(i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1;
            int right = nums.length - 1;

            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum - target == 0) {
                    return target;
                }
                 if(sum - target > 0) {
                    ans = (sum - target > Math.abs(ans - target) ? ans : sum); //比较是否此时的sum是更优解
                    right -= 1;
                }else {
                    ans = (target - sum > Math.abs(ans - target) ? ans : sum);
                    left += 1;
                }
            }
        }
        return ans;
    }
}
```





 ## 26 删除排序数组的重复项(E)

### 描述

[题目链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例：
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

遍历一遍数组，统计迄今为止发生重复的个数。因为数组本身是排序的，因此如果当前值和前一个值相等，发生重复，重复个数加1， 那么该值应该被舍弃。如果没有重复，应该像前移动到 `i - dupCount`的位置， `dupCount`是迄今为止重复的个数

### 实现

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int dupCount = 0; // 重复的个数
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                // 当前值和前一个值相等，重复个数加1
                dupCount += 1;
                continue;
            }
            // 没有重复的时候，向前移动到  i - duoCount的位置
            nums[i - dupCount] = nums[i];
        }

        return nums.length - dupCount;
    }
}

```



## 27. 原地移除元素

### 题目描述

[链接](https://leetcode-cn.com/problems/remove-element/)

```
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

这道题和上一道题，思路一致

### 实现

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == val) {
                // 遇到一个,数量加1
                count += 1;
                continue;
            }
            nums[i - count] = nums[i];
        }
        return nums.length - count;
    }
}
```



## 31. 下一个排列(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/next-permutation/)

```
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

输入：nums = [ 1 2 3 4 7 5 3 1]
输出：[1,2,3,5,1,3,4,7]
```

### 分析

要找下一个更大的数字。

首先需要最靠右的较小的值，即例子中的4， 4的后面是逆序的，内部已经不可能再继续增加了，只能将4提升，提升到多少呢，需要提升最小，因此需要找到4的右侧，大于4的最小值。注意4的后面已经是逆序排列了，因此找到5之后，将4和5交换。此时5的后面是逆序的，4已经提升到5了，需要5的后面现在最小，也就是后面变成顺序，反转一下即可

### 实现

```java
class Solution {
    public void nextPermutation(int[] nums) {
        //  1 2 3 4 7 5 3 1

        // 找到一个尽可能靠右的 较小值，即找到从右往左的第一个  值小于下一个值
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i -= 1;
        }
        
        if (i >= 0) {
            // 找到 i的右侧，大于 nums[i]的最小的值，因为需要将nums[i]变大，
            int j = nums.length - 1;
            while (nums[j] <= nums[i]) {
                j -= 1;
            }

            // 找到了对应的两个值
            swap(nums, i, j);
        }

        // 需要将i之后的  已经是 逆序的，换成顺序
        reverse(nums, i + 1, nums.length - 1);
    }


    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start, end);
            start += 1;
            end -= 1;
        }
    }
}
```





## 41. 缺失的第一个正数(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/first-missing-positive/)

```
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。

输入: [3,4,-1,1]
输出: 2
```

### 分析

和在0-n中寻找一个重复的元素类似，使用原地映射。

比如`[1,2,3,4,5]`，这种天然的已经是一个萝卜一个坑，每个位置的值和其索引都完全对应，那么下一个就是 `nums.length+1`

如果不是这种标准的，那么需要用一种方式来标识这个索引位置上有其对应的值。

由于负数和大于`nums.length`的值，其实是没有意义的，可能先一次遍历，将这些值设置为`Integer.MAX_VALUE`，或者只要超过`nums.length`的值都可以。

那么经过预处理之后，数组变成`3,4,100,1`

* 然后，比如，数字3， 那么3对应的索引位置是`3-1=2`，那么将索引为2的地方标识一下，已经有萝卜了，因为经过预处理现在都是正数，那么将`nums[2]`这个值变成负数`-100`，来标识他有对应的萝卜了。此时数组变成 `[3,4,-100,1]`
* 然后第二个数， 找到其坑位，是 `4-1=3`，把`nums[3]`变成负数 `[3,4,-100,-1]`
* 然后第三个数， `-100`，本来是100，太大，没有意义，跳过
* 然后第四个数，`-1`，本来是`1`,,找到其坑位 `1-1=0`，将`nums[0]`转化为负数， 变为 `-3,4,-100,-1`

一次遍历之后，结果显而易见，第一个为正数的地方，标识这个坑位没有对应的萝卜，那么结果就是这个位置上本应该的值

### 实现

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] <= 0) {
                nums[i] = nums.length + 1;
            }
        }

        // 原地哈希映射
        for (int i = 0; i < nums.length; i++) {
            int value = Math.abs(nums[i]);
            if (value > nums.length) {
                // 是负数或者超过length的数
                continue;
            }
            // 将 value-1位置的数变成负数
            if (nums[value - 1] > 0) {
                nums[value - 1] = - nums[value - 1];
            }

        }

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                // 这个位置没有被 标识为负数，即这个位置空缺
                return i + 1;
            }
        }

        return nums.length + 1;
    }
}
```





## 42. 接雨水

### 描述

[链接](https://leetcode-cn.com/problems/trapping-rain-water/)

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```



### 分析

方法1： 暴力法，遍历数组，针对每一个元素，向左查找比该元素大的最高柱子， 向右查找比该元素大的最高柱子，然后算出当前索引下的雨水量。求和。

方法2：动态规划。假设每个位置的向左的最大值和向右的最大值已经知道，那么就可以计算了。从左往右遍历，构造一个当前最大的数的数组，一直更新该数组。同理，从右往左遍历，实时更新当前最大的数。最后计算

方法3：双指针：维护一个左指针，一个右指针，并且当前的左边的最大值，和右边的最大值。如果left_max 小于right_max， 那么左指针进行移动，如果该元素，小于left_max，那么求出该柱子上的雨水，如果大于left_max，那么更新left_max。同理，如果当前left_max大于right_max，那么左指针不动，右指针进行移动，最终计算完成。

### 实现

```java
// 方法1, 暴力法
class Solution {
    public int trap(int[] nums) {
        int ans = 0;
        for (int i = 1; i < nums.length - 1; i++) {
            int leftMax = nums[i], rightMax = nums[i];
            for(int j = i - 1; j >= 0; j--) {
                if (nums[j] > leftMax) {
                    leftMax = nums[j];
                }
            }
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] > rightMax) {
                    rightMax = nums[j];
                }
            }
            ans += Math.min(leftMax, rightMax) - nums[i];
        }
        return ans;
    }
}

// 方法2： 动态规划
class Solution {
    public int trap(int[] nums) {
        int length = nums.length;
        if (length == 0) return 0;
        int[] leftMaxArray = new int[length];
        int[] rightMaxArray = new int[length];

        leftMaxArray[0] = nums[0];
        rightMaxArray[length - 1] = nums[length - 1];
        for (int i = 1; i < length; i++) {
            leftMaxArray[i] = Math.max(leftMaxArray[i - 1], nums[i]);
        }
        for (int i = length - 2; i >= 0; i--) {
            rightMaxArray[i] = Math.max(rightMaxArray[i + 1], nums[i]);
        }
        int ans = 0;
        for (int i = 0; i < length; i++) {
            ans += Math.min(leftMaxArray[i], rightMaxArray[i]) - nums[i];
        }
        return ans;
    }
}

// 方法3 双指针
class Solution {
    public int trap(int[] nums) {
        int left = 0;
        int right = nums.length - 1;;
        int leftMax = 0, rightMax = 0;
        int ans = 0;
        while (left < right) {
            if (leftMax <= rightMax) {
                if (nums[left] > leftMax) {
                    leftMax = nums[left];
                    left += 1;
                } else {
                    ans += leftMax - nums[left];
                    left += 1;
                }
            } else {
                if (nums[right] > rightMax) {
                    rightMax = nums[right];
                    right -= 1;
                } else {
                    ans += rightMax - nums[right];
                    right -= 1;
                }
            }
        }
        return ans;
    }
}

```





## 45. 跳跃游戏2(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/jump-game-ii/)

```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

### 分析

求最值问题，一种很直观的思路是动态规划，每个`dp[i]`记录的是到当前位置的最小次数。但是超时了

使用贪心算法。记录当前能够到达的最远的地方，然后从当前位置遍历到最远的地方，一直能够到达更新最远的地方，这次遍历完了之后，次数加1.有点像树的层序遍历，每一次跳跃就对应树的一层

### 实现

```java
class Solution {
    public int jump(int[] nums) {
        if (nums.length == 0 || nums.length == 1) {
            return 0;
        }
        int farest = nums[0];  // 第一个位置开始，能够到达的最远距离就是nums[0]
        int step = 1; 
        int start = 1;// 遍历的位置从1开始
        
        while (farest < nums.length - 1) { // 如果能够到达的最远距离超过了最后一个位置，跳出循环，得到结果
            int end = farest; // 本轮能够到达的最远的地方
            for (int i = start; i <= end; i++) {
                farest = Math.max(farest, i + nums[i]); // 更新最远距离
            }
            // 本轮结束，step加1
            step += 1;
            start = end;// 更新下一轮的起点
        }

        return step;
    }
}
```



## 55. 跳跃游戏(M)

[链接](https://leetcode-cn.com/problems/jump-game/)

```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

### 分析

方法1：动态规划。从右往左，依次找寻当前位置是否能跳转到最后一个位置。最后返回第一个位置是否能

方法2：贪心。方法1，找寻了每个位置是否能到达，其实可以只关心第一个点。遍历数组，维护一个当前位置能够跳转到的最远距离，此时更新最远距离为 此前的最大距离和当前能够跳转的最大距离的更大值。

贪心算法更好

### 实现

```java
// 动态规划
class Solution {
    public boolean canJump(int[] nums) {
        boolean[] yes = new boolean[nums.length];
        yes[nums.length - 1] = true;
        for (int j = nums.length - 1; j >= 0; j--) {
            for (int i = j + 1; i <= j + nums[j] && i < nums.length; i++) {
                if (yes[i]) {
                    yes[j] = true;
                    break;
                }
            }
        }
        return yes[0];
    }
}

// 贪心算法
class Solution {
    public boolean canJump(int[] nums) {
        int rightMost = 0;  // 当前能够到达的最远距离
        for (int i = 0; i < nums.length; i++) {
            if (rightMost < i) return false;  // 连第i个位置都不能跳到，直接返回false
            rightMost = Math.max(rightMost, nums[i] + i);
            if (rightMost >= nums.length - 1) return true;
        }
        return false;
    }
}
```





## 48. 旋转方阵90度(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/rotate-image/)

```
给定一个 n × n 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。
说明：
你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],
原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

### 分析

先转置，再左右对称变换

### 实现

```java
class Solution {
    public void rotate(int[][] nums) {
        if (nums == null) {
            return;
        }
        int m = nums.length;
        int n = nums[0].length;
        // 先转置
        for (int i = 0; i < m; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = nums[i][j];
                nums[i][j] = nums[j][i];
                nums[j][i] = temp;
            }
        }
		
        // 对称变换
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = nums[i][j];
                nums[i][j] = nums[i][n - j - 1];
                nums[i][n - j - 1] = temp;
            }
        }
    }
}
```





## 54. 旋转矩阵(M)

### 描述

[链接](https://leetcode-cn.com/problems/spiral-matrix/)

```
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]

```

### 分析

按照层级输出，每一轮都循环四次。相当于转了个圈子

### 实现

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> ans = new LinkedList<>();
        if (matrix == null || matrix.length == 0) return ans;
        int top = 0,  bottom = matrix.length - 1;
        int left = 0, right = matrix[0].length - 1;

        int total = (right + 1) * (bottom + 1);
        while (total > 0) {
          // 注意每次循环加的限制条件  total > 0， 如果是方阵，刚好四个循环之后，total为0， 如果是普通矩阵，会有问题，所以每个循环都要加该限制条件
            for (int i = left; i <= right && total > 0; i++) {
                ans.add(matrix[top][i]);
                total -= 1;
            }
            top += 1;

            for (int i = top; i <= bottom && total > 0; i++) {
                ans.add(matrix[i][right]);
                total -= 1;
            }
            right -= 1;

            for (int i = right; i >= left && total > 0; i--) {
                ans.add(matrix[bottom][i]);
                total -= 1;
            }
            bottom -= 1;

            for (int i = bottom; i >= top && total > 0; i--) {
                ans.add(matrix[i][left]);
                total -= 1;
            }
            left += 1;
        }
        return ans;
    }
}
```





## 59. 旋转矩阵2(M)

### 描述

[链接](https://leetcode-cn.com/problems/spiral-matrix-ii/)

```
给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]

```

### 分析

和上一道题原理一样， 只是换种形式

### 实现

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int count = 1; 
        int left = 0, right = n - 1, top = 0, bottom = n - 1;
        int[][] matrix = new int[n][n];
        while (count <= n * n) {
          // 这道题一定是方阵， 因此可以不用加额外的限制条件
            for (int i = left; i <= right; i++) {
                matrix[top][i] = count;
                count += 1;
            }
            top += 1;

            for (int i = top; i <= bottom; i++) {
                matrix[i][right] = count;
                count += 1;
            }
            right -= 1;

            for (int i = right; i >= left; i--) {
                matrix[bottom][i] = count;
                count += 1;
            }
            bottom -= 1;

            for (int i = bottom; i >= top; i--) {
                matrix[i][left] = count;
                count += 1;
            }
            left += 1;
        }
        return matrix;
    }
}
```





## 66.数组加1(E)

### 题目描述

[链接](https://leetcode-cn.com/problems/plus-one/)

```
给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。

输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

### 分析

如果最后一位不为9，直接加1返回即可。如果需要进位，则从后往前遍历，一直加下去。

如果遍历结束，还需要进位，则整个数组需要扩充一个，并且只有全是9，比如99999这种数才会需要扩充

### 实现

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int extra = 1;
        for (int i = digits.length - 1; i >= 0; i--) {
            int sum = (digits[i] + extra);
            digits[i] = sum % 10;
            extra = sum / 10;
            if (extra == 0) {
                // 不用继续了，已经得到结果了
                return digits;
            }
        }

        // 是否需要扩充数组
        if (extra == 0) {
            return digits;
        } else {
            int[] ans = new int[digits.length + 1];
            ans[0] = 1;
            return ans;
        }
    }
}
```





## 73. 矩阵置零(M)

### 描述

[链接](https://leetcode-cn.com/problems/set-matrix-zeroes/)

```
给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。(原地算法即空间复杂度为o(1))
输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

```

### 分析

空间复杂度要求为常数。使用第一行和第一列来标识该行该列是否需要置为0.。 遍历整个矩阵，如果`matrix[i][j = 0`, 那么将该行的第一个元素和该列的第一个元素设为0。最后，再次遍历矩阵，如果发现该行的第一个为0.则该行都设为0， 同理，发现该列的头元素为0，该列都设为0.

但是需要注意的是，由于第一行和第一列，可能会一直变化，所以需要先判断第一行和第一列本身是否需要置为0.

### 实现

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean firstRow = false, firstCol = false;

      // 判断第一列是否需要整体置为0
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstCol = true;
                break;
            }
        }
      // 判断第一行整体是否需要置为0
        for (int i = 0; i < n; i++) {
            if (matrix[0][i] == 0) {
                firstRow = true;
                break;
            }
        }

      // 寻找哪些行哪些列需要整体置为0， 用头元素标识
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }

      // 替换除了第一行和第一列的其他行、列
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

      // 第一行需要置换
        if (firstRow == true) {
            for (int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }
      // 第一列需要置换
        if (firstCol == true) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```





## 74. 搜索二维矩阵(M)

### 描述

[链接](https://leetcode-cn.com/problems/search-a-2d-matrix/)

```java
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。     // 剑指offer中类似题目，没有这个限制条件

输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true

```

### 分析

如果没有第二个限制条件，则可以设置一个baseline， 从左下角开始，如果大于target，则往右走，如果小于target，则往上走。

如果有第二个限制条件，整个矩阵展开来，扁平化之后，就是一个完全排序的数组。可以使用二分法。

或者先二分找到在哪个行，锁定行之后，然后再次二分即可



### 实现

```java
/**
	二分
*/
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }

        int m = matrix.length - 1;
        int n = matrix[0].length - 1;

        // 先找到对应的行
        int left = 0, right = m;
        while (left < right) {
            int mid = right - (right - left) / 2;
            if (matrix[mid][0] > target) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }

        // 现在对应的行是left
        int row = left;
        left = 0;
        right = n;
        // 锁定行之后，在列上二分，继续寻找
        while (left <= right) {
            int mid = right - (right - left) / 2;
            if (matrix[row][mid] == target) {
                return true;
            } else if (matrix[row][mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        return false;
        
    }
}


// 通用的解法
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) return false;
        int m = matrix.length, n = matrix[0].length;
        int row = m - 1, col = 0;
        while (row >= 0 && col < n) {
            int base = matrix[row][col];
            if (base == target) return true;
            if (target > base) {
                col += 1;
            }else {
                row -= 1;
            }
        }
        return false;
    }
}
```





## 75. 颜色分类(荷兰国旗问题)(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/sort-colors/)

```
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

你可以不使用代码库中的排序函数来解决这道题吗？
你能想出一个仅使用常数空间的一趟扫描算法吗？

输入：nums = [2,0,2,1,1,1]
输出：[0,0,1,1,2,2]
```

### 分析

类似于一趟快排的思路，需要一趟之后，分成三个区间，第一个区间是小于1，也就是0，第二个区间是等于1，第三个大于1，也就是2。

设0的区间是`[0,redIndex]`， 2的区间是`[blueIndex, len-1]`

* `i=0`，是2，和`blueIndex`置换，`blueIndex-1`，此时变成`[1,0,2,1,1,2]`
* `i仍然为0，`是1， 和`redIndex`置换，`redIndex+1,index+1`,,此时还是`[1,0,2,1,1,2]`
* ......

### 实现

```java
class Solution {
    public void sortColors(int[] nums) {
        int redIndex = 0;
        int blueIndex = nums.length - 1;
        int index = 0;

        while (index <= blueIndex) {
            if (nums[index] == 0) {
                // 需要往前放
                swap(nums, redIndex, index);
                redIndex += 1;
                index += 1; // 这里需要 index 也加1，因为换回来的一定是1，所以需要加1
            } else if (nums[index] == 2) {
                swap(nums, blueIndex, index);
                blueIndex -= 1;
                // 这里不需要index+1， 因为可能换回去的是0
            } else {
                // 是1，不用管
                index += 1;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```





## 80. 删除排序数组中的重复项2(M)

### 描述

[链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

```
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

给定 nums = [1,1,1,2,2,3],
函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。
你不需要考虑数组中超出新长度后面的元素。
```

### 分析

一种很自然的思路是，如果遇到重复的数字，则将后面的数整体向前移动一个，复杂度为 o(n^2)

采用双指针，i是遍历的数字，j是当前移动的位置，如果当前数字重复，则j不变，如果当前位置不重复，则移动数字到j，并把j+1。具体看代码。

### 实现

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int count = 1, j = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                count += 1;
            } else {
                count = 1;
            }
            if (count <= 2) {
                nums[j] = nums[i];
                j += 1;
            } else {
                
            }
        }
        return j;
    }
}
```



## 88. 合并两个有序数组(M)

### 描述

[链接](https://leetcode-cn.com/problems/merge-sorted-array/)

```
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
 
说明:
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]

```

### 分析

一种很自然的方式就是重新构造一个数组，然后采用双指针进行插入。

但是更节省空间的方式，是**从后往前**进行遍历，这样就可以直接利用`nums1`这个数组

### 实现

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m - 1, index2 = n - 1;
        int index3 = m + n -1;
        while (index1 >= 0 && index2 >= 0) {
            if (nums1[index1] > nums2[index2]) {
                nums1[index3] = nums1[index1];
                index1 -= 1;
                index3 -= 1;
            } else {
                nums1[index3] = nums2[index2];
                index2 -= 1;
                index3 -= 1;
            }
        }

        while (index1 >= 0) {
            nums1[index3] = nums1[index1];
            index1 -= 1;
            index3 -= 1;
        }

        while (index2 >= 0) {
            nums1[index3] = nums2[index2];
            index2 -= 1;
            index3 -= 1;
        }

    }
}
```





## 122. 买卖股票的最佳时机2(E)

### 题目描述

[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

输入: [7,1,5,3,6,8]
输出: 9
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 6 天（股票价格 = 8）的时候卖出, 这笔交易所能获得利润 = 8-3 = 5 。
```

### 分析

因为次数不受限制，因此什么时候买，什么时候卖不受限制。因此有：

* 7的时候不能买，因为`1小于7`,如果在7买，1卖出去，不如不买。如果7买，1的时候不卖，还不如在1买
* 1的时候买，5的时候卖出去，收益4
* 3的时候买，8的时候卖出去，收益5.可以发现这个等价于，3的时候买，6的时候卖出去，然后6的时候买，8的时候卖(虽然这个不能这么操作)

上述过程是一个贪心的算法，只要后面一个数字大于前一个数字，就可以等价的这么卖卖

### 实现

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) {
                ans += prices[i] - prices[i - 1];
            }
        }
        return ans;
    }
}
```





## 128. 最长连续序列(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

```
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
你可以设计并实现时间复杂度为 O(n) 的解决方案吗？

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

### 分析

时间复杂度要求为 `o(n)`，那么一定要使用空间，使用set来保存元素。

在set中遍历一次，比如遍历到1， 寻找是否存在2，是否存在3.....。

那么在遍历1的时候，会寻找2，那么为了保证不重复遍历2， 比如2在前面，如何不寻找2，发现 (2-1)在set中，因此不寻找2开始的最长的长度。

### 实现

```java
class Solution {
    public int longestConsecutive(int[] nums) {

        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        int ans = 0;
        
        for (int num : set) {

            if (set.contains(num - 1)) {
                // 存在比num小1的，跳过，因为该元素不会是最长序列的第一个值
                continue;
            }

            int count = 1;
            while (set.contains(num + 1)) {
                count += 1;
                num = num + 1;
            }

            ans = Math.max(ans, count);
        }
        return ans;
    }
}
```





## 134. 加油站(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/gas-station/)

```
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

```

### 分析

一种直观的思路是，先确定起点在哪，然后一直走下去，看是是否存在一个正确的。

如果只能一次遍历，那么思路是。试图从最开始走，然后如果在某个地方走不通了，那说明，在这个之前的任何地方作为起点，都是走不通的，那么直接跳过这些作为起点。

### 实现

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;

        int startIndex = 0; // 尝试从起点出发

        while (startIndex < len) {

            if (gas[startIndex] < cost[startIndex]) {
                // 这不能作为起点，都不够到下一程的
                startIndex += 1;
                continue;
            }

            int avail = gas[startIndex] - cost[startIndex];  // 剩下的油
            int i = startIndex + 1;
            int count = 1;

            while (count < len) {
                // 还没走完全程

                avail = avail + gas[i % len] - cost[i % len];  // 跑完i剩下的油
                if (avail < 0) {
                    // 上一轮剩下的不够了，重新设置起点,因为startIndex开始是有剩余的，如果startIndex开始都不能到达重点
                    // 那么 startIndex 到 i中间这些，如果作为起点，那一定也不能到达终点
                    startIndex = i;
                    break;
                } else {
                    // 还能接着跑
                    i += 1;
                    count += 1;
                }
            }

            if (count == len) {
                // 已经跑完了
                return startIndex;
            }
        }

        return -1;


    }
}
```





## 135. 分发糖果(H)

### 题目描述

[链接](https://leetcode-cn.com/problems/candy/)

```
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

输入：[1,2,2]
输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

### 分析

* 当前值比上一个评分高，那么需要比上一个多一个糖果。
* 当前值如果和上一个一样，那么这个人直接给她1个
* 如果当前值比上一个小，首先这个人只给1个，需要将这个人之前的下降序列的值都增加一个糖果

### 实现

```java
class Solution {
    public int candy(int[] ratings) {

        int ans = 1;
        int pre = 1;

        int decLen = 0;
        int incLen = 1; // 上一个递增序列的最后一个同学的糖果个数

        for (int i = 1; i < ratings.length; i++) {

            if (ratings[i] > ratings[i - 1]) {
                // 比上一个评分高，必须比他得到更多的
                ans += pre + 1;  // 比上一个同学多一个
                pre += 1;  // 更新pre
                decLen = 0; // 因为是上升中，下降序列长度为0
                incLen = pre; // 上升中，最后一个同学就是当前同学， incLen = pre
            } else if (ratings[i] == ratings[i - 1]) {
                // 和上一个评分一样，直接给他最少的，1个
                ans += 1; // 给他一个
                pre = 1;
                decLen = 0;
                incLen = 1; //递增的最后一个同学就是当前同学
            } else {
                // 比上一个下降了，先给他1个，然后把之前下降序列的每一个都加1个
                decLen += 1; // 下降序列长度+1
                if (incLen == decLen) {
                    // 如果二者相等，则增序列的最后一个和下降序列的第一个(是同一个值),也需要多一个糖，否则可能出现下降序列的第1个同学和第2个同学糖果一样的情况
                    decLen += 1;
                }
                ans += decLen; // 给这个下降序列的每一个同学加1个
                pre = 1; // 当前同学只有1个
            }
        }
        return ans;
    }
}
```







## 167. 两数之和2-输入有序数组

### 描述

```
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

```

### 分析

一种思路是，固定一个数，另一个数用二分法寻找

另一种思路是左右指针，如果二者之和满足条件，返回，如果大于，右指针左移，否则左指针右移

### 实现

```java
/**
  双指针
**/
class Solution {
   public static int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        
        while (left < right) {
            if (numbers[left] + numbers[right] == target) return new int[]{left + 1, right + 1};
            
            if (numbers[left] + numbers[right] > target) {
                right -= 1;
            } else {
                left += 1;
            }
        }
        return null;
	}
}

/**
	二分法
**/

class Solution {
   public static int[] twoSum(int[] numbers, int target) {
        for (int i = 0; i < numbers.length; i++) {
            int left = i + 1; 
            int right = numbers.length - 1;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (numbers[mid] + numbers[i] == target) return new int[]{i + 1, mid + 1};
                if (numbers[mid] > target - numbers[i]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }
        return null;
	}
}
```





## 189. 数组整体向右移动k个单位(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/rotate-array/)

```
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

```

### 分析

思路1：使用一个额外的数组，然后移动到对应的位置上即可。

思路2，每次向右移动1次，然后重复这个过程k次

上面两种思路都很简单，但是第一种使用额外空间，第二种复杂度太高。

思路3：模拟这个过程，比如第一个元素，直接向右移动k个，然后接着移动刚才这个元素，如果遇到了环，则跳出这一次。然后将下一个作为起始值，继续重复这个过程。当移动的总次数和数组长度相等的时候，就退出整个的循环。

思路4：将数组整体反转，然后分别将前k个反转，以及后面的反转。

### 实现

```java
/**
	思路2，每次移动一个，总体循环k次
*/
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        if (len == 0 || len == 1) {
            return;
        }

        k = k % len;
        for (int i = 1; i <= k; i++) {
            int last = nums[len - 1];  // 最后一个元素
            for (int j = len - 1; j >= 1; j--) {
                nums[j] = nums[j - 1];
            }
            nums[0] = last; // 第一个位置放置最后一个元素
        }
    }
}

/**
	思路3，模拟，每次移动k个，直到有环或者移动完成
*/
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;

        if (len == 0 || len == 1) {
            return;
        }

        k = k % len;
        
        int count = 0;
        int startIndex = 0;
        while (count < len) { // 还没有移动完

            int prev = nums[startIndex];
            int current = startIndex;

            do {
                int nextIndex = (current + k) % len; // 下一个
                int temp = nums[nextIndex];
                nums[nextIndex] = prev; 
                prev = temp; // 更新前一个值
                current = nextIndex;
                count += 1;  // 移动的总个数 加 1
            } while (current != startIndex); // 结束条件是遇到了环，即current等于最开始的startIndex

            // 遇到环了，这一轮移动完成，继续下一轮
            startIndex += 1;
        }
    }
}

/**
	思路4，三次反转
*/
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;

        if (len == 0 || len == 1) {
            return;
        }

        k = k % len;

        reverse(nums, 0, len - 1);  // 整体一次反转
        reverse(nums, 0, k - 1); // 前 k个反转
        reverse(nums, k, len - 1);  // 后面反转
    }

    private void reverse(int[] nums, int left, int right) {
        while (left < right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left += 1;
            right -= 1;
        }
    }
}
```





## 209. 和为s的长度最小的子数组(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

### 分析

最直观的思路是两层循环遍历。

因为是正整数数字，那么前缀和一定是递增的，利用前缀和，然后锁定left, 进行二分查找大于 s的范围

另一种思路是，使用滑动窗口，如果小于s，则右滑动，否则，左滑动

### 实现

```java
/**
	思路1， 滑动窗口
*/
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int left = 0;
        int right = 0;
        int ans = Integer.MAX_VALUE;
        int sum = 0;
        while (right < nums.length) {
            sum += nums[right];  // 往右滑动

            while (sum >= s) {
                // 左窗口滑动，直到不满足条件
                ans = Math.min(ans, right - left + 1);
                sum = sum - nums[left];
                left += 1;
            }
            right += 1;
        }

        return ans == Integer.MAX_VALUE ? 0 : ans;

    }

}

/**
	思路2， 前缀和
*/
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int[] preSum = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            preSum[i + 1] = preSum[i] + nums[i];
        }

        int ans = Integer.MAX_VALUE;

        // 前缀和是递增的，使用二分法查找
        for (int i = 1; i < preSum.length; i++) {
            int left = i;
            int right = preSum.length - 1;

            int target = preSum[i - 1] + s; // 目标值，必须要比他大才行，这里是 preSum[i -1]，需要注意

            while (left <= right) {
                int mid = (left + right) / 2;

                if (preSum[mid] >= target) {
                    // 还能继续缩小
                    ans = Math.min(ans, mid - i + 1);  // 满足条件，更新 ans
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }

}
```





## 219. 是否存在重复元素2(E)

### 题目描述

[链接](https://leetcode-cn.com/problems/contains-duplicate-ii/)

```
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。

输入: nums = [1,2,3,1], k = 3
输出: true
```

### 分析

由于限定了`i、j`索引的差值最多是`k`， 很明显，使用一个窗口，来维护这个关系，是否重复，则使用`set`即可

### 实现

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {

        Set<Integer> window = new HashSet<>();

        int left = 0;
        int right = 0;
        while (right < nums.length) {
            if (window.contains(nums[right])) {
                // 满足条件
                return true;
            }

            window.add(nums[right]);
            if (right - left == k) {
                // 需要移除一个
                window.remove(nums[left]);  // 窗口里面一定不会重复，否则之前已经返回true了
                left += 1;
            }
            right += 1;
        }
        return false;
    }
}
```





## 324. 摆动序列(M

### 题目描述

[链接](https://leetcode-cn.com/problems/wiggle-sort-ii/)

```
给定一个无序的数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。
输入: nums = [1, 5, 1, 1, 6, 4]
输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]
```

### 分析

排序后，交替插入。比如排序后为 `1 1 1     4 5 6`

先放 1，再放4，再放1再放5...

由于左边必须完全小于右边，因此，可以这样放可能存在等于的情况。于是都从右往左放即可。



如果要优化的话，因为只要保证右边全部大于左边即可，内部不一定要有序，这明显就是快速排序，找中位数那种做法。

### 实现

```java
class Solution {
    public void wiggleSort(int[] nums) {
        int[] array = Arrays.copyOf(nums, nums.length);
        Arrays.sort(array);

        int left = (array.length - 1) / 2;
        int right = array.length - 1;

        int index = 0;
        while (left >= 0) {
            nums[index] = array[left];
            left -= 1;
            index += 1;

            if (index == nums.length) {
                break;
            }
            nums[index] = array[right];
            right -= 1;
            index += 1;
        }

        if (nums.length % 2 == 1) {
            // 多出来一个
            nums[nums.length - 1] = array[0];
        }


    }
}
```



## 416. 分割等和子集(M）

### 题目描述

[链接](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

### 分析

总和的一半是目标值。有点类似于找总和等于目标值的题。采用递归和回溯，不断判断。思路是可以的。

但是回溯或者递归，是要将几乎所有情况列举完的。如果不是要求详细情况，求总数或者是否这种情况，一定要思考是否有更好的解法。

这道题，就是一个0-1背包问题。并且是一个 一定要装满的背包问题，所以初始化的时候需要特别关键。

### 实现

```java
// 0-1背包思路
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        int maxValue = Integer.MIN_VALUE;
        for(int each : nums) {
            sum += each;
            maxValue = Math.max(maxValue, each);
        }
        if(sum % 2 == 1) return false;
        int target = sum / 2;

        if (maxValue > target) {
            return false;
        }
        Arrays.sort(nums);

        boolean[][] dp = new boolean[nums.length + 1][target + 1];  // 前 i 个 是否能够 达到 和 等于 j

        // 必须要装满，因此初始化很关键
        for (int i = 0; i <= nums.length; i++) {
            dp[i][0] = true;
        }

        for (int i = 1; i <= nums.length; i++) {
            int num = nums[i - 1];

            for (int j = 1; j <= target; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j - num >= 0) {
                    dp[i][j] = dp[i][j] || dp[i - 1][j - num];
                }
            }
        }

        return dp[nums.length][target];
    }
}



// 递归版本，复杂度高，但是也是合理的
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int each : nums) {
            sum += each;
        }
        if(sum % 2 == 1) return false;
        Arrays.sort(nums);

        // 上面是预处理
        return backTrack(nums, 0, sum / 2, 0);
       
    }

    private boolean backTrack(int[] nums, int sum, int target, int index) {
        if (sum == target) {
            return true;
        } else if (sum > target) {
            return false;
        }

        for (int i = index; i < nums.length; i++) {
            int newSum = sum + nums[i];
            boolean isOk = backTrack(nums, newSum, target, i + 1);

            if (isOk == true) {
                return true;
            }
        }
        return false;
    }
}
```





## 424. 替换后的最长重复字符串(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

```
给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。
输入:
s = "ABAB", k = 2

输出:
4

解释:
用两个'A'替换为两个'B',反之亦然
```

### 分析

维护一个窗口，判断窗口内替换掉少于k个是否合法，如果合法，窗口右移动，否则窗口收缩。

如何判断是否合法，记录窗口内部，出现次数最多的个数，那么需要替换的个数就是窗口长度减去这个最多个个数。

### 实现

```java
class Solution {
    public int characterReplacement(String s, int k) {
        int[] count = new int[26];

        int left = 0;
        int right = 0;
        int maxCount = 0; // 记录窗口出现次数最多的个数
        int ans = 0;

        while (right < s.length()) {
            char c = s.charAt(right);
            count[c - 'A'] += 1;

            if (count[c - 'A'] > maxCount) {
                // 窗口内最多的需要改变了
                maxCount = count[c - 'A'];
            }

            // 需要替换的个数为窗口大小减去最大的个数
            int needChange = right - left + 1 - maxCount;

            // 如果 needChange  小于 k，那么还是合法的，窗口继续移动，否则窗口需要收缩
            if (needChange > k) {
                char temp = s.charAt(left);
                count[temp - 'A'] -= 1;
                left += 1;
            }
            ans = Math.max(ans, right - left + 1);
            right += 1;
        }
        return ans;
    }
}
```





## 453. 最小操作次数使得元素相等(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/)

```
给定一个长度为 n 的 非空 整数数组，每次操作将会使 n - 1 个元素增加 1。找出让数组所有元素相等的最小操作次数。
输入：
[1,2,3]
输出：
3
解释：
只需要3次操作（注意每次操作会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

```

### 分析

一种很特别的思路是，每次 `n - 1`个元素增加1，等价于一个元素 减去 1。 因此，变成每次减去1，最少次数变成最小值。

### 实现

```java
class Solution {
    public int minMoves(int[] nums) {
        if(nums.length == 0 || nums.length == 1) return 0;
        
        // 找最小值
        int min = nums[0];
        for (int i = 1; i < nums.length; i++) {
            min = Math.min(min, nums[i]);
        }

        int ans = 0;
        for (int each : nums) {
            ans += each - min;
        }

        return ans;
    }
}
```





## 457. 环形数组循环(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/circular-array-loop/)

```
给定一个含有正整数和负整数的环形数组 nums。 如果某个索引中的数 k 为正数，则向前移动 k 个索引。相反，如果是负数 (-k)，则向后移动 k 个索引。因为数组是环形的，所以可以假设最后一个元素的下一个元素是第一个元素，而第一个元素的前一个元素是最后一个元素。

确定 nums 中是否存在循环（或周期）。循环必须在相同的索引处开始和结束并且循环长度 > 1。此外，一个循环中的所有运动都必须沿着同一方向进行。换句话说，一个循环中不能同时包括向前的运动和向后的运动。

输入：[2,-1,1,2,2]
输出：true
解释：存在循环，按索引 0 -> 2 -> 3 -> 0 。循环长度为 3 。
```

### 分析

从某个起始点，一直模拟进行，查找是否有环。如何判断有环，一种思路是类似于判断链表有环那种，用快慢指针。一种就是记录下之前的节点，遇到相同的说明有环。这里采用第二种。

还有一个问题是，如果遇到了之前就已经判断过的，不能形成环的节点，如何快速返回，而不是继续进行判断。因此都需要进行记录。

二者统一用一个数组记录，如果是当前路径走过的，用一个相同数字保存， 如果是之前判断过的不能形成环的，用其他数字标识即可。可以用`round`来标识，代表第几次从起点出发寻找环，即轮数。

### 实现

```java
class Solution {
    public boolean circularArrayLoop(int[] nums) {
        
        int[] used = new int[nums.length]; // 这是一个数组，来标识之前是否被使用了。
        // 比如找第一个的时候，都标记为1， 那么如果有环，一定会回到某个索引等于1.
        // 第一个没找到，不能形成环的都已经被标记为1， 那么找第二轮，都标记为2，依次类推

        int round = 1;
        int len = nums.length;

        for (int i = 0; i < len; i++) {

            if (used[i] != 0) {
                // 之前已经走过了，并且不能形成环，只要不是0，就说明曾经访问过，如果等于本轮的标识，则说明是环，否则，说明不行
                continue;
            }

            round += 1;  // 轮数 + 1

            // 从 i 开始模拟这个过程
            int currentIndex = i;
            
            while (true) {
                if (nums[i] > 0 && nums[currentIndex] < 0) {
                    // 都应该是正数，但当前是负数
                    break;
                }
                if (nums[i] < 0 && nums[currentIndex] > 0) {
                    break;
                }

                int nextIndex = (currentIndex + nums[currentIndex]) % len;
                // 如果是负数，需要转为正数
                nextIndex = (nextIndex + len) % len;

                if (nextIndex == currentIndex) {
                    // 走一步就回到自己了，这不算环
                    break;
                } 


                if (used[currentIndex] == 0) {
                    // 还没有被用过
                    used[currentIndex] = round;
                    currentIndex = nextIndex;
                } else if (used[currentIndex] == round) {
                    // 构成环了
                    return true;
                } else {
                    // 被之前其他轮用过了，构不成环
                    break;
                }
            }
        }
        return false;
    }
}
```





## 462. 最少加1次数使得元素相等(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)

```
给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。
输入:
[1,2,3]

输出:
2

说明：
只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： 

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]

```

### 分析

可以证明的是，最终元素是中位数就是最少的次数，如果是偶数个，比如中位数是 10 和 20， 那么最终元素是10到20中任何一个都可以。所以，排个序，然后取中位数，就得到最终的目标元素了。

由于只是寻找中位数，很明显的使用一趟快排，能够降低时间复杂度。

### 实现

```java
class Solution {
    public int minMoves2(int[] nums) {
        if(nums.length == 0 || nums.length == 1) return 0;
        Arrays.sort(nums);
        
        int ans = 0;
        int base = nums[nums.length / 2];
        for(int each : nums) {
            ans += Math.abs(each - base);
        }
        return ans;
    }
}

// 使用快排版本
class Solution {
    public int minMoves2(int[] nums) {
        quickSortOnce(nums, 0, nums.length - 1);

        int base = nums[nums.length / 2];
        int ans = 0;
        for (int each : nums) {
            ans += Math.abs(each - base);
        }
        return ans;
    }


    private void quickSortOnce(int[] nums, int startIndex, int endIndex) {
        if (startIndex >= endIndex) {
            return;
        }

        int key = nums[startIndex];
        int left = startIndex;
        int right = endIndex;

        while (left < right) {
            while (left < right && nums[right] >= key) {
                right -= 1;
            }
            swap(nums, left, right);
            while (left < right && nums[left] <= key) {
                left += 1;
            }
            swap(nums, left, right);
        }

        if (left == nums.length / 2) {
            return;
        } else if (left > nums.length / 2) {
            quickSortOnce(nums, startIndex, left - 1);
        } else {
            quickSortOnce(nums, left + 1, endIndex);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```





## 498. 对角线遍历(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/diagonal-traverse/)

```
给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。
 输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

```

### 分析

如果模拟的话，也可以，就是边界判断太多。

只从一方进行对角线行进，然后判断是否需要反转。比如，第一个对焦， 1， 不用反转，第二个对角，4，2反转，第三个不用反转，以此类推

### 实现

```java
class Solution {
    public int[] findDiagonalOrder(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return new int[]{};
        }
        int m = matrix.length - 1;
        int n = matrix[0].length - 1;
        int[] ans = new int[(m + 1) * (n + 1)];

        boolean flag = false;

        int startRow = 0;
        int startCol = 0; // 每一次的起点，
        int index = 0;

        Deque<Integer> stack = new LinkedList<>();
        while (index < ans.length) {

            // 一次对角线遍历
            int i = startRow;
            int j = startCol;

            if (flag == false) {
                // 是顺序的
                while (i >= 0 && j <= n) {
                    ans[index] = matrix[i][j];
                    i -= 1;
                    j += 1;
                    index += 1;
                }
                flag = !flag; // 改变 flag

            } else {
                // 需要反转
                while (i >= 0 && j <= n) {
                    stack.offerLast(matrix[i][j]);
                    i -= 1;
                    j += 1;
                }

                while (stack.size() > 0) {
                    ans[index] = stack.pollLast();
                    index += 1;
                }
                flag = !flag; // 改变 flag
            }


            // 找下一个起始点
            if (startRow == m && startCol == 0) {
                // 在左下角
                startCol += 1;
            } else if (startRow < m) {
                // 在左侧
                startRow += 1;
            } else {
                // 在下边
                startCol += 1;
            }
        }
        return ans;
    }
}
```





## 523. 连续的子数组和(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/continuous-subarray-sum/)

```
给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

输入：[23,2,4,6,7], k = 6
输出：True
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。
```

### 分析

要涉及到区间的总和，一般都要想到使用前缀和。最直观的思路， 求出前缀和，然后两层循环，判断是否有合适的即可。

还有一种思路是，由于是`k`的倍数即可，将前缀和进行取余并不影响什么。于是这道题就变成了， 求两个位置的前缀和是否存在相等，这样的话，用`set`保存之前的前缀和，就可以直接判断之前是否存在和他相等的即可。

一些特殊情况，`k=0`需要额外注意，因为不能取余。题目还要求，连续数组大小至少是2， 那么用`set`并不能标识索引信息，于是用`map`， `key`是前缀和(取余)， `value`是对应的索引。

### 实现

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {

        Map<Integer, Integer> map = new HashMap<>();
        int preSum = 0;
        map.put(preSum, -1); // 前缀和的一般都需要加一个0进去
        
        for (int i = 0; i < nums.length; i++) {
            preSum += nums[i];// 当前的前缀和

            // 判断和之前的前缀和相减是否等于0,因为都是取了余数的
            if (k != 0) {
                // 取余，k不能是0
                preSum = preSum % k;
            }
            
            if (map.containsKey(preSum)) {
                // 还要满足， 大小至少为2
                if (i - map.get(preSum) >= 2) {
                    return true;
                }
            } else {
                map.put(preSum, i); // 要在这个else里面判断，如果存在但是不满足至少为2的适合，不用更新map(相同的值，保持最小的索引，才可以有更大的区间)， 只有不存在的时候，才需要更新map
            }
            
        }

        return false;

        
    }
}
```





## 560. 和为K的连续子数组个数(M)

### 题目描述

[链接](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

### 分析

和上一道题思路完全一致，用`map`存储前缀和。

### 实现

```java
class Solution {
    public int subarraySum(int[] nums, int k) {

        int preSum = 0; // 前缀和
        Map<Integer, Integer> map = new HashMap<>();
        map.put(preSum, 1);

        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            preSum += nums[i];

            int target = preSum - k;
            
            if (map.containsKey(target) == true) {
                // 有匹配到的，数量加入结果
                ans += map.get(target);
            }

            map.put(preSum, map.getOrDefault(preSum, 0) + 1);
        }

        return ans;
    }

}
```

