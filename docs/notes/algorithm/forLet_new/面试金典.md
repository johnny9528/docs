# 面试金典

## 1. 移除链表中重复节点

### 描述

[链接](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

```
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
 
链表长度在[0, 20000]范围内。
链表元素在[0, 20000]范围内。
```

### 分析

最简单的思路，使用`haseSet`保存之前出现的值。或者两次循环暴力求解。

一种更好的方式是， 使用位运算来保存之前出现的值, 这样一个数字可以保存32个信息

### 实现

```java
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        int[] nums = new int[20000 / 32 + 1];
        ListNode preHead = new ListNode();
        ListNode preHeadDumpy = preHead;

        while (head != null) {
            int index = head.val / 32;
            int extra = head.val % 32;

            if ((nums[index] & (1 << extra)) != 0) {
                // 出现重复
                head = head.next;
                preHead.next = null;
            } else {
                nums[index] = nums[index] | (1 << extra);
                preHead.next = head;
                head = head.next;
                preHead = preHead.next;
                preHead.next = null;
            }
        }

        return preHeadDumpy.next;
    }
}
```





## 08-01. 三步问题

### 描述

[链接](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

```
三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
 输入：n = 3 
 输出：4
 说明: 有四种走法
```

### 分析

典型的动态规划，当前状态等于之前三个状态的总和。

可以优化空间复杂度, 不优化更好理解

也可以采用递归，至上而下，动态规划是空间换时间

### 实现

```java
class Solution {
    public int waysToStep(int n) {
        if (n <= 2) return n;
        int[] dp = new int[n + 1];
        dp[n] = 1;
        dp[n - 1] = 2;
        dp[n - 2] = 4;
        for (int i = n - 3; i > 0; i--) {
            dp[i] = (dp[i + 1] + dp[i + 2]) % 1000000007 + dp[i + 3];
            dp[i] = dp[i] % 1000000007;
        }
        return dp[1];

    }
}
```



## 08-02. 迷路的机器人

### 描述

[链接](https://leetcode-cn.com/problems/robot-in-a-grid-lcci/)

```
设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。
网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
解释: 
输入中标粗的位置即为输出表示的路径，即
0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）
```

### 分析

这是一个典型的回溯。但是需要注意的是：

* 只用找到一条路径即可，即找到一条路径就不用继续回溯了。因此`dfs`的返回值一定需要标识是否已经找到结果。如果找到结果，直接返回，否则，继续`dfs`
* 由于只能往右或者往下走，不需要一个全局的 `visted`来标识哪些地方已经访问过。
* 减枝， 如果某个点已经确定无法到达重点，那么该点和障碍其实是一样的，将该点标识为障碍，避免重复计算该点

### 实现

```java
class Solution {
    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {

        List<List<Integer>> ans = new ArrayList<>();
        if (obstacleGrid == null || obstacleGrid.length == 0) {
            return ans;
        }
        int row = obstacleGrid.length - 1;
        int col = obstacleGrid[0].length - 1;
        if (obstacleGrid[row][col] == 1) {
            return ans;
        }


        dfs(obstacleGrid, ans, 0, 0, obstacleGrid.length - 1, obstacleGrid[0].length - 1);
        return ans;

    }
    private boolean dfs(int[][] nums, List<List<Integer>> ans, int i, int j, int row, int col) {
        if (i == row && j == col) {
            // 得到一个结果, 加入结果，返回true， 表示已经得到最终结果，后续不需要再遍历了。
            List<Integer> location = new ArrayList<>();
            location.add(i);
            location.add(j);
            ans.add(location);
            return true;
        }
        // 超出边界或者遇到障碍物，返回false， 表示此路不通
        if (i == row + 1 || j == col + 1 || nums[i][j] == 1) {
            return false;
        }
		
        // 将该点加入到路径中
        List<Integer> location = new ArrayList<>();
        location.add(i);
        location.add(j);
        ans.add(location);
        
        // 尝试往右走，返回往右是否有路径到达
        boolean isTrue = dfs(nums, ans, i, j + 1, row, col);
        if (isTrue == true) {
            // 往右已经有路径到达了，不用回溯和尝试了，直接返回结果
            return true;
        }
        
        // 往右走，没有路径到达，尝试往下走
        isTrue = dfs(nums, ans, i + 1, j, row, col);
        if (isTrue == true) {
            // 往下走，有路径到达，返回正确结果
            return true;
        }
        
        // 往右和往下都没有路径到达，回溯，删除刚才加入路径的点
        ans.remove(ans.size() - 1);
        nums[i][j] = 1;  // 减枝，很关键，标时这个点无法到达终点，即和障碍一样，标时为障碍
        return false;
    }
}
```



## 08-03. 魔术索引

### 描述

[链接](https://leetcode-cn.com/problems/magic-index-lcci/)

```
魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

输入：nums = [0, 2, 3, 4, 5]
输出：0
说明: 0下标的元素为0
```

### 分析

关键信息： 魔术索引是 索引等于当前值的索引、数组有序。

因为数组有序，比如说遍历到索引为`5`的地方， `nums[5]` 的值有以下几种情况：

* 等于5， 那么找到第一个魔术了，直接返回。
* 大于 5， 比如等于 8。 由于数组递增，那么 索引为5的后面一定大于等于8， 即索引为6、7的地方一定不会是魔数，直接跳到8再判断
* 小于5， 此时不能判断任何东西，判读下一个索引，即6 是否是魔数

### 实现

```java
class Solution {
    public int findMagicIndex(int[] nums) {
        int index = 0;
        while (index < nums.length) {
            // 找到结果了，直接返回
            if (nums[index] == index) {
                return index;
            }
			
            // 满足第二种情况，索引直接跳到nums[index]
            if (nums[index] > index) {
                index = nums[index];
            } else {
                // 不能判断任何东西，继续下一个
                index += 1;
            }
        }
        return -1;
    }
}
```



## 08-04. 幂集

### 描述

[链接](https://leetcode-cn.com/problems/power-set-lcci/)

```
幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。

说明：解集不能包含重复的子集。
 输入： nums = [1,2,3]
 输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

```

### 分析

方法1：

典型的回溯。需要考虑的问题是：

* 本身集合不含重复的元素，那么就不用考虑顺序的问题。
* 结果集不能包含重复的元素，那么中间过程只用考虑后面的部分。比如第一个数为1， 已经包含了大部分情况，当寻找以 2 开头的结果的时候，不应该考虑1. 即  `2 1 3`一定会在 `1, 2, 3`之后找到，此时重复了。



方法2：

当1 和 2 都已经找到的时候，即 `[],[1], [2], [1,2]`， 加入只需要将每一个加入3即可，原来的还在，然后新增加入3的。

### 实现

```java
/**
	回溯
*/
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Deque<Integer> path = new LinkedList<>();

        dfs(nums, 0, ans, path);
        return ans;
    }

    private void dfs(int[] nums, int index, List<List<Integer>> ans, Deque<Integer> path) {
        ans.add(new ArrayList<>(path));
        for (int i = index; i < nums.length; i++) {
            path.push(nums[i]);
            dfs(nums, i + 1, ans, path);
            path.pop();  
        }
    }
}

/**
	方法2
*/
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(new ArrayList<>());
        for (int num : nums) {
            int preLength = ans.size();
            for (int i = 0; i < preLength; i++) {
                List<Integer> temp = new ArrayList<>(ans.get(i));
                temp.add(num);
                ans.add(temp);
            }
        }
        return ans;
    }

}
```



## 08-05. 递归乘法

### 描述

[链接](https://leetcode-cn.com/problems/recursive-mulitply-lcci/)

```
递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
 输入：A = 1, B = 10
 输出：10
```

### 分析

分治。乘法就是不断的加法。比如 10 * 6，可以不断划分下去

* `10 * 6 = 5 * 6 + 5 * 6`
* `5 * 6 = 2 * 6 + 2 * 6 + 6`

因此， 如果x是偶数，则求出 x / 2 * y 即可，然后两个加起来。

如果x 是偶数， 需要额外再加一个y。

使用递归实现：

### 实现

```java
class Solution {
    public int multiply(int A, int B) {
        if (A == 1) {
            return B;
        }
        int half = A >> 1;
        int extra = A - (half << 1);

        int subAns = multiply(half, B);
        return subAns + subAns + (extra == 1 ? B : 0);
    }
}
```



## 08-06. 汉诺塔问题

### 题目描述

[链接](https://leetcode-cn.com/problems/hanota-lcci/submissions/)

```
在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
```

### 分析

不考虑实现细节，考虑整体。要把A柱子上的n个圆盘移到C， 有个柱子B作为过渡。考虑如下步骤

* 将A柱子上的n-1个圆盘， 通过柱子C作为过渡，移到柱子B。 此时， A柱子上剩下一个圆盘， B柱子有n-1个， C为空。
* 将A柱子上剩下的最大的圆盘，移到C。此时， A柱子为空， B柱子还是n-1个， C柱子上1个
* 将B柱子上的n-1个圆盘通过柱子A过渡，移到C上。
* 流程结束

### 实现

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        move(A.size(), A, B, C);
    }
	
    /**
    	C是目的地， B是过渡
    */
    private void move(int n, List<Integer> A, List<Integer> B, List<Integer> C) {
        if (n == 1) {
            // 如果移动的个数为1， 将最上的一个直接移到目的地C
            C.add(A.remove(A.size() - 1));
            return;
        }

        // 将 n - 1个从A移动到B
        move(n - 1, A, C, B);

        // 将最底下一个移动到c
        C.add(A.remove(A.size() - 1));
        // 将B的所有移动到C
        move(n - 1, B, A, C);

    }
}
```



## 08-07. 无重复字符串的排列组合

### 描述

[链接](https://leetcode-cn.com/problems/permutation-i-lcci/)

```
无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。
 输入：S = "qwe"
 输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"]
```

### 分析

字符串的排列组合，和幂集的区别在于：幂集是不能重复的， 比如 `[1, 2, 3]` 和 `[2, 1, 3]`是一样的， 但是字符串 `abc`和`bac`不一样。因此大体思路一致， 区别在于需要一个 `visted`数组来标识哪些被用过了。

### 实现

```java
class Solution {
    public String[] permutation(String S) {
        List<String> ans = new ArrayList<>();
        if (S == null || S.length() == 0) {
            return new String[] {};
        }
        StringBuilder path = new StringBuilder();
        int length = S.length();
        boolean[] visted = new boolean[length];

        dfs(S, visted, ans, path);
        
        String[] stringArray = new String[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            stringArray[i] = ans.get(i);
        }
        return stringArray;
    }

    private void dfs(String s, boolean[] visted, List<String> ans, StringBuilder path) {

        if (path.length() == s.length()) {
            // 加入到结果集
            ans.add(path.toString());
            // System.out.println(ans);
            return;
        }

        for (int i = 0; i < s.length(); i++) {
            if (visted[i] == true) {
                // 该字符被用过了，跳过
                continue;
            }
            // 将该字符加入到路径中
            path.append(s.charAt(i));
            visted[i] = true; // 设置该字符被使用了
            dfs(s, visted, ans, path); // 继续找下一个字符
            path.deleteCharAt(path.length() - 1); // 回溯，路径中删除该字符
            visted[i] = false; // 将字符标识为没有被使用
        }

    }
}
```



## 08-08. 有重复字符串的排列组合

### 描述

[链接]()

```java
和上一题的唯一区别是， 字符可能存在重复。
```

### 分析

字符存在重复， 除了基本思路和上述一致外。需要额外考虑的是这种特殊情况：

当字符串前缀相同时，如果在当前位置两次遍历同一个字母就会导致重复。

### 实现

```java
class Solution {
    public String[] permutation(String S) {
        List<String> ans = new ArrayList<>();
        if (S == null || S.length() == 0) {
            return new String[]{};
        }
        StringBuilder sb = new StringBuilder();
        boolean[] used = new boolean[S.length()];

        dfs(S, ans, sb, used);

        return ans.toArray(new String[ans.size()]);

    }

    private void dfs(String s, List<String> ans, StringBuilder sb, boolean[] used) {
        if (sb.length() == s.length()) {
            // 加入结果
            ans.add(sb.toString());
            return;
        }

        for (int i = 0; i < s.length(); i++) {
            if (used[i] == true) {
                continue;
            }

            boolean valid = true; // 判断这个字符应不应该要
            for (int j = 0; j < i; j++) {
                if (s.charAt(j) == s.charAt(i) && used[j] == false) {
                    // 如果该字符和之前字符相同， 并且之前字符没有被用到，那么这次用到，一定会重复(如果要用，为什么不用之前的呢， 这种道理)
                    valid = false;
                }
            }
            if (valid == false) {
                // 冗余， 直接跳过
                continue;
            }
            
            // 后续步骤和之前一致

            sb.append(s.charAt(i));
            used[i] = true;
            dfs(s, ans, sb, used);
            sb.deleteCharAt(sb.length() - 1);
            used[i] = false;

        }


    }
}
```

