# 面试金典

## 1. 移除链表中重复节点

### 描述

[链接](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

```
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
 
链表长度在[0, 20000]范围内。
链表元素在[0, 20000]范围内。
```

### 分析

最简单的思路，使用`haseSet`保存之前出现的值。或者两次循环暴力求解。

一种更好的方式是， 使用位运算来保存之前出现的值, 这样一个数字可以保存32个信息

### 实现

```java
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        int[] nums = new int[20000 / 32 + 1];
        ListNode preHead = new ListNode();
        ListNode preHeadDumpy = preHead;

        while (head != null) {
            int index = head.val / 32;
            int extra = head.val % 32;

            if ((nums[index] & (1 << extra)) != 0) {
                // 出现重复
                head = head.next;
                preHead.next = null;
            } else {
                nums[index] = nums[index] | (1 << extra);
                preHead.next = head;
                head = head.next;
                preHead = preHead.next;
                preHead.next = null;
            }
        }

        return preHeadDumpy.next;
    }
}
```



## 01-01. 判断字符串中字符是否唯一(S)

### 题目描述

[链接](https://leetcode-cn.com/problems/is-unique-lcci/)

```
实现一个算法，确定一个字符串 s 的所有字符是否全都不同。
输入: s = "leetcode"
输出: false 
```

### 分析

如果采用set， 则没有意义。

由于字符的个数为128个，一个Long型的整数，8个比特， 能够存储的最大位数为64位， 因此采用两个long型整数进行存储。采用位运算， 左移和右移

### 实现

```java
class Solution {
    public boolean isUnique(String astr) {
        long high = 0;  // 存储 第 64到 128号字符
        long low = 0;

        for (int i = 0; i < astr.length(); i++) {
            char c = astr.charAt(i);

            if (c >= 64) {
                // 使用high进行判断
                long temp = 1l << (c - 64);
                if ((high & temp) != 0) { // 此时遇见重复
                    return false;
                }
                high = high | temp;
            } else {
                long temp = 1l << c;
                if ((low & temp) != 0) {
                    return false;
                }
                low = low | temp;
            }
        }
        return true;
    }
}
```



## 01-02. 判断是否是字符重排(S)

### 题目描述

[链接](https://leetcode-cn.com/problems/check-permutation-lcci/)

```
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
输入: s1 = "abc", s2 = "bca"
输出: true 
```

### 分析

由于字符的个数不超过128， 构造一个`count`数组， 遍历两个字符，第一个字符串的字符，对应count加 1， 第二个则减一，最后看是不是全0即可

### 实现

```java
class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        int[] count = new int[128];
        for (int i = 0; i < s1.length(); i++) {
            count[s1.charAt(i)]++;
            count[s2.charAt(i)]--;
        }
        
        for (int num : count) {
            if (num != 0) return false;
        }
        return true;
    }
}
```



## 01-04. 回文排列

### 题目描述

[链接](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)

```
给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
回文串不一定是字典当中的单词。

输入："tactcoa"
输出：true（排列有"tacocat"、"atcocta"，等等）
```

### 分析

和上一题一样思路， 利用一个count数组，最后遍历count，如果有多于一个是奇数的，则返回false， 否则返回true

### 实现

```java
class Solution {
    public boolean canPermutePalindrome(String s) {
        int[] count = new int[128];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i)] += 1;
        }

        int allowOnce = 0;
        for (int number : count) {
            if (number % 2 == 1) {
                allowOnce += 1;
            }

            if (allowOnce == 2) {// 超过一个奇数了
                return false;
            }
        }
        return true;
    }
}
```



## 01-05. 一次编辑

### 题目描述

[链接](https://leetcode-cn.com/problems/one-away-lcci/)

```
字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。
输入: 
first = "pale"
second = "ple"
输出: True
```

### 分析

由于最多只能操作一次，可以插入删除和替换。考虑下面几种情况：

* 两个字符串长度一样：那么只能是替换一个字符或者不替换。
* 长度不一样
  * 长度相差为1， 一定是短的字符串插入了一个字符
  * 相差不止1， 直接返回false

分开讨论即可

### 实现

```java
class Solution {
    public boolean oneEditAway(String first, String second) {
        // 保持first比second长
        // 如果长度相同，则一定是替换字符， 如果长度相差1， 则一定是删除一个字符
        if (first.length() < second.length()) {
            String temp = first;
            first = second;
            second = temp;
        }
        int len1 = first.length();
        int len2 = second.length();

        if (len1 - len2 > 1) {
            return false;
        }

        int differenceCount = 0;
        int i = 0;
        int j = 0;
        if (len1 == len2) {
            // 只能有一个地方不同
            while (i < len1) {
                if (first.charAt(i) != second.charAt(i)) {
                    differenceCount += 1;
                }
                i += 1;
                if (differenceCount > 1) {
                    return false;
                }
            }
        } else {
            // 只能是删除一个
            while (i < len1 && j < len2) {
                if (first.charAt(i) != second.charAt(j)) {
                    differenceCount += 1;
                    i += 1;
                } else {
                    i += 1;
                    j += 1;
                }

                if (differenceCount > 1) {
                    return false;
                }
            }
        }

        return true;
    }
}
```



## 01-06. 字符串压缩

### 题目描述

[链接](https://leetcode-cn.com/problems/compress-string-lcci/)

```
字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
 输入："aabcccccaaa"
 输出："a2b1c5a3"
```

### 分析

直接模拟这个过程即可， 双指针找到相同元素的左和右

### 实现

```java
class Solution {
    public String compressString(String s) {
        if (s == null || s.length() == 0) return s;
        StringBuilder sb = new StringBuilder();

        int left = 0, right = 0;
        while (right < s.length()) {
            if (s.charAt(right) == s.charAt(left)) {
                right += 1;
            } else {
                sb.append(s.charAt(left)).append(right - left);
                left = right;
            }
        }
        sb.append(s.charAt(left)).append(right - left);

        return sb.length() < s.length() ? sb.toString() : s;
    }
}
```



## 01-07. 旋转矩阵90度

### 题目描述

[链接](https://leetcode-cn.com/problems/rotate-matrix-lcci/)

```
给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]

```

### 分析

可以找到规律， 旋转90度， 可以用两个过程模拟

* 先求转置
* 然后左右对称变换

### 实现

```java
class Solution {
    public void rotate(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return;
        }
        int length = matrix.length;

        int temp = 0;
        // 先转置
        for (int i = 0; i < length; i++) {
            for (int j = i; j < length; j++) {
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 再对称变换
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length / 2; j++) {
                temp = matrix[i][j];
                matrix[i][j] = matrix[i][length - j - 1];
                matrix[i][length - j - 1] = temp;
            }
        }
    }
}
```



## 01-08. 将矩阵中零元素对应的行和列都清零

### 题目描述

[链接](https://leetcode-cn.com/problems/zero-matrix-lcci/)

```
编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]

```

### 分析

先判断第一行和第一列是否需要清零。

然后遍历整个数组， 如果某个元素为0， 将改行的第一个元素标识为 -1， 表示改行需要清零。将该列的第一个元素标识为 -1。

根据需要清零的行和列进行清零。

### 实现

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return;
        }
        int row = matrix.length;
        int col = matrix[0].length;
        boolean firstRow = false;
        boolean firstCol = false;

        for (int i = 0; i < row; i++) {
            if (matrix[i][0] == 0) {
                firstCol = true;
                break;
            }
        }
        for (int j = 0; j < col; j++) {
            if (matrix[0][j] == 0) {
                firstRow = true;
                break;
            }
        }

        // 如果某个元素为0, 则将改行和该列的头部元素标识为需要清零
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        for (int i = 1; i < col; i++) {
            if (matrix[0][i] == 0) {
                // 该列需要清零
                for (int j = 1; j < row; j++) {
                    matrix[j][i] = 0;
                }
            }
        }

        for (int i = 1; i < row; i++) {
            if (matrix[i][0] == 0) {
                // 该行需要清零
                for (int j = 1; j < col; j++) {
                    matrix[i][j] = 0;
                }
            }
        }

        // 第一行和第一列是否需要清零
        if (firstRow == true) {
            for (int i = 0; i < col; i++) {
                matrix[0][i] = 0;
            }
        }

        if (firstCol == true) {
            for (int i = 0; i < row; i++) {
                matrix[i][0] = 0;
            }
        }

    }
}
```



## 01-09. 字符串旋转

### 题目描述

[链接](https://leetcode-cn.com/problems/string-rotation-lcci/)

```
字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。
输入：s1 = "waterbottle", s2 = "erbottlewat"
 输出：True
```

### 分析

如果`s2`是`s1`旋转得到，那么， 两个`s2`拼接， 一定会在中间形成一个`s1`， 比如 

`erbottlewat` + `erbottlewat` = `erbottlewaterbottlewat`  中间有 `waterbottle`

### 实现

```java
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        if (s1 == null || s2 == null || s1.length() != s2.length()) {
            return false;
        }

        return (s2 + s2).indexOf(s1) != -1;
    }
}
```





## 08-01. 三步问题

### 描述

[链接](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

```
三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
 输入：n = 3 
 输出：4
 说明: 有四种走法
```

### 分析

典型的动态规划，当前状态等于之前三个状态的总和。

可以优化空间复杂度, 不优化更好理解

也可以采用递归，至上而下，动态规划是空间换时间

### 实现

```java
class Solution {
    public int waysToStep(int n) {
        if (n <= 2) return n;
        int[] dp = new int[n + 1];
        dp[n] = 1;
        dp[n - 1] = 2;
        dp[n - 2] = 4;
        for (int i = n - 3; i > 0; i--) {
            dp[i] = (dp[i + 1] + dp[i + 2]) % 1000000007 + dp[i + 3];
            dp[i] = dp[i] % 1000000007;
        }
        return dp[1];

    }
}
```



## 08-02. 迷路的机器人

### 描述

[链接](https://leetcode-cn.com/problems/robot-in-a-grid-lcci/)

```
设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。
网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
解释: 
输入中标粗的位置即为输出表示的路径，即
0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）
```

### 分析

这是一个典型的回溯。但是需要注意的是：

* 只用找到一条路径即可，即找到一条路径就不用继续回溯了。因此`dfs`的返回值一定需要标识是否已经找到结果。如果找到结果，直接返回，否则，继续`dfs`
* 由于只能往右或者往下走，不需要一个全局的 `visted`来标识哪些地方已经访问过。
* 减枝， 如果某个点已经确定无法到达重点，那么该点和障碍其实是一样的，将该点标识为障碍，避免重复计算该点

### 实现

```java
class Solution {
    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {

        List<List<Integer>> ans = new ArrayList<>();
        if (obstacleGrid == null || obstacleGrid.length == 0) {
            return ans;
        }
        int row = obstacleGrid.length - 1;
        int col = obstacleGrid[0].length - 1;
        if (obstacleGrid[row][col] == 1) {
            return ans;
        }


        dfs(obstacleGrid, ans, 0, 0, obstacleGrid.length - 1, obstacleGrid[0].length - 1);
        return ans;

    }
    private boolean dfs(int[][] nums, List<List<Integer>> ans, int i, int j, int row, int col) {
        if (i == row && j == col) {
            // 得到一个结果, 加入结果，返回true， 表示已经得到最终结果，后续不需要再遍历了。
            List<Integer> location = new ArrayList<>();
            location.add(i);
            location.add(j);
            ans.add(location);
            return true;
        }
        // 超出边界或者遇到障碍物，返回false， 表示此路不通
        if (i == row + 1 || j == col + 1 || nums[i][j] == 1) {
            return false;
        }
		
        // 将该点加入到路径中
        List<Integer> location = new ArrayList<>();
        location.add(i);
        location.add(j);
        ans.add(location);
        
        // 尝试往右走，返回往右是否有路径到达
        boolean isTrue = dfs(nums, ans, i, j + 1, row, col);
        if (isTrue == true) {
            // 往右已经有路径到达了，不用回溯和尝试了，直接返回结果
            return true;
        }
        
        // 往右走，没有路径到达，尝试往下走
        isTrue = dfs(nums, ans, i + 1, j, row, col);
        if (isTrue == true) {
            // 往下走，有路径到达，返回正确结果
            return true;
        }
        
        // 往右和往下都没有路径到达，回溯，删除刚才加入路径的点
        ans.remove(ans.size() - 1);
        nums[i][j] = 1;  // 减枝，很关键，标时这个点无法到达终点，即和障碍一样，标时为障碍
        return false;
    }
}
```



## 08-03. 魔术索引

### 描述

[链接](https://leetcode-cn.com/problems/magic-index-lcci/)

```
魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

输入：nums = [0, 2, 3, 4, 5]
输出：0
说明: 0下标的元素为0
```

### 分析

关键信息： 魔术索引是 索引等于当前值的索引、数组有序。

因为数组有序，比如说遍历到索引为`5`的地方， `nums[5]` 的值有以下几种情况：

* 等于5， 那么找到第一个魔术了，直接返回。
* 大于 5， 比如等于 8。 由于数组递增，那么 索引为5的后面一定大于等于8， 即索引为6、7的地方一定不会是魔数，直接跳到8再判断
* 小于5， 此时不能判断任何东西，判读下一个索引，即6 是否是魔数

### 实现

```java
class Solution {
    public int findMagicIndex(int[] nums) {
        int index = 0;
        while (index < nums.length) {
            // 找到结果了，直接返回
            if (nums[index] == index) {
                return index;
            }
			
            // 满足第二种情况，索引直接跳到nums[index]
            if (nums[index] > index) {
                index = nums[index];
            } else {
                // 不能判断任何东西，继续下一个
                index += 1;
            }
        }
        return -1;
    }
}
```



## 08-04. 幂集

### 描述

[链接](https://leetcode-cn.com/problems/power-set-lcci/)

```
幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。

说明：解集不能包含重复的子集。
 输入： nums = [1,2,3]
 输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

```

### 分析

方法1：

典型的回溯。需要考虑的问题是：

* 本身集合不含重复的元素，那么就不用考虑顺序的问题。
* 结果集不能包含重复的元素，那么中间过程只用考虑后面的部分。比如第一个数为1， 已经包含了大部分情况，当寻找以 2 开头的结果的时候，不应该考虑1. 即  `2 1 3`一定会在 `1, 2, 3`之后找到，此时重复了。



方法2：

当1 和 2 都已经找到的时候，即 `[],[1], [2], [1,2]`， 加入只需要将每一个加入3即可，原来的还在，然后新增加入3的。

### 实现

```java
/**
	回溯
*/
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Deque<Integer> path = new LinkedList<>();

        dfs(nums, 0, ans, path);
        return ans;
    }

    private void dfs(int[] nums, int index, List<List<Integer>> ans, Deque<Integer> path) {
        ans.add(new ArrayList<>(path));
        for (int i = index; i < nums.length; i++) {
            path.push(nums[i]);
            dfs(nums, i + 1, ans, path);
            path.pop();  
        }
    }
}

/**
	方法2
*/
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(new ArrayList<>());
        for (int num : nums) {
            int preLength = ans.size();
            for (int i = 0; i < preLength; i++) {
                List<Integer> temp = new ArrayList<>(ans.get(i));
                temp.add(num);
                ans.add(temp);
            }
        }
        return ans;
    }

}
```



## 08-05. 递归乘法

### 描述

[链接](https://leetcode-cn.com/problems/recursive-mulitply-lcci/)

```
递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
 输入：A = 1, B = 10
 输出：10
```

### 分析

分治。乘法就是不断的加法。比如 10 * 6，可以不断划分下去

* `10 * 6 = 5 * 6 + 5 * 6`
* `5 * 6 = 2 * 6 + 2 * 6 + 6`

因此， 如果x是偶数，则求出 x / 2 * y 即可，然后两个加起来。

如果x 是偶数， 需要额外再加一个y。

使用递归实现：

### 实现

```java
class Solution {
    public int multiply(int A, int B) {
        if (A == 1) {
            return B;
        }
        int half = A >> 1;
        int extra = A - (half << 1);

        int subAns = multiply(half, B);
        return subAns + subAns + (extra == 1 ? B : 0);
    }
}
```



## 08-06. 汉诺塔问题

### 题目描述

[链接](https://leetcode-cn.com/problems/hanota-lcci/submissions/)

```
在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
```

### 分析

不考虑实现细节，考虑整体。要把A柱子上的n个圆盘移到C， 有个柱子B作为过渡。考虑如下步骤

* 将A柱子上的n-1个圆盘， 通过柱子C作为过渡，移到柱子B。 此时， A柱子上剩下一个圆盘， B柱子有n-1个， C为空。
* 将A柱子上剩下的最大的圆盘，移到C。此时， A柱子为空， B柱子还是n-1个， C柱子上1个
* 将B柱子上的n-1个圆盘通过柱子A过渡，移到C上。
* 流程结束

### 实现

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        move(A.size(), A, B, C);
    }
	
    /**
    	C是目的地， B是过渡
    */
    private void move(int n, List<Integer> A, List<Integer> B, List<Integer> C) {
        if (n == 1) {
            // 如果移动的个数为1， 将最上的一个直接移到目的地C
            C.add(A.remove(A.size() - 1));
            return;
        }

        // 将 n - 1个从A移动到B
        move(n - 1, A, C, B);

        // 将最底下一个移动到c
        C.add(A.remove(A.size() - 1));
        // 将B的所有移动到C
        move(n - 1, B, A, C);

    }
}
```



## 08-07. 无重复字符串的排列组合

### 描述

[链接](https://leetcode-cn.com/problems/permutation-i-lcci/)

```
无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。
 输入：S = "qwe"
 输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"]
```

### 分析

字符串的排列组合，和幂集的区别在于：幂集是不能重复的， 比如 `[1, 2, 3]` 和 `[2, 1, 3]`是一样的， 但是字符串 `abc`和`bac`不一样。因此大体思路一致， 区别在于需要一个 `visted`数组来标识哪些被用过了。

### 实现

```java
class Solution {
    public String[] permutation(String S) {
        List<String> ans = new ArrayList<>();
        if (S == null || S.length() == 0) {
            return new String[] {};
        }
        StringBuilder path = new StringBuilder();
        int length = S.length();
        boolean[] visted = new boolean[length];

        dfs(S, visted, ans, path);
        
        String[] stringArray = new String[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            stringArray[i] = ans.get(i);
        }
        return stringArray;
    }

    private void dfs(String s, boolean[] visted, List<String> ans, StringBuilder path) {

        if (path.length() == s.length()) {
            // 加入到结果集
            ans.add(path.toString());
            // System.out.println(ans);
            return;
        }

        for (int i = 0; i < s.length(); i++) {
            if (visted[i] == true) {
                // 该字符被用过了，跳过
                continue;
            }
            // 将该字符加入到路径中
            path.append(s.charAt(i));
            visted[i] = true; // 设置该字符被使用了
            dfs(s, visted, ans, path); // 继续找下一个字符
            path.deleteCharAt(path.length() - 1); // 回溯，路径中删除该字符
            visted[i] = false; // 将字符标识为没有被使用
        }

    }
}
```



## 08-08. 有重复字符串的排列组合

### 描述

[链接]()

```java
和上一题的唯一区别是， 字符可能存在重复。
```

### 分析

字符存在重复， 除了基本思路和上述一致外。需要额外考虑的是这种特殊情况：

当字符串前缀相同时，如果在当前位置两次遍历同一个字母就会导致重复。

### 实现

```java
class Solution {
    public String[] permutation(String S) {
        List<String> ans = new ArrayList<>();
        if (S == null || S.length() == 0) {
            return new String[]{};
        }
        StringBuilder sb = new StringBuilder();
        boolean[] used = new boolean[S.length()];

        dfs(S, ans, sb, used);

        return ans.toArray(new String[ans.size()]);

    }

    private void dfs(String s, List<String> ans, StringBuilder sb, boolean[] used) {
        if (sb.length() == s.length()) {
            // 加入结果
            ans.add(sb.toString());
            return;
        }

        for (int i = 0; i < s.length(); i++) {
            if (used[i] == true) {
                continue;
            }

            boolean valid = true; // 判断这个字符应不应该要
            for (int j = 0; j < i; j++) {
                if (s.charAt(j) == s.charAt(i) && used[j] == false) {
                    // 如果该字符和之前字符相同， 并且之前字符没有被用到，那么这次用到，一定会重复(如果要用，为什么不用之前的呢， 这种道理)
                    valid = false;
                }
            }
            if (valid == false) {
                // 冗余， 直接跳过
                continue;
            }
            
            // 后续步骤和之前一致

            sb.append(s.charAt(i));
            used[i] = true;
            dfs(s, ans, sb, used);
            sb.deleteCharAt(sb.length() - 1);
            used[i] = false;

        }


    }
}
```



## 08-09. 括号生成

### 题目描述

[链接](https://leetcode-cn.com/problems/bracket-lcci/)

```
括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。
说明：解集不能包含重复的子集。
例如，给出 n = 3，生成结果为：
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

### 分析

典型回溯，限制条件是剩下的左括号一定不能多于右括号。因此设定剩下的左括号和右括号为m和n

* 如果 `m = 0 && n = 0`， 找到一组合法的结果，加入结果集。
* 如果`m = n`， 此时只能先加左括号
* 如果`m < n`， 那么既可以加左括号，又可以加右括号。

### 实现

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        dfs(n, n, ans, sb);
        return ans;
    }

    public void dfs(int leftNum, int rightNum, List<String> ans, StringBuilder sb) {
        if (rightNum == 0 && leftNum == 0) {
            // 找到一组条件，加入结果集
            ans.add(sb.toString());
            return;
        }
        if (leftNum > rightNum) {
            // 如果左括号剩下的大于右边，是不合法的，直接返回
            return;
        }

        if (leftNum == rightNum) {
            // 只能加左括号
            sb.append("(");
            dfs(leftNum - 1, rightNum, ans, sb);
            sb.deleteCharAt(sb.length() - 1);

        } else {
            if (leftNum > 0) {
                // 先加左括号
                sb.append("(");
                dfs(leftNum - 1, rightNum, ans, sb);
                sb.deleteCharAt(sb.length() - 1);
            }
            // 再加右括号
            sb.append(")");
            dfs(leftNum, rightNum - 1, ans, sb);
            sb.deleteCharAt(sb.length() - 1);
            
        }
    }
}
```



## 08-10. 颜色填充

### 题目描述

[链接](https://leetcode-cn.com/problems/color-fill-lcci/)

```
编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。
待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的横坐标为 sr 纵坐标为 sc。需要填充的新颜色为 newColor 。
「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。
请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。
输入：
image = [[1,1,1],[1,1,0],[1,0,1]] 
sr = 1, sc = 1, newColor = 2
输出：[[2,2,2],[2,2,0],[2,0,1]]
解释: 
初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。
初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。
注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。
```

### 分析

回溯。深度优先遍历，目的 是找到和目标点相连的点。这类题需要注意的地方是：

* 如何标识已经访问过的地方。一种解决思路是构造一个同样大小的二维数组`visited`， 如果直接能够复用给定数组，就可以不用建数组。此题是可以复用的，即`newColor`的就标识为已经访问过

### 实现

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        if (image == null || image.length == 0) {
            return image;
        }
        dfs(image, sr, sc, image[sr][sc] ,newColor, image.length - 1, image[0].length - 1);
        return image;
    }

    private void dfs(int[][] image, int x, int y, int oldColor, int newColor, int row, int col) {
        if (x < 0 || x > row || y < 0 || y > col) {
            // 停止
            return;
        }

        if (image[x][y] == newColor || image[x][y] != oldColor) {
            // 已经被染色, 或者不需要被染色
            return;
        }
        image[x][y] = newColor;  // 染色，同时标识该点被访问过

        // 向四个方向深度优先遍历
        dfs(image, x - 1, y, oldColor, newColor, row, col);
        dfs(image, x + 1, y, oldColor, newColor, row, col);
        dfs(image, x, y - 1, oldColor, newColor, row, col);
        dfs(image, x, y + 1, oldColor, newColor, row, col);
    }
}
```



## 08-11. 硬币有多少种方式

### 题目描述

[链接](https://leetcode-cn.com/problems/coin-lcci/)

```
硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```

### 分析

先假设只有1分的，那么所有的都只有1种方式。

此时加入5分的，那么`count[i] = count[i - 5] + 之前的count[i]`

此时加入10分的， 那么`count[i] = count[i - 10] + 之前累计的count[i]`

此时加入25分的，......

### 实现

```java
class Solution {
    public int waysToChange(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        int[] values = {1, 5, 10, 25};
        for (int value : values) {
            for (int i = value; i <= n; i++) {
                dp[i] = (dp[i - value] + dp[i]) % 1000000007;
            }
        }
        // System.out.println(Arrays.toString(dp));
        return dp[n];
    }
}
```



## 10-01. 合并两个排序的数组

### 题目描述

[链接](https://leetcode-cn.com/problems/sorted-merge-lcci/)

```
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化 A 和 B 的元素数量分别为 m 和 n。
输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

### 分析

合并之后，总共会有 `m + n`个，那么从大找到小，不会影响到A和B之间的元素

* 先找到A和B最大的，插到第 `m + n`个位置处， 然后找倒数第二大的。插入的位置永远不会和A的索引冲突。

### 实现

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
      int index1 = m - 1;
      int index2 = n - 1;
      int location = m + n - 1;
      while (index1 >= 0 && index2 >= 0) {
          if (A[index1] >= B[index2]) {
              A[location] = A[index1];
              index1 -= 1;
              location -= 1;
          } else {
              A[location] = B[index2];
              index2 -= 1;
              location -= 1;
          }
      }

      while (index1 >= 0) {
          A[location] = A[index1];
          index1 -= 1;
          location -= 1;
      }

      while (index2 >= 0) {
          A[location] = B[index2];
          index2 -= 1;
          location -= 1;
      }
        
    }
}
```



## 10-02. 变位词组

### 描述

[链接](https://leetcode-cn.com/problems/group-anagrams-lcci/)

```
编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。
输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]

```

### 分析

维护一个`map`， `key` 是排序后的单词， `value` 是对应的列表。遍历字符串数组，每一个字符串，先对其排序，然后插入到对应的列表中， 如果`map`中不存在对应的`key`， 则加入到哈希表中。

### 实现

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> ans = new ArrayList<>();
        if (strs == null || strs.length == 0) {
            return ans;
        }

        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            // 排序
            char[] charArray = str.toCharArray();
            Arrays.sort(charArray);
            String key = new String(charArray);

            if (map.containsKey(key)) {
                map.get(key).add(str);
            } else {
                List<String> one = new ArrayList<>();
                one.add(str);
                map.put(key, one);
            }
        }

        for (String key : map.keySet()) {
            ans.add(map.get(key));
        }

        return ans;
    }
}
```



## 10-05. 搜索稀疏数组

### 题目描述

[链接](https://leetcode-cn.com/problems/sparse-array-search-lcci/)

```
稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。
 输入: words = ["at", "", "", "", "ball", "", "", "car", "", "","dad", "", ""], s = "ta"
 输出：-1
 说明: 不存在返回-1。
```

### 分析

因为数组排好序，肯定是用二分法。根据左右索引先找到中间索引，存在如下情况：

* mid的值大于target， 那么直接在左半边继续找。
* mid的值小于target， 那么在右半部分找
* mid的值等于target， 找到了，直接返回
* mid的值是空字符串，不知道在左边还是右边，都得找

### 实现

```java
class Solution {
    public int findString(String[] words, String s) {

        return findString(words, s, 0, words.length - 1);
    }

    private int findString(String[] words, String s, int left, int right) {
        if (left > right) {
            return -1;
        }

        int mid = (left + right) / 2;

        if (!"".equals(words[mid])) {
            if (s.equals(words[mid])) {
                return mid;
            } else if (s.compareTo(words[mid]) > 0) {
                return findString(words, s, mid + 1, right);
            } else {
                return findString(words, s, left, mid - 1);
            }
        } else {
            // 中间值是空字符串， 先找左边，左边找不到再找右边
            int leftAns = findString(words, s, left, mid - 1);
            if (leftAns != -1) {
                return leftAns;
            }
            return findString(words, s, mid + 1, right);
        }
    }
}
```



## 10-09. 搜索排序矩阵

### 题目描述

[链接](https://leetcode-cn.com/problems/sorted-matrix-search-lcci/)

```
给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

给定 target = 5，返回 true。
给定 target = 20，返回 false。
```

### 分析

从矩阵的左下角或者右上角开始。

* 当前值超出边界， 返回false
* 当前值等于目标，返回true
* 当前值大于目标值， 向上一行移动
* 当前值小于目标值， 向右一列移动，直到找到目标值

### 实现

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }

        int row = matrix.length - 1;
        int col = 0;
        while (row >= 0 && col <= matrix[0].length - 1) {
            if (matrix[row][col] == target) {
                return true;
            }
            if (target < matrix[row][col]) {
                row -= 1;
            } else {
                col += 1;
            }
        }
        return false;
    } 
}
```



## 16-01. 交换两个数字

### 题目描述

[链接](https://leetcode-cn.com/problems/swap-numbers-lcci/)

```
编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。
输入: numbers = [1,2]
输出: [2,1]
```

### 分析

使用异或，最好记住吧，没啥分析的

### 实现

```java
class Solution {
    public int[] swapNumbers(int[] numbers) {
        numbers[0] = numbers[0] ^ numbers[1];
        numbers[1] = numbers[0] ^ numbers[1];
        numbers[0] = numbers[0] ^ numbers[1];
        return numbers;
    }
}
```



## 16-05. 阶乘尾数有多少个0

### 题目描述

[链接](https://leetcode-cn.com/problems/factorial-zeros-lcci/)

```
设计一个算法，算出 n 阶乘有多少个尾随零。
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

### 分析

要出现一次0， 即出现一次乘以10， 由于是阶乘， 那么2的个数是远大于5的， 即乘因子有多少个5. 比如5，15，35有一个5， 25有两个5.

以227为例子， 首先计算，只能贡献一个5的个数，个数为 227/5 = 25个.(25也算作贡献了一个5)

然后再 算 227/5 = 25， 贡献了多少个5， 此时为 25 / 5 = 5个， （25在本轮又贡献了一个5）， 

然后计算 25 / 5 , 能够贡献1个5.

综上，意思就是， 能够贡献 3个 5的有1个， 能够贡献两个5或者三个5的有5个， 能够贡献1个或者2个或者3个5的有25个。

因此结论是 25 + 5 + 1 = 31

### 实现

```java
class Solution {
    public int trailingZeroes(int n) {
        // 有多少个5和5的倍数
        int count = 0;
        while (n > 0) {
            count += n / 5;
            n = n / 5;
        }

        return count;

    }
}
```



## 16-06. 最小差

### 题目描述

[链接](https://leetcode-cn.com/problems/smallest-difference-lcci/)

```
给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差
输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8}
输出： 3，即数值对(11, 8)
```

### 分析

因为不知道数字的排列规律，因此一定要先进行排序。然后类似于合并两个有序数组的思想流程，两个`index1, index2`

* 如果 `a[index1] <= b[index2]`， 移动`index1`
* 反之
* 期间维护一个全局最小差， 实时更新
* 需要考虑， 如果特别大的正数和特别小的负数做差，可能会超过int的范围

### 实现

```java
class Solution {
    public int smallestDifference(int[] a, int[] b) {
        Arrays.sort(a);
        Arrays.sort(b);

        int index1 = 0;
        int index2 = 0;

        long ans = Long.MAX_VALUE;
        while (index1 < a.length && index2 < b.length) {
            if (a[index1] <= b[index2]) {
                ans = Math.min((long)b[index2] - (long)a[index1], ans);
                index1 += 1;
            } else {
                ans = Math.min((long)a[index1] - (long)b[index2], ans);
                index2 += 1;
            }
        }
        return (int) ans;

    }
}
```



## 16-10. 生存人数

### 题目描述

[链接](https://leetcode-cn.com/problems/living-people-lcci/)

```
给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。

你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。
如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。

输入：
birth = {1900, 1901, 1950}
death = {1948, 1951, 2000}
输出： 1901
```

### 分析

要想得到生存人数最大的年份，那一定要知道每一年的人数，一种直观的思路是，每一个birth-death二元组， 都对其区间的每一年加1。但是复杂度太高。

遍历一次二元组， 在生的那一年 加1，表示该年增加1个人，在death的那一年 加 -1， 即减去1， 表示该年增加 -1个人。此时，只要知道前一年多少人，就知道这一年多少人，遍历增加人数的数组，采用前缀和的思想。然后同时实时更新结果

### 实现

```java
class Solution {
    public int maxAliveYear(int[] birth, int[] death) {
        int[] lives = new int[102];
        for (int year : birth) {
            lives[year - 1900] += 1; // 该年 增量 + 1
        }
        for (int year : death) {
            lives[year - 1900 + 1] -= 1; // 该年增量 -1
        }

        int ans = 0;
        int year = 0;
        int preSum = 0;
        for (int i = 1; i <= 100; i++) {
            preSum += lives[i]; // 记录前一年生存人数
            if (preSum > ans) {
                ans = preSum;
                year = i + 1900;
            }
        }
        return year;
    }
}
```



## 16-11. 跳水板

### 题目描述

[链接](https://leetcode-cn.com/problems/diving-board-lcci/)

```
你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
返回的长度需要从小到大排列。

输入：
shorter = 1
longer = 2
k = 3
输出： [3,4,5,6]
解释：
可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。

```

### 分析

考虑两种情况，如果短的和长的其实长度一样，那么输出只有一种情况，因为选谁都一样。

如果长度不一样， 那么有 `k + 1`中情况， 即长的选择可能是 0， 1， 2， 3， ... k， 共 `k + 1`种情况

### 实现

```java
class Solution {
    public int[] divingBoard(int shorter, int longer, int k) {
        if (k == 0) {
            return new int[] {};
        }
        if (shorter == longer) {
            return new int[] {k};
        }
        int total = k + 1;
        int[] ans = new int[total];
        int index = 0;
        for (int i = 0; i <= k; i++) {
            ans[index] = (k - i) * shorter + i * longer;
            index += 1;
        }
        return ans;
    }
}
```



## 16-16. 部分排序

### 题目描述

[链接](https://leetcode-cn.com/problems/sub-sort-lcci/)

```
给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。

输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]
输出： [3,9]
```

### 分析

以给定示例具体说明。 首先从左往右找到第一个不是排好顺序的地方，即  11 和 7这个衔接处。 然后从右往左找到第一个不是排好序的地方， 即 12 和 6这个衔接处。

由于找到了两个衔接处，那么  11 到 6这个范围， 一定需要重新排序， 这是暂时的m到n的窗口最小值。

但是窗口可能会更大，原因是， 这个暂时的窗口中， 可能存在比11之前的这些值还小的值，那么就要往左边扩散， 同理， 如果6之前的这些值，可以存在比6之后的值大的情况，此时，窗口需要向右扩散到对应的地方。

实现起来， 大概是， 遍历这个暂时的最短的窗口， 如果某个值小于m对应的地方， m向左扩散一个， 反之同理

### 实现

```java
class Solution {
    public int[] subSort(int[] array) {
        if (array == null || array.length <= 1) {
            return new int[] {-1, -1};
        }

        int m = 0;
        int n = array.length - 1;
        while (m < array.length - 1 && array[m + 1] >= array[m]) {
            m += 1;
        }

        while (n > 0 && array[n - 1] <= array[n]) {
            n -= 1;
        }

        // 找到初始窗口
        if (m > n) {
            return new int[] {-1, -1};
        }

        int left = m;
        int right = n;

        // 遍历这个窗口里面非排序的元素
        for (int i = left; i <= right; i++) {
            while (m > 0 && array[i] < array[m - 1]) {
                m -= 1;
            }

            while (n < array.length - 1 && array[i] > array[n + 1]) {
                n += 1;
            }
        }

        return new int[] {m, n};
    }
}
```



## 16-17. 连续数列的最大值

### 题目描述

[链接](https://leetcode-cn.com/problems/contiguous-sequence-lcci/)

```
给定一个整数数组，找出总和最大的连续数列，并返回总和。
输入： [-2,1,-3,4,-1,2,1,-5,4]
输出： 6
解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

### 分析

典型的动态规划， 假定`dp[i]`是所选数列的最后一个元素， 那么有两种情况

* `dp[i - 1] < 0`， 直接不要之前的数列， 只用当前元素
* 大于0， 加上之前的数列即可
* 可以优化空间复杂度， 不用构造dp数组

### 实现

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int ans = nums[0];

        for (int i = 1; i < nums.length; i++) {
            nums[i] = Math.max(nums[i - 1] + nums[i], nums[i]);
            ans = Math.max(ans, nums[i]);
        }

        return ans;
    }
}
```



## 16-19. 水域面积

### 题目描述

[链接](https://leetcode-cn.com/problems/pond-sizes-lcci/)

```
你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。

输入：
[
  [0,2,1,0],
  [0,1,0,1],
  [1,1,0,1],
  [0,1,0,1]
]
输出： [1,2,4]
```

### 分析

回溯，需要注意的是：

* 怎么标识被访问过的地方， 可以复用二维数组， 将访问过的地方设置为 -1， 表示被访问过.
* 需要注意对角线也必须要考虑

### 实现

```java
class Solution {
    public int[] pondSizes(int[][] land) {
        //
        List<Integer> ans = new ArrayList<>();
        if (land == null || land.length == 0) {
            return new int[] {};
        }

        int row = land.length - 1;
        int col = land[0].length - 1;

        for (int i = 0; i <= row; i++) {
            for (int j = 0; j <= col; j++) {
                int area = dfs(land, i, j, row, col);
                if (area > 0) {
                    ans.add(area);
                }
            }
        }
        // System.out.println(ans);
        
        int[] array = new int[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            array[i] = ans.get(i);
        }
        Arrays.sort(array);
        return array;
    }


    // 已经触及到的地方设置为-1
    private int dfs(int[][] land, int i, int j, int row, int col) {
        if (i < 0 || i > row || j < 0 || j > col) {
            return 0;
        }

        if (land[i][j] > 0) {
            // 构不成池塘
            return 0;
        }

        if (land[i][j] == -1) {
            // 约定的已经被使用过
            return 0;
        }

        int total = 1;
        land[i][j] = -1;

        total += dfs(land, i - 1, j, row, col);
        total += dfs(land, i + 1, j, row, col);
        total += dfs(land, i, j - 1, row, col);
        total += dfs(land, i, j + 1, row, col);

        total += dfs(land, i - 1, j - 1, row, col);
        total += dfs(land, i - 1, j + 1, row, col);
        total += dfs(land, i + 1, j - 1, row, col);
        total += dfs(land, i + 1, j + 1, row, col);

        return total;
    }
}
```



## 16-21. 交换和

### 题目描述

[链接](https://leetcode-cn.com/problems/sum-swap-lcci/)

```
给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。
返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。

输入: array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3]
输出: [1, 3]
```

### 分析

先求出两个数组的和， 如果两个数组的和  加起来是奇数，那么肯定不存在，直接返回。

遍历一个数组， 如果替换这个数组， 能否找到对应的解， 如何快速找到这个解，可以将另一个数组放到set中。

### 实现

```java
class Solution {
    public int[] findSwapValues(int[] array1, int[] array2) {
        Set<Integer> set = new HashSet<>();
        int sum1 = 0;
        int sum2 = 0;
        for (int num : array1) {
            sum1 += num;
        }
        for (int num : array2) {
            sum2 += num;
            set.add(num);
        }

        int total = sum1 + sum2;
        if (total % 2 == 1) {
            // 不存在
            return new int[] {};
        }
        int base = total / 2;

        for (int num : array1) {
            int target = base - (sum1 - num);
            if (set.contains(target)) {
                return new int[] {num, target};
            }
        }
        return new int[] {};

    }


}
```



## 16-24.数对和

### 题目描述

[链接](https://leetcode-cn.com/problems/pairs-with-sum-lcci/)

```
设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。
输入: nums = [5,6,5,6], target = 11
输出: [[5,6],[5,6]]
```

### 分析

简单思路，排序后使用前后双指针进行查找

### 实现

```java
class Solution {
    public List<List<Integer>> pairSums(int[] nums, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return ans;
        }
        
        Arrays.sort(nums);

        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum == target) {
                ans.add(Arrays.asList(nums[left], nums[right]));
                left += 1;
                right -= 1;
            } else if (sum > target) {
                right -= 1;
            } else {
                left += 1;
            }
        }
        return ans;
    }
}
```



## 16-26. 自己实现加减乘除

### 题目描述

[链接](https://leetcode-cn.com/problems/calculator-lcci/)

```
给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。
表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分

输入: " 3+5 / 2 "
输出: 5
```

### 分析

方法1， 模拟栈这个过程。从左到右遍历， 如果一个数字之前的符号是加号，则把上一个缓存的值加到结果中，减号同理。如果是乘号， 则继续更新这个缓存的值。

比如 `1 + 2 + 3 * 4  * 5 + 6 - 7`

* 首先，缓存第一个值是1， 当遇到2的时候， 2之前是加号，则把之前缓存的1加进去， 更新缓存值为2
* 第二部，遇到3的时候，3之前也是加号，则把缓存值2加到结果中，更新缓存值为3
* 第三步， 遇到4， 4之前是乘号， 更新缓存值为 12
* 第四步，遇到5， 5之前是乘号，更新缓存值为60
* 第五步，遇到6， 之前是加号，把缓存值60加到结果中，更新缓存值为6
* ......

方法2， 递归实现，思路看代码

### 实现

```java
class Solution {
    public int calculate(String s) {

        char flag = '+';
        int ans = 0;
        int subNum = 0;
        int index = 0;
        while (index < s.length()) {
            
            if (s.charAt(index) == ' ') {
                index += 1;
                continue;
            }

            int num = parseStrToInt(s, index);
            // System.out.println(" " + num);
            switch (flag) {
                case '+':
                    // 前一个操作符是 加，将上一个缓存的结果加进去
                    ans += subNum;
                    // 更新缓存结果
                    subNum = num;
                    break;
                case '-':
                    // 加和减基本一致，区别是正负问题
                    ans += subNum;
                    subNum = 0 - num;
                    break;
                case '*':
                    // 如果是乘法， 不能更新结果，因为可能没算完， 只用更新上一个缓存结果
                    subNum = subNum * num;
                    break;
                case '/':
                    // 除法同理
                    subNum = subNum / num;
                    break;
                default:
                    // 可以挡掉别的符号， 直接break，然后继续下一轮
                    break;
            }
            // 进行完上一次计算之后， 更新index
            if (index < s.length()) {
                flag = s.charAt(index);
            }
            
            index += 1;
        }

        // 最后一次还没算完
        ans += subNum;
        return ans;
        
    }

    private int parseStrToInt(String s, int index) {
        int num = 0;
        while (index < s.length()) {
            char c = s.charAt(index);
            if (c >= '0' && c <= '9') {
                // 是数字
                num = num * 10 + (c - '0');
                index += 1;
            } else {
                // 不是数字
                break;
            }
        }

        return num;
    }


}


/**
	方法2
*/
class Solution {
    public int calculate(String s) {

        return subCal(s, 0, s.length() - 1);
        
    }

    private int subCal(String s, int left, int right) {
        // 先通过 加 和减分为不同的部分
        
        // 必须从后往前， 注意以下
        for (int i = right; i >= left; i--) {
            if (s.charAt(i) == '+') {
                return subCal(s, left, i - 1) + subCal(s, i + 1, right);
            }
            if (s.charAt(i) == '-') {
                return subCal(s, left, i - 1) - subCal(s, i + 1, right);
            }
        }

        for (int i = right; i >= left; i--) {
            if (s.charAt(i) == '*') {
                return subCal(s, left, i - 1) * subCal(s, i + 1, right);
            }
            if (s.charAt(i) == '/') {
                return subCal(s, left, i - 1) / subCal(s, i + 1, right);
            }
        }

        // 一个符号都没有
        return parseStrToInt(s, left);
    }

    private int parseStrToInt(String s, int index) {
        int num = 0;
        while (index < s.length()) {
            char c = s.charAt(index);
            if (c == ' ') {
                index += 1;
                continue;
            }
            if (c >= '0' && c <= '9') {
                // 是数字
                num = num * 10 + (c - '0');
                index += 1;
            } else {
                // 不是数字
                break;
            }
        }

        return num;
    }


}
```



## 17-04. 消失的数字

### 题目描述

[链接](https://leetcode-cn.com/problems/missing-number-lcci/)

```
数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？
输入：[9,6,4,2,3,5,7,0,1]
输出：8
```

### 分析

一种简单的思路，是求和，然后和预期的sum做减法。

更好的思路是利用异或的特性， `x ^ y ^ y = x`， 即一个数和另一个数两次异或，结果还是本身。

遍历一次数组，同时和索引和对应的值进行异或，如果存在的话，会经过两次异或。如果缺失的值，只会和他的索引异或

### 实现

```java
class Solution {
    public int missingNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            ans = ans ^ i;
            ans = ans ^ nums[i];
        }
        ans = ans ^ nums.length;
        return ans;
    }
}

/**
	思路2， 求和
*/
class Solution {
    public int missingNumber(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return (nums.length) * (nums.length + 1) / 2 - sum;
    }
}
```

 

## 17-05. 字母与数字

### 题目描述

[链接](https://leetcode-cn.com/problems/find-longest-subarray-lcci/)

```
给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。
返回该子数组，若存在多个最长子数组，返回左端点最小的。若不存在这样的数组，返回一个空数组。

输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]
输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]
```

### 分析

从左到右，如果是字符，count加1， 如果是数字，count减一。因此，如果要某个区间字符和数字个数相等，只需要两个count相等即可。简单得前缀和思想。比如，索引为5的count为3，索引为100的count为3，那么这个区间的供需平衡。

即变成了，求数组中两个相同值的最小间隔，可以两次遍历，也可以用Hash进行缓存。key是count， value是最小的索引。实时更新结果

### 实现

```java
class Solution {
    public String[] findLongestSubarray(String[] array) {
        Map<Integer, Integer> map = new HashMap<>();
        int count = 0;
        map.put(0, -1);  // count为0， 从最初开始，设置虚拟索引为 -1
        int maxLength = 0;
        int left = -1;
        int right = -1;
        for (int i = 0; i < array.length; i++) {
            if (isCharacter(array[i]) == true) {
                // 是字符
                count += 1;
            } else {
                count -= 1;
            }

            if (map.containsKey(count)) {
                // 存在一个相同的count， 说明左边有合适的
                if (i - map.get(count) > maxLength) {
                    // 找到一个更长的
                    left = map.get(count);
                    right = i;
                    maxLength = right - left;
                }
            } else {
                map.put(count, i);
            }
        }

        String[] ans = new String[right - left];
        int index = 0;
        for (int i = left + 1; i <= right; i++) {
            ans[index] = array[i];
            index += 1; 
        }
        return ans;
    }

    private boolean isCharacter(String str) {
        char c = str.charAt(0);
        if (c >= 'A' && c <= 'Z') {
            return true;
        }
        if (c >= 'a' && c <= 'z') {
            return true;
        }
        return false;
    }
}
```



## 17-09. 第k个素数

### 题目描述

[链接](https://leetcode-cn.com/problems/get-kth-magic-number-lcci/)

```
有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。

输入: k = 5
输出: 9
```

### 分析

采用动态规划一个一个找，根据已有的找下一个最小的。因为只能是之前的值 乘以  3、5、7.看代码吧

### 实现

```java
class Solution {
    public int getKthMagicNumber(int k) {
        int[] dp = new int[k + 1];
        dp[1] = 1;
        int index1 = 1, index2 = 1, index3 = 1;
        for (int i = 2; i <= k; i++) {
            int minValue = Math.min(dp[index1] * 3, Math.min(dp[index2] * 5, dp[index3] * 7));
            dp[i] = minValue;

            // 三个 if 不能是 if-else， 因为可能存在重复的可能，必须都加1， 否则出现重复
            // 比如 15， 可以是3 * 5, 也可以是5 * 3, 必须保证不重复
            if (minValue == dp[index1] * 3) {
                index1 += 1;
            } 

            if (minValue == dp[index2] * 5) {
                index2 += 1;
            }

            if (minValue == dp[index3] * 7) {
                index3 += 1;
            }
        }

        return dp[k];

    }
}
```



## 17-10. 数组中超过一半的元素

### 题目描述

[链接](https://leetcode-cn.com/problems/find-majority-element-lcci/)

```
数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。
输入：[1,2,5,9,5,9,5,5,5]
输出：5
```

### 分析

采用选举投票法，如果当前值和之前一致，加一票， 否则减一票。如果票数变为0了， 更新候选人。一直得到最终的结果。

因为可能不存在，所以需要验证

### 实现

```java
class Solution {
    public int majorityElement(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        
        int vote = 1;  // 初始候选人有1票
        int base = nums[0];  // 候选人设置为第一个人

        for (int i = 1; i < nums.length; i++) {
            if (vote == 0) {
            	// 候选人得票不足一半了，换下一个候选人
                vote = 1;
                base = nums[i];
                continue;
            }
			
			// 的票 + 1
            if (nums[i] == base) {
                vote += 1;
            } else {
            	// 的票 -1
                vote -= 1;
            }

        }

        // 验证， 因为可能不存在
        int count = 0;
        for (int num : nums) {
            if (num == base) {
                count += 1;
            } else {
                count -= 1;
            }
        }

        return count > 0 ? base : -1;
    }
}
```



## 17-11. 文本中两个单词的最小距离

### 题目描述

[链接](https://leetcode-cn.com/problems/find-closest-lcci/)

```
有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?

输入：words = ["I","am","a","student","from","a","university","in","a","city"], word1 = "a", word2 = "student"
输出：1

```

### 分析

从左到右遍历。设index1是第一个单词的最新的索引，index2是第二个单词的。找到一个，得到一次距离，实时更新最小距离即可。

代码并没有针对重复多次调用优化

### 实现

```java
class Solution {
    public int findClosest(String[] words, String word1, String word2) {
        int index1 = -1;
        int index2 = -1;
        int minLength = Integer.MAX_VALUE;
        for (int i = 0; i < words.length; i++) {
            if (word1.equals(words[i])) {
                if (index2 == -1) {
                    index1 = i;
                } else {
                    index1 = i;
                    minLength = Math.min(index1 - index2, minLength);
                }
            } else if (word2.equals(words[i])) {
                if (index1 == -1) {
                    index2 = i;
                } else {
                    index2 = i;
                    minLength = Math.min(index2 - index1, minLength);
                }
            } 
        }

        return minLength;
    }
}
```



## 17-12. 二叉搜索树原地改变为单链表

### 题目描述

[链接](https://leetcode-cn.com/problems/binode-lcci/)

```
二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。
返回转换后的单向链表的头节点。

输入： [4,2,5,1,3,null,6,0]
输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]
```

### 分析

一种直观的思路是，找到左子树的头节点和尾巴节点，然后左子树的尾巴指向root。同理，得到右子树的头部和尾巴，root指向右子树的头部。（尾巴的意思，是最后一个有值的节点，而不是null节点）

方式二： 或者使用全局变量，这种方式一定要使用类的全局变量.（值传递?太难了吧），方式二不使用全局变量是错误的

### 实现

```java
class Solution {
    public TreeNode convertBiNode(TreeNode root) {
        return getHeadAndTail(root)[0];
    }
	
    // 返回一个长度为2的数组，第一个为head， 第二个为tail
    private TreeNode[] getHeadAndTail(TreeNode root) {
        TreeNode[] ans = new TreeNode[2];
        if (root == null) {
            ans[0] = null;
            ans[1] = null;
            return ans;
        }

        TreeNode[] leftAns = getHeadAndTail(root.left);
        TreeNode[] rightAns = getHeadAndTail(root.right);

        if (root.left == null && root.right == null) {
            // 
            ans[0] = root;
            ans[1] = root;
        } else if (root.left == null) {
            // 如果左子树为空，返回的头部是root， 尾巴是右子树的尾巴
            root.right = rightAns[0];
            ans[0] = root;
            ans[1] = rightAns[1];
        } else if (root.right == null) {
            root.left = null;
            leftAns[1].right = root;
            ans[0] = leftAns[0];
            ans[1] = root;
        } else {
            root.left = null;
            root.right = null;
            leftAns[1].right = root;
            root.right = rightAns[0];
            ans[0] = leftAns[0];
            ans[1] = rightAns[1];
        }

        return ans;  
    }
}


/**
	方法2
*/
class Solution {
    TreeNode preHead = new TreeNode();
    TreeNode tail = null;
    public TreeNode convertBiNode(TreeNode root) {
        helper(root);
        return preHead.right;
    }

    private void helper(TreeNode root) {
        if (root == null) {
            return;
        }

        helper(root.left);
        if (tail == null) {
            // 左边的tail为空，说明左子树为空
            preHead.right = root;
            tail = root;  // root和左子树加起来的尾巴
        } else {
            tail.right = root;
            tail = root;
        }
        root.left = null;  // 先把root的左边清空


        // 至此， preHead一定不会再修改了，因为tail不为空，所以这一定是头节点的preHead;
        helper(root.right);
    }

}
```



## 17-14. 数组中最小的K个数

### 题目描述

[链接](https://leetcode-cn.com/problems/smallest-k-lcci/)

```
设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
输入： arr = [1,3,5,7,2,4,6,8], k = 4
输出： [1,2,3,4]
```

### 分析

一趟快排之后，能够得到一个index， 使得左边的全部小于他， 右边的全部大于他。

* 如果index 等于 k, ok, 已经得出结论了。
* index 大于k， 在左边继续找
* 反之在右边继续找

### 实现

```java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        
        quickSortOnce(arr, 0, arr.length - 1, k);
        return getAns(arr, k);
        
    }

    private void quickSortOnce(int[] nums, int startIndex, int endIndex, int k) {
        //一趟快排 
        
        if (startIndex >= endIndex) {
            return;
        }

        int key = nums[startIndex];
        int left = startIndex;
        int right = endIndex;

        while (left < right) {
            while (left < right && nums[right] >= key) {
                right -= 1;
            }

            sawp(nums, left, right);

            while (left < right && nums[left] <= key) {
                left += 1;
            }
            sawp(nums, left, right);
        }

        if (left == k) {
            // 找到了，停止吧
            return;
        } else if (left > k) {
            // 在左边继续一躺快排
            quickSortOnce(nums, startIndex, left - 1, k);
        } else {
            quickSortOnce(nums, left + 1, endIndex, k);
        }

    }


    
    
    private void sawp(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private int[] getAns(int[] nums, int k) {
        int[] ans = new int[k];
        for (int i = 0; i < k; i++) {
            ans[i] = nums[i];
        }
        return ans;
    }
}
```



## 17-16. 按摩师的最大收益（和打家劫舍一样）

### 题目描述

[链接](https://leetcode-cn.com/problems/the-masseuse-lcci/)

```
一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。

```

### 分析

和打家劫舍一样，参考动态规划-打家劫舍

### 实现

```java
class Solution {
    public int massage(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int[] dp = new int[nums.length + 1];
        dp[1] = nums[0];
        for (int i = 2; i <= nums.length; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
        }
        return dp[nums.length];
    }
}
```

