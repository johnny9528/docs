# 面试金典

## 1. 移除链表中重复节点

### 描述

[链接](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

```
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
 
链表长度在[0, 20000]范围内。
链表元素在[0, 20000]范围内。
```

### 分析

最简单的思路，使用`haseSet`保存之前出现的值。或者两次循环暴力求解。

一种更好的方式是， 使用位运算来保存之前出现的值, 这样一个数字可以保存32个信息

### 实现

```java
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        int[] nums = new int[20000 / 32 + 1];
        ListNode preHead = new ListNode();
        ListNode preHeadDumpy = preHead;

        while (head != null) {
            int index = head.val / 32;
            int extra = head.val % 32;

            if ((nums[index] & (1 << extra)) != 0) {
                // 出现重复
                head = head.next;
                preHead.next = null;
            } else {
                nums[index] = nums[index] | (1 << extra);
                preHead.next = head;
                head = head.next;
                preHead = preHead.next;
                preHead.next = null;
            }
        }

        return preHeadDumpy.next;
    }
}
```





## 08-01. 三步问题

### 描述

[链接](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

```
三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
 输入：n = 3 
 输出：4
 说明: 有四种走法
```

### 分析

典型的动态规划，当前状态等于之前三个状态的总和。

可以优化空间复杂度, 不优化更好理解

也可以采用递归，至上而下，动态规划是空间换时间

### 实现

```java
class Solution {
    public int waysToStep(int n) {
        if (n <= 2) return n;
        int[] dp = new int[n + 1];
        dp[n] = 1;
        dp[n - 1] = 2;
        dp[n - 2] = 4;
        for (int i = n - 3; i > 0; i--) {
            dp[i] = (dp[i + 1] + dp[i + 2]) % 1000000007 + dp[i + 3];
            dp[i] = dp[i] % 1000000007;
        }
        return dp[1];

    }
}
```



## 08-02. 迷路的机器人

### 描述

[链接](https://leetcode-cn.com/problems/robot-in-a-grid-lcci/)

```
设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。
网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
解释: 
输入中标粗的位置即为输出表示的路径，即
0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）
```

### 分析

这是一个典型的回溯。但是需要注意的是：

* 只用找到一条路径即可，即找到一条路径就不用继续回溯了。因此`dfs`的返回值一定需要标识是否已经找到结果。如果找到结果，直接返回，否则，继续`dfs`
* 由于只能往右或者往下走，不需要一个全局的 `visted`来标识哪些地方已经访问过。
* 减枝， 如果某个点已经确定无法到达重点，那么该点和障碍其实是一样的，将该点标识为障碍，避免重复计算该点

### 实现

```java
class Solution {
    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {

        List<List<Integer>> ans = new ArrayList<>();
        if (obstacleGrid == null || obstacleGrid.length == 0) {
            return ans;
        }
        int row = obstacleGrid.length - 1;
        int col = obstacleGrid[0].length - 1;
        if (obstacleGrid[row][col] == 1) {
            return ans;
        }


        dfs(obstacleGrid, ans, 0, 0, obstacleGrid.length - 1, obstacleGrid[0].length - 1);
        return ans;

    }
    private boolean dfs(int[][] nums, List<List<Integer>> ans, int i, int j, int row, int col) {
        if (i == row && j == col) {
            // 得到一个结果, 加入结果，返回true， 表示已经得到最终结果，后续不需要再遍历了。
            List<Integer> location = new ArrayList<>();
            location.add(i);
            location.add(j);
            ans.add(location);
            return true;
        }
        // 超出边界或者遇到障碍物，返回false， 表示此路不通
        if (i == row + 1 || j == col + 1 || nums[i][j] == 1) {
            return false;
        }
		
        // 将该点加入到路径中
        List<Integer> location = new ArrayList<>();
        location.add(i);
        location.add(j);
        ans.add(location);
        
        // 尝试往右走，返回往右是否有路径到达
        boolean isTrue = dfs(nums, ans, i, j + 1, row, col);
        if (isTrue == true) {
            // 往右已经有路径到达了，不用回溯和尝试了，直接返回结果
            return true;
        }
        
        // 往右走，没有路径到达，尝试往下走
        isTrue = dfs(nums, ans, i + 1, j, row, col);
        if (isTrue == true) {
            // 往下走，有路径到达，返回正确结果
            return true;
        }
        
        // 往右和往下都没有路径到达，回溯，删除刚才加入路径的点
        ans.remove(ans.size() - 1);
        nums[i][j] = 1;  // 减枝，很关键，标时这个点无法到达终点，即和障碍一样，标时为障碍
        return false;
    }
}
```



## 08-03. 魔术索引

### 描述

[链接](https://leetcode-cn.com/problems/magic-index-lcci/)

```
魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

输入：nums = [0, 2, 3, 4, 5]
输出：0
说明: 0下标的元素为0
```

### 分析

关键信息： 魔术索引是 索引等于当前值的索引、数组有序。

因为数组有序，比如说遍历到索引为`5`的地方， `nums[5]` 的值有以下几种情况：

* 等于5， 那么找到第一个魔术了，直接返回。
* 大于 5， 比如等于 8。 由于数组递增，那么 索引为5的后面一定大于等于8， 即索引为6、7的地方一定不会是魔数，直接跳到8再判断
* 小于5， 此时不能判断任何东西，判读下一个索引，即6 是否是魔数

### 实现

```java
class Solution {
    public int findMagicIndex(int[] nums) {
        int index = 0;
        while (index < nums.length) {
            // 找到结果了，直接返回
            if (nums[index] == index) {
                return index;
            }
			
            // 满足第二种情况，索引直接跳到nums[index]
            if (nums[index] > index) {
                index = nums[index];
            } else {
                // 不能判断任何东西，继续下一个
                index += 1;
            }
        }
        return -1;
    }
}
```



## 08-04. 幂集

### 描述

[链接](https://leetcode-cn.com/problems/power-set-lcci/)

```
幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。

说明：解集不能包含重复的子集。
 输入： nums = [1,2,3]
 输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

```

### 分析

方法1：

典型的回溯。需要考虑的问题是：

* 本身集合不含重复的元素，那么就不用考虑顺序的问题。
* 结果集不能包含重复的元素，那么中间过程只用考虑后面的部分。比如第一个数为1， 已经包含了大部分情况，当寻找以 2 开头的结果的时候，不应该考虑1. 即  `2 1 3`一定会在 `1, 2, 3`之后找到，此时重复了。



方法2：

当1 和 2 都已经找到的时候，即 `[],[1], [2], [1,2]`， 加入只需要将每一个加入3即可，原来的还在，然后新增加入3的。

### 实现

```java
/**
	回溯
*/
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Deque<Integer> path = new LinkedList<>();

        dfs(nums, 0, ans, path);
        return ans;
    }

    private void dfs(int[] nums, int index, List<List<Integer>> ans, Deque<Integer> path) {
        ans.add(new ArrayList<>(path));
        for (int i = index; i < nums.length; i++) {
            path.push(nums[i]);
            dfs(nums, i + 1, ans, path);
            path.pop();  
        }
    }
}

/**
	方法2
*/
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(new ArrayList<>());
        for (int num : nums) {
            int preLength = ans.size();
            for (int i = 0; i < preLength; i++) {
                List<Integer> temp = new ArrayList<>(ans.get(i));
                temp.add(num);
                ans.add(temp);
            }
        }
        return ans;
    }

}
```



## 08-05. 递归乘法

### 描述

[链接](https://leetcode-cn.com/problems/recursive-mulitply-lcci/)

```
递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。
 输入：A = 1, B = 10
 输出：10
```

### 分析

分治。乘法就是不断的加法。比如 10 * 6，可以不断划分下去

* `10 * 6 = 5 * 6 + 5 * 6`
* `5 * 6 = 2 * 6 + 2 * 6 + 6`

因此， 如果x是偶数，则求出 x / 2 * y 即可，然后两个加起来。

如果x 是偶数， 需要额外再加一个y。

使用递归实现：

### 实现

```java
class Solution {
    public int multiply(int A, int B) {
        if (A == 1) {
            return B;
        }
        int half = A >> 1;
        int extra = A - (half << 1);

        int subAns = multiply(half, B);
        return subAns + subAns + (extra == 1 ? B : 0);
    }
}
```



## 08-06. 汉诺塔问题

### 题目描述

[链接](https://leetcode-cn.com/problems/hanota-lcci/submissions/)

```
在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
```

### 分析

不考虑实现细节，考虑整体。要把A柱子上的n个圆盘移到C， 有个柱子B作为过渡。考虑如下步骤

* 将A柱子上的n-1个圆盘， 通过柱子C作为过渡，移到柱子B。 此时， A柱子上剩下一个圆盘， B柱子有n-1个， C为空。
* 将A柱子上剩下的最大的圆盘，移到C。此时， A柱子为空， B柱子还是n-1个， C柱子上1个
* 将B柱子上的n-1个圆盘通过柱子A过渡，移到C上。
* 流程结束

### 实现

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        move(A.size(), A, B, C);
    }
	
    /**
    	C是目的地， B是过渡
    */
    private void move(int n, List<Integer> A, List<Integer> B, List<Integer> C) {
        if (n == 1) {
            // 如果移动的个数为1， 将最上的一个直接移到目的地C
            C.add(A.remove(A.size() - 1));
            return;
        }

        // 将 n - 1个从A移动到B
        move(n - 1, A, C, B);

        // 将最底下一个移动到c
        C.add(A.remove(A.size() - 1));
        // 将B的所有移动到C
        move(n - 1, B, A, C);

    }
}
```



## 08-07. 无重复字符串的排列组合

### 描述

[链接](https://leetcode-cn.com/problems/permutation-i-lcci/)

```
无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。
 输入：S = "qwe"
 输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"]
```

### 分析

字符串的排列组合，和幂集的区别在于：幂集是不能重复的， 比如 `[1, 2, 3]` 和 `[2, 1, 3]`是一样的， 但是字符串 `abc`和`bac`不一样。因此大体思路一致， 区别在于需要一个 `visted`数组来标识哪些被用过了。

### 实现

```java
class Solution {
    public String[] permutation(String S) {
        List<String> ans = new ArrayList<>();
        if (S == null || S.length() == 0) {
            return new String[] {};
        }
        StringBuilder path = new StringBuilder();
        int length = S.length();
        boolean[] visted = new boolean[length];

        dfs(S, visted, ans, path);
        
        String[] stringArray = new String[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            stringArray[i] = ans.get(i);
        }
        return stringArray;
    }

    private void dfs(String s, boolean[] visted, List<String> ans, StringBuilder path) {

        if (path.length() == s.length()) {
            // 加入到结果集
            ans.add(path.toString());
            // System.out.println(ans);
            return;
        }

        for (int i = 0; i < s.length(); i++) {
            if (visted[i] == true) {
                // 该字符被用过了，跳过
                continue;
            }
            // 将该字符加入到路径中
            path.append(s.charAt(i));
            visted[i] = true; // 设置该字符被使用了
            dfs(s, visted, ans, path); // 继续找下一个字符
            path.deleteCharAt(path.length() - 1); // 回溯，路径中删除该字符
            visted[i] = false; // 将字符标识为没有被使用
        }

    }
}
```



## 08-08. 有重复字符串的排列组合

### 描述

[链接]()

```java
和上一题的唯一区别是， 字符可能存在重复。
```

### 分析

字符存在重复， 除了基本思路和上述一致外。需要额外考虑的是这种特殊情况：

当字符串前缀相同时，如果在当前位置两次遍历同一个字母就会导致重复。

### 实现

```java
class Solution {
    public String[] permutation(String S) {
        List<String> ans = new ArrayList<>();
        if (S == null || S.length() == 0) {
            return new String[]{};
        }
        StringBuilder sb = new StringBuilder();
        boolean[] used = new boolean[S.length()];

        dfs(S, ans, sb, used);

        return ans.toArray(new String[ans.size()]);

    }

    private void dfs(String s, List<String> ans, StringBuilder sb, boolean[] used) {
        if (sb.length() == s.length()) {
            // 加入结果
            ans.add(sb.toString());
            return;
        }

        for (int i = 0; i < s.length(); i++) {
            if (used[i] == true) {
                continue;
            }

            boolean valid = true; // 判断这个字符应不应该要
            for (int j = 0; j < i; j++) {
                if (s.charAt(j) == s.charAt(i) && used[j] == false) {
                    // 如果该字符和之前字符相同， 并且之前字符没有被用到，那么这次用到，一定会重复(如果要用，为什么不用之前的呢， 这种道理)
                    valid = false;
                }
            }
            if (valid == false) {
                // 冗余， 直接跳过
                continue;
            }
            
            // 后续步骤和之前一致

            sb.append(s.charAt(i));
            used[i] = true;
            dfs(s, ans, sb, used);
            sb.deleteCharAt(sb.length() - 1);
            used[i] = false;

        }


    }
}
```



## 08-09. 括号生成

### 题目描述

[链接](https://leetcode-cn.com/problems/bracket-lcci/)

```
括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。
说明：解集不能包含重复的子集。
例如，给出 n = 3，生成结果为：
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

### 分析

典型回溯，限制条件是剩下的左括号一定不能多于右括号。因此设定剩下的左括号和右括号为m和n

* 如果 `m = 0 && n = 0`， 找到一组合法的结果，加入结果集。
* 如果`m = n`， 此时只能先加左括号
* 如果`m < n`， 那么既可以加左括号，又可以加右括号。

### 实现

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        dfs(n, n, ans, sb);
        return ans;
    }

    public void dfs(int leftNum, int rightNum, List<String> ans, StringBuilder sb) {
        if (rightNum == 0 && leftNum == 0) {
            // 找到一组条件，加入结果集
            ans.add(sb.toString());
            return;
        }
        if (leftNum > rightNum) {
            // 如果左括号剩下的大于右边，是不合法的，直接返回
            return;
        }

        if (leftNum == rightNum) {
            // 只能加左括号
            sb.append("(");
            dfs(leftNum - 1, rightNum, ans, sb);
            sb.deleteCharAt(sb.length() - 1);

        } else {
            if (leftNum > 0) {
                // 先加左括号
                sb.append("(");
                dfs(leftNum - 1, rightNum, ans, sb);
                sb.deleteCharAt(sb.length() - 1);
            }
            // 再加右括号
            sb.append(")");
            dfs(leftNum, rightNum - 1, ans, sb);
            sb.deleteCharAt(sb.length() - 1);
            
        }
    }
}
```



## 08-10. 颜色填充

### 题目描述

[链接](https://leetcode-cn.com/problems/color-fill-lcci/)

```
编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。
待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的横坐标为 sr 纵坐标为 sc。需要填充的新颜色为 newColor 。
「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。
请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。
输入：
image = [[1,1,1],[1,1,0],[1,0,1]] 
sr = 1, sc = 1, newColor = 2
输出：[[2,2,2],[2,2,0],[2,0,1]]
解释: 
初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。
初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。
注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。
```

### 分析

回溯。深度优先遍历，目的 是找到和目标点相连的点。这类题需要注意的地方是：

* 如何标识已经访问过的地方。一种解决思路是构造一个同样大小的二维数组`visited`， 如果直接能够复用给定数组，就可以不用建数组。此题是可以复用的，即`newColor`的就标识为已经访问过

### 实现

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        if (image == null || image.length == 0) {
            return image;
        }
        dfs(image, sr, sc, image[sr][sc] ,newColor, image.length - 1, image[0].length - 1);
        return image;
    }

    private void dfs(int[][] image, int x, int y, int oldColor, int newColor, int row, int col) {
        if (x < 0 || x > row || y < 0 || y > col) {
            // 停止
            return;
        }

        if (image[x][y] == newColor || image[x][y] != oldColor) {
            // 已经被染色, 或者不需要被染色
            return;
        }
        image[x][y] = newColor;  // 染色，同时标识该点被访问过

        // 向四个方向深度优先遍历
        dfs(image, x - 1, y, oldColor, newColor, row, col);
        dfs(image, x + 1, y, oldColor, newColor, row, col);
        dfs(image, x, y - 1, oldColor, newColor, row, col);
        dfs(image, x, y + 1, oldColor, newColor, row, col);
    }
}
```



## 08-11. 硬币有多少种方式

### 题目描述

[链接](https://leetcode-cn.com/problems/coin-lcci/)

```
硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```

### 分析

先假设只有1分的，那么所有的都只有1种方式。

此时加入5分的，那么`count[i] = count[i - 5] + 之前的count[i]`

此时加入10分的， 那么`count[i] = count[i - 10] + 之前累计的count[i]`

此时加入25分的，......

### 实现

```java
class Solution {
    public int waysToChange(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        int[] values = {1, 5, 10, 25};
        for (int value : values) {
            for (int i = value; i <= n; i++) {
                dp[i] = (dp[i - value] + dp[i]) % 1000000007;
            }
        }
        // System.out.println(Arrays.toString(dp));
        return dp[n];
    }
}
```



## 10-01. 合并两个排序的数组

### 题目描述

[链接](https://leetcode-cn.com/problems/sorted-merge-lcci/)

```
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化 A 和 B 的元素数量分别为 m 和 n。
输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

### 分析

合并之后，总共会有 `m + n`个，那么从大找到小，不会影响到A和B之间的元素

* 先找到A和B最大的，插到第 `m + n`个位置处， 然后找倒数第二大的。插入的位置永远不会和A的索引冲突。

### 实现

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
      int index1 = m - 1;
      int index2 = n - 1;
      int location = m + n - 1;
      while (index1 >= 0 && index2 >= 0) {
          if (A[index1] >= B[index2]) {
              A[location] = A[index1];
              index1 -= 1;
              location -= 1;
          } else {
              A[location] = B[index2];
              index2 -= 1;
              location -= 1;
          }
      }

      while (index1 >= 0) {
          A[location] = A[index1];
          index1 -= 1;
          location -= 1;
      }

      while (index2 >= 0) {
          A[location] = B[index2];
          index2 -= 1;
          location -= 1;
      }
        
    }
}
```



## 10-02. 变位词组

### 描述

[链接](https://leetcode-cn.com/problems/group-anagrams-lcci/)

```
编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。
输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]

```

### 分析

维护一个`map`， `key` 是排序后的单词， `value` 是对应的列表。遍历字符串数组，每一个字符串，先对其排序，然后插入到对应的列表中， 如果`map`中不存在对应的`key`， 则加入到哈希表中。

### 实现

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> ans = new ArrayList<>();
        if (strs == null || strs.length == 0) {
            return ans;
        }

        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            // 排序
            char[] charArray = str.toCharArray();
            Arrays.sort(charArray);
            String key = new String(charArray);

            if (map.containsKey(key)) {
                map.get(key).add(str);
            } else {
                List<String> one = new ArrayList<>();
                one.add(str);
                map.put(key, one);
            }
        }

        for (String key : map.keySet()) {
            ans.add(map.get(key));
        }

        return ans;
    }
}
```



## 10-05. 搜索稀疏数组

### 题目描述

[链接](https://leetcode-cn.com/problems/sparse-array-search-lcci/)

```
稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。
 输入: words = ["at", "", "", "", "ball", "", "", "car", "", "","dad", "", ""], s = "ta"
 输出：-1
 说明: 不存在返回-1。
```

### 分析

因为数组排好序，肯定是用二分法。根据左右索引先找到中间索引，存在如下情况：

* mid的值大于target， 那么直接在左半边继续找。
* mid的值小于target， 那么在右半部分找
* mid的值等于target， 找到了，直接返回
* mid的值是空字符串，不知道在左边还是右边，都得找

### 实现

```java
class Solution {
    public int findString(String[] words, String s) {

        return findString(words, s, 0, words.length - 1);
    }

    private int findString(String[] words, String s, int left, int right) {
        if (left > right) {
            return -1;
        }

        int mid = (left + right) / 2;

        if (!"".equals(words[mid])) {
            if (s.equals(words[mid])) {
                return mid;
            } else if (s.compareTo(words[mid]) > 0) {
                return findString(words, s, mid + 1, right);
            } else {
                return findString(words, s, left, mid - 1);
            }
        } else {
            // 中间值是空字符串， 先找左边，左边找不到再找右边
            int leftAns = findString(words, s, left, mid - 1);
            if (leftAns != -1) {
                return leftAns;
            }
            return findString(words, s, mid + 1, right);
        }
    }
}
```

