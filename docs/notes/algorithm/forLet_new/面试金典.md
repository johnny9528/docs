# 面试金典

## 1. 移除链表中重复节点

### 描述

[链接](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

```
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
 
链表长度在[0, 20000]范围内。
链表元素在[0, 20000]范围内。
```

### 分析

最简单的思路，使用`haseSet`保存之前出现的值。或者两次循环暴力求解。

一种更好的方式是， 使用位运算来保存之前出现的值, 这样一个数字可以保存32个信息

### 实现

```java
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        int[] nums = new int[20000 / 32 + 1];
        ListNode preHead = new ListNode();
        ListNode preHeadDumpy = preHead;

        while (head != null) {
            int index = head.val / 32;
            int extra = head.val % 32;

            if ((nums[index] & (1 << extra)) != 0) {
                // 出现重复
                head = head.next;
                preHead.next = null;
            } else {
                nums[index] = nums[index] | (1 << extra);
                preHead.next = head;
                head = head.next;
                preHead = preHead.next;
                preHead.next = null;
            }
        }

        return preHeadDumpy.next;
    }
}
```





## 08-01. 三步问题

### 描述

[链接](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

```
三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
 输入：n = 3 
 输出：4
 说明: 有四种走法
```

### 分析

典型的动态规划，当前状态等于之前三个状态的总和。

可以优化空间复杂度, 不优化更好理解

也可以采用递归，至上而下，动态规划是空间换时间

### 实现

```java
class Solution {
    public int waysToStep(int n) {
        if (n <= 2) return n;
        int[] dp = new int[n + 1];
        dp[n] = 1;
        dp[n - 1] = 2;
        dp[n - 2] = 4;
        for (int i = n - 3; i > 0; i--) {
            dp[i] = (dp[i + 1] + dp[i + 2]) % 1000000007 + dp[i + 3];
            dp[i] = dp[i] % 1000000007;
        }
        return dp[1];

    }
}
```



## 08-02. 迷路的机器人

### 描述

[链接](https://leetcode-cn.com/problems/robot-in-a-grid-lcci/)

```
设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。
网格中的障碍物和空位置分别用 1 和 0 来表示。
返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
解释: 
输入中标粗的位置即为输出表示的路径，即
0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）
```

### 分析

这是一个典型的回溯。但是需要注意的是：

* 只用找到一条路径即可，即找到一条路径就不用继续回溯了。因此`dfs`的返回值一定需要标识是否已经找到结果。如果找到结果，直接返回，否则，继续`dfs`
* 由于只能往右或者往下走，不需要一个全局的 `visted`来标识哪些地方已经访问过。
* 减枝， 如果某个点已经确定无法到达重点，那么该点和障碍其实是一样的，将该点标识为障碍，避免重复计算该点

### 实现

```java
class Solution {
    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {

        List<List<Integer>> ans = new ArrayList<>();
        if (obstacleGrid == null || obstacleGrid.length == 0) {
            return ans;
        }
        int row = obstacleGrid.length - 1;
        int col = obstacleGrid[0].length - 1;
        if (obstacleGrid[row][col] == 1) {
            return ans;
        }


        dfs(obstacleGrid, ans, 0, 0, obstacleGrid.length - 1, obstacleGrid[0].length - 1);
        return ans;

    }
    private boolean dfs(int[][] nums, List<List<Integer>> ans, int i, int j, int row, int col) {
        if (i == row && j == col) {
            // 得到一个结果, 加入结果，返回true， 表示已经得到最终结果，后续不需要再遍历了。
            List<Integer> location = new ArrayList<>();
            location.add(i);
            location.add(j);
            ans.add(location);
            return true;
        }
        // 超出边界或者遇到障碍物，返回false， 表示此路不通
        if (i == row + 1 || j == col + 1 || nums[i][j] == 1) {
            return false;
        }
		
        // 将该点加入到路径中
        List<Integer> location = new ArrayList<>();
        location.add(i);
        location.add(j);
        ans.add(location);
        
        // 尝试往右走，返回往右是否有路径到达
        boolean isTrue = dfs(nums, ans, i, j + 1, row, col);
        if (isTrue == true) {
            // 往右已经有路径到达了，不用回溯和尝试了，直接返回结果
            return true;
        }
        
        // 往右走，没有路径到达，尝试往下走
        isTrue = dfs(nums, ans, i + 1, j, row, col);
        if (isTrue == true) {
            // 往下走，有路径到达，返回正确结果
            return true;
        }
        
        // 往右和往下都没有路径到达，回溯，删除刚才加入路径的点
        ans.remove(ans.size() - 1);
        nums[i][j] = 1;  // 减枝，很关键，标时这个点无法到达终点，即和障碍一样，标时为障碍
        return false;
    }
}
```



## 08-03. 魔术索引

### 描述

[链接](https://leetcode-cn.com/problems/magic-index-lcci/)

```
魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

输入：nums = [0, 2, 3, 4, 5]
输出：0
说明: 0下标的元素为0
```

### 分析

关键信息： 魔术索引是 索引等于当前值的索引、数组有序。

因为数组有序，比如说遍历到索引为`5`的地方， `nums[5]` 的值有以下几种情况：

* 等于5， 那么找到第一个魔术了，直接返回。
* 大于 5， 比如等于 8。 由于数组递增，那么 索引为5的后面一定大于等于8， 即索引为6、7的地方一定不会是魔数，直接跳到8再判断
* 小于5， 此时不能判断任何东西，判读下一个索引，即6 是否是魔数

### 实现

```java
class Solution {
    public int findMagicIndex(int[] nums) {
        int index = 0;
        while (index < nums.length) {
            // 找到结果了，直接返回
            if (nums[index] == index) {
                return index;
            }
			
            // 满足第二种情况，索引直接跳到nums[index]
            if (nums[index] > index) {
                index = nums[index];
            } else {
                // 不能判断任何东西，继续下一个
                index += 1;
            }
        }
        return -1;
    }
}
```



## 08-04. 幂集

### 描述

[链接](https://leetcode-cn.com/problems/power-set-lcci/)

```
幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。

说明：解集不能包含重复的子集。
 输入： nums = [1,2,3]
 输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

```

### 分析

方法1：

典型的回溯。需要考虑的问题是：

* 本身集合不含重复的元素，那么就不用考虑顺序的问题。
* 结果集不能包含重复的元素，那么中间过程只用考虑后面的部分。比如第一个数为1， 已经包含了大部分情况，当寻找以 2 开头的结果的时候，不应该考虑1. 即  `2 1 3`一定会在 `1, 2, 3`之后找到，此时重复了。



方法2：

当1 和 2 都已经找到的时候，即 `[],[1], [2], [1,2]`， 加入只需要将每一个加入3即可，原来的还在，然后新增加入3的。

### 实现

```java
/**
	回溯
*/
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Deque<Integer> path = new LinkedList<>();

        dfs(nums, 0, ans, path);
        return ans;
    }

    private void dfs(int[] nums, int index, List<List<Integer>> ans, Deque<Integer> path) {
        ans.add(new ArrayList<>(path));
        for (int i = index; i < nums.length; i++) {
            path.push(nums[i]);
            dfs(nums, i + 1, ans, path);
            path.pop();  
        }
    }
}

/**
	方法2
*/
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(new ArrayList<>());
        for (int num : nums) {
            int preLength = ans.size();
            for (int i = 0; i < preLength; i++) {
                List<Integer> temp = new ArrayList<>(ans.get(i));
                temp.add(num);
                ans.add(temp);
            }
        }
        return ans;
    }

}
```



